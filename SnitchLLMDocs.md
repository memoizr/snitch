# Snitch Documentation

*This file was automatically generated by concatenating documentation files.*

---

## From: What is Snitch.md

# Kotlin's Most Elegant HTTP Framework

In today's microservices-driven world, creating robust, well-documented, and maintainable HTTP APIs has become a critical challenge for development teams. **Snitch** emerges as a game-changing solution in this landscape—a lightweight, type-safe Kotlin framework designed to help developers build production-grade HTTP layers with minimal effort while automatically generating comprehensive documentation.

## The Snitch Advantage: Why It's Transforming How We Build APIs

Snitch isn't just another web framework. It's a thoughtfully designed layer built on established embedded web servers like Undertow, offering the perfect balance of performance, type safety, and developer experience. Thanks to Kotlin's inlining capabilities, Snitch delivers exceptional performance without sacrificing readability or maintainability.

### What Sets Snitch Apart From Traditional API Frameworks

- **Zero-Effort Documentation**: Snitch automatically generates complete OpenAPI 3.0 documentation without requiring a single line of documentation code
- **Pure Kotlin Approach**: No reflection, annotations, or code generation for production code
- **Expressive DSL**: Creates the most readable and maintainable API for building HTTP services
- **Strong Type Safety**: Comprehensive parameter validation and domain type mapping
- **Performance-First Design**: As lightweight and fast as the underlying web server
- **Seamless Coroutines Support**: Async by default without sacrificing readability
- **Minimal Overhead**: Small learning curve despite its powerful DSL capabilities

## Getting Started with Snitch in Minutes

Adding Snitch to your project is straightforward:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

And creating your first API is just as simple:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.snitch
import snitch.dsl.routes
import snitch.dsl.response.ok

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("/hello") isHandledBy { "world".ok }
        }
        .start()
        .serveDocumenation()
}
```

This minimal example creates a service that:
- Responds with "world" when you make a GET request to `/hello`
- Automatically generates and serves interactive API documentation at `/docs`

## Snitch's Core Features: The Building Blocks of Modern APIs

### 1. Expressive Routing with Intuitive Syntax

Snitch's DSL allows you to define routes in a clear, intuitive way that makes even complex routing structures easy to understand:

```kotlin
val usersController = routes {
    POST() with body<CreateUserRequest>() isHandledBy createUser
    POST("login") with body<LoginRequest>() isHandledBy userLogin

    userId / "posts" / {
        authenticated {
            GET() onlyIf principalEquals(userId) isHandledBy getPosts
            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost

            GET(postId) isHandledBy getPost
            PUT(postId) with body<UpdatePostRequest>() onlyIf principalEquals(userId) isHandledBy updatePost
            DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
        }
    }
}
```

The DSL is flexible enough to support different team preferences—routes can be grouped by path, by HTTP method, or in a hybrid approach. This adaptability makes Snitch suitable for teams with different coding styles and organizational preferences.

### 2. Comprehensive Type-Safe Parameter Handling

Snitch's parameter handling system ensures all inputs are validated and mapped to appropriate domain types:

```kotlin
// Path parameters
val userId by path(ofUserId)
val postId by path(ofPostId)

// Query parameters with validation
val limit by query(ofNonNegativeInt(max = 30))
val offset by query(ofNonNegativeInt())
val sort by optionalQuery(ofEnum<Sorting>(), default = NEW)

// Headers with custom validation
val accessToken by header(ofValidAccessToken)

// Custom validators for domain types
val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }
val ofValidAccessToken = stringValidator("valid jwt") { jwt().validate(it) }
```

This approach ensures that by the time your handler code runs, all parameters have been validated and transformed into their proper domain types, eliminating the need for repetitive validation code.

### 3. Powerful Middleware System

Snitch provides a flexible middleware system that simplifies cross-cutting concerns:

```kotlin
// Simple logging middleware
val Router.log get() = decorateWith {
    logger().info("Begin Request: ${request.method.name} ${request.path}")
    next().also {
        logger().info("End Request: ${request.method.name} ${request.path} ${it.statusCode.code}")
    }
}

// Transaction middleware for database operations
val Router.withTransaction get() = decorateWith { 
    transaction { next() } 
}

// Apply middleware to routes
val rootRouter = routes {
    log {
        withTransaction {
            "users" / usersController
            "posts" / postsController
        }
    }
}
```

Middleware can be applied to entire route hierarchies or individual endpoints, giving you precise control over behavior.

### 4. Advanced Access Control with Guards and Conditions

Snitch's guard system provides a clean, expressive syntax for controlling access to endpoints:

```kotlin
// Define conditions
val hasAdminRole = condition("hasAdminRole") {
    when (role) {
        ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Not an admin".forbidden())
    }
}

val isResourceOwner = condition("isResourceOwner") {
    if (principal.id == request[resourceId]) ConditionResult.Successful
    else ConditionResult.Failed("Not the resource owner".forbidden())
}

// Apply conditions to endpoints
DELETE("resource" / resourceId) onlyIf (isResourceOwner or hasAdminRole) isHandledBy { deleteResource() }
```

Conditions support logical operators for complex access rules and can be applied to entire route hierarchies, providing a powerful yet readable way to implement authorization.

### 5. Automated Documentation That's Always Up-to-Date

Perhaps Snitch's most impressive feature is its ability to generate complete OpenAPI 3.0 documentation with absolutely no additional effort:

```kotlin
snitch(GsonJsonParser)
    .onRoutes(rootRouter)
    .generateDocumentation()
    .servePublicDocumenation()
    .start()
```

Every input, output, parameter, and response code is automatically documented, giving you interactive Swagger UI pages that stay perfectly in sync with your code. This eliminates the documentation drift that plagues many API projects.

### 6. Seamless Integration with Shank for Dependency Injection

Snitch integrates with Shank, a high-performance dependency injection library:

```kotlin
// Define modules with dependencies
object ApplicationModule : ShankModule {
    val logger = single { -> LoggerImpl() }
    val clock = single { -> Clock.systemUTC() }
}

object RepositoryModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
}

// Use dependencies in handlers
val getUsers by handling {
    val logger = ApplicationModule.logger()
    val usersRepo = RepositoryModule.usersRepository()
    
    logger.info("Fetching all users")
    usersRepo.getUsers().ok
}
```

Shank provides best-in-class performance with strictly type-safe dependency management, built-in cycle detection, and zero reflection overhead—all in a lightweight package.

## Real-World Applications: Where Snitch Shines

Snitch excels in a variety of scenarios:

### Microservices Architecture

In microservices environments, Snitch offers:
- **Light resource footprint**: Runs in as little as 12MB of RAM
- **Fast startup time**: Minimal overhead means services start quickly
- **Automatic documentation**: Each service self-documents its API
- **Strong contract enforcement**: Type safety ensures API contracts are maintained

### High-Performance APIs

When performance is critical, Snitch delivers:
- **Minimal overhead**: Thin layer on top of high-performance web servers
- **Low GC pressure**: Careful design minimizes object creation
- **No reflection**: Zero runtime reflection for request handling
- **Shallow call stack**: Optimized for execution speed

### Teams with Documentation Requirements

For teams that need to maintain API documentation:
- **Zero documentation effort**: Documentation generated automatically
- **Always up-to-date**: Documentation reflects the actual code
- **Interactive Swagger UI**: Test endpoints directly from documentation
- **OpenAPI 3.0 compatibility**: Integrates with API management tools

## Best Practices for Building with Snitch

### 1. Domain-Driven Design

Snitch encourages mapping HTTP inputs to domain types:

```kotlin
// Transform raw string to domain type
val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }
val userId by path(ofUserId)

// In handler, work with domain types
val getUser by handling {
    // userId is already a UserId domain type
    userRepository().getUser(request[userId]).ok
}
```

This approach creates a clean separation between your HTTP layer and domain logic.

### 2. Middleware for Cross-Cutting Concerns

Use middleware for aspects that span multiple endpoints:

```kotlin
// Apply logging, authentication, and transactions
routes {
    log {
        authenticated {
            withTransaction {
                "users" / usersController
            }
        }
    }
}
```

This keeps your handlers focused on business logic rather than infrastructure concerns.

### 3. Granular Access Control

Leverage Snitch's condition system for fine-grained access control:

```kotlin
onlyIf(hasAdminRole) {
    "admin" / adminController
}

"users" / userId / "posts" / {
    GET() isHandledBy getPosts // Anyone can read posts
    POST() onlyIf principalEquals(userId) isHandledBy createPost // Only post owner can create
    DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost // Owner or admin can delete
}
```

This makes your authorization rules explicit and declarative.

## The Future of API Development with Snitch

In an era where API development often involves significant boilerplate and documentation overhead, Snitch offers a refreshing alternative. By combining Kotlin's expressive syntax with automatic documentation generation and strong type safety, Snitch allows developers to focus on what matters most: building great services.

The framework's design philosophy—focused on readability, type safety, and minimal ceremony—represents the future direction of API development tools. As microservices continue to proliferate and API-first development becomes standard practice, tools like Snitch that streamline the development process while enforcing good practices will become increasingly valuable.

## Getting Started with Snitch Today

Ready to transform your API development experience? Here's how to get started:

1. **Add the dependency** to your Gradle build file
2. **Create your first endpoint** with the intuitive DSL
3. **Run your service** and explore the automatically generated documentation
4. **Learn more** through the comprehensive guides and tutorials

Join a growing community of developers who are discovering the power of Snitch for building elegant, performant, and well-documented APIs.

## Conclusion: Why Snitch Exists

The creators of Snitch believe that:
- Code should be as readable as possible
- Simple tasks shouldn't require complex ceremony
- Resources are precious and shouldn't be wasted
- Documentation is crucial but should be generated automatically
- Nobody should ever have to manually edit OpenAPI YAML or JSON files

Whether you're developing microservices, backend APIs, or full applications, Snitch provides the tools you need to create robust, well-documented HTTP layers with minimal effort and maximum readability.

[GitHub Repository](https://github.com/memoizr/snitch) | [Maven Central](https://central.sonatype.com/artifact/io.github.memoizr/snitch-bootstrap) | [Join Discord Community](https://discord.gg/bG6NW3UyxS) 

---

## From: Docs.md

# Snitch

### Introduction

Snitch is a small and typesafe web framework for Kotlin

```kotlin
fun main() {
    snitch(GsonJsonParser).onRoutes {
        GET("hello") isHandledBy { "world".ok }
    }.start()
} 
```

#### Features

- Lightweight and fast.
- Functional approach
- OpenAPI 3 support
- Fully asynchronous execution
- Plain Kotlin. No reflection, code generation, annotation processing.
- Kotlin compiler is enough. No Gradle plugins

### Getting started 

```Kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```
That's it, no need for command line tools, gradle plugins. It's just a simple library.


### Router
#### Routing basics
```kotlin
val root = routes {
    GET("foo") isHandledBy {
        "bar".ok
    }
    POST("foo") with body<FooRequest>() isHandledBy {
        "fooValue: ${body.fooValue}".created
    }
}
```        

The infix style is optional and a classic fluent approach is also supported.

```kotlin
val root = routes {
    GET("foo").isHandledBy {
        "bar".ok
    }
    POST("foo")
        .with(body<FooRequest>())
        .isHandledBy {
        "fooValue: ${body.fooValue}".created
    }
}
```        

Notice that `GET("/foo")` and `GET("foo")` are the same thing

You pass the router to the `onRoutes` function 
```kotlin
fun main() {
    snitch(GsonJsonParser).onRoutes(root).start()
} 
```

Of course in a real application you'd like to separate the route declarations from the endpoint implementations.

```kotlin
val root = routes {
    GET("foo") isHandledBy getFoo
    POST("foo") with body<FooRequest>() isHandledBy postFoo
}

val getFoo by handling {
    "bar".ok
}

val postFoo by parsing<FooRequest>() handling {
    "fooValue: ${body.fooValue}".created
}
```

#### Route Nesting
Services often have hundreds of routes, organized hierarchically. This can be modeled in Snitch:
```kotlin
val root = routes {
    "health" / healthController
    "users" / usersController
    "posts" / postsController
    ...
}

val usersController = routes {
    POST() with body<CreateUserRequest> isHandledBy createUser
    
    userId / {
        GET() isHandledBy getUser
        DELETE() isHandledBy deleteUser
        
        "posts" / {
            GET() isHandledBy getPosts
            POST() with body<CreatePostRequest> isHandledBy createPost
            postId / {
                GET() isHandledBy getPost
            }
        }
    }
}
```

This will define the following routes:
```
POST users
GET users/{userId}
DELETE users/{userId}
GET users/{userId}/posts
POST users/{userId}/posts
GET users/{userId}/posts/{postId}
```

Different teams however will have different styles that they endorse, so for those who would rather have a less DRY but more explicit route declaration, they can define the routes as:

```kotlin
val root = routes {
    healthController
    usersController
    postsController
    ...
}
val usersController = routes {
    POST("users") with body<CreateUserRequest> isHandledBy createUser
    
    GET("users" / userId) isHandledBy getUser
    DELETE("users" / userId) isHandledBy deleteUser

    GET("users" / userId / "posts") isHandledBy getPosts
    POST("users" / userId / "posts") with body<CreatePostRequest> isHandledBy createPost
    GET("users" / userId / "posts" / postId) isHandledBy getPost
}
```

The DSL is flexible so for teams that would like a measured and hybrid approach they can define the routes howerver they wish. For example grouping by path for all the actions supported on it:

```kotlin
val root = routes {
    healthController
    usersController
    postsController
    ...
}
val usersController = routes {
    "users" / {
        POST() with body<CreateUserRequest> isHandledBy createUser
    }
    "users" / userId / {
        GET() isHandledBy getUser
        DELETE() isHandledBy deleteUser
    }

    "users" / userId / "posts" / {
        GET() isHandledBy getPosts
        POST() with body<CreatePostRequest> isHandledBy createPost
    }

    "users" / userId / "posts" / postId / {
        GET() isHandledBy getPost
    }
}
```


#### HTTP input parameters

```kotlin
val userId by path()
val showDetails by query(ofBoolean)

val root = routes {
    GET("users" / userId / "profile")
        .with(showDetails)
        .isHandledBy {
            val user = UserId(request[userId])
            if (request[showDetails]) {
                usersRepository().profileDetails(user)
            } else {
                usersRepository().profileSummary(user)
            }.ok
        }
}
```        

Note: `userId` and `showDetails` are typed and validated. `request[showDetails]` will return a `Boolean` and `request[userId]` will return a `String`. If you don't pass a `Validator` such as `ofBoolean`, it defaults to `ofNonEmptyString`.  
Note: you have to declare the usage of a certain parameter in order to use it.

#### Input parameter validation and transformation
All parameters are validated and transformed to another type by default. Here's some more examples, let's add the type parameters explicitly so it's clear what's happening:

```Kotlin
val userId: String by path(nonEmptyString)  
val filters: Set<String> by path(ofNonEmptySet)
val showDetails: Boolean by path(ofBoolean)
```

#### Custom validations
Although there are a few built in validator-transformers, they offer a relatively weak typing. Best practice involves transforming and validating raw platform types into domain types. For example a `userId` is rarely actually just a string, for example it's unlikely the content of `Shakespeare.txt` parsed as string could possibly be a valid ID for a user. You most likely have a `value class UserId` defined somewhere. Likewise, a search filter is usually something like an `Enum` where you have a set of pre-determined filter values. 

Defining custom validator-transformers in snitch is simple:
```kotlin
value class UserId(val id: UUID)
enum class Filter { EXPIRED, ACTIVE, CANCELLED, PENDING }

val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }

// explicit types can be omitted for conciseness, here included for illustrative purposes
val userId: UserId by path(ofUserId)
val filters: Collection<Filter> by query(ofRepeatableEnum<Filter>())
val filter: Filter by query(ofEnum<Filter>())
```

> *Note:* Snitch is optimized for production code use cases, and in the spirit of Kotlin, it *enforces* best practices. In production, you almost always need to validate and transfrom inputs consistently. Snitch lets you do this in only one line of code in most cases, leading to a more concise, explicit and consistent codebase, making it easier to maintain larger codebases and for new developers to quickly become productive. 

#### Optional input parameters
Declaring a parameter with `query` or `header` will make it required. If the parameter is not supplied a `400` message will be returned specifying that that particular parameter was expected but not provided, as well as any other parameter that also does not pass validation. Optional parameters can be declared as such:


```kotlin
// request[sort] is nullable
val sort: Sorting? by optionalQuery(ofEnum<Sorting>())
```

The optionality functionality is quite powerful, offering a clear and consistent way of specifying default values as well as defining a behaviour for when these values are provided as empty as or as invalid inputs:

```kotlin
// request[sort] is not nullable, NEW is the default value
val sort: Sorting by optionalQuery(ofEnum<Sorting>(), default = NEW)

val limit: Int by optionalQuery(ofNonNegativeInt, default = 20, emptyAsMissing = true, invalidAsMissing = true)
val offset: Int by optionalQuery(ofNonNegativeInt, default = 0, emptyAsMissing = true, invalidAsMissing = true)
```

#### Parameter naming
Snitch aims at being as concise and as less verbose as possible while delivering a full feature set for production use-cases. In this spirit when you define an input parameter such as `val q by query()` it will create a named query parameter that should be supplied as such for example:`?q=urlencodedquery`. Note that the name of the parameter `val` in the codebase is by default the same name as in the API. If you want it to be different, it's simple:
```kotlin
val searchQuery by query(name = "searchQuery")
```

`limit` and `offset` here are defined so that if these parameters were not provided, or provided incorrectly, a default value would be provided instead. This is in case a "fail quietly" behaviour is desired. By default, a `fail explicitly` behaviour is supported, so empty or invalid inputs will return a 400 to inform the API user they're probably doing something wrong.

#### Unsafe, undocumented parameter parsing
While Snitch *enforces* best practices, leading to a less verbose and more consistent codebase that implements them, it also supports an *unsafe* traditional approach. If you want to access a parameter sneakily, and you don't care for the parameter to be included in the documentation, you can do it very simply with the cowboy-friendly syntax:

```kotlin
val getCows by handling {
    ...
    request.queryParams("numberOfCows")
    request.headerParams("ranch")
    request.pathParams("ranchId")
    ...
}
```
Although this approach is supported for niche use cases, it is strongly discouraged that this be used for most production applications unless there is a good reason for it.

#### Repeated parameters
In HTTP one of the hidden challenges to creating a robust and production grade API is that of handling the edge case of query or header parameters provided repeatedly when exactly one or at most one is expected. By default `val searchQuery by query()` expects exactly one value being provided and `val searchQuery by optionalQuery()` provides at most one semantics, unexpected repetition will result in 400. Support for repeated parameters can be made explicity by using `... by query(ofStringSet)` for example, which uses a repeatable validator. Custom validator for repeatable can be created in a very similar way to non-repeatable validators:

```kotlin
val ofUserId = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }
```
#### Body parameter
Body parameters are treated differently than other input parameters as they are used in different ways. While it's common to share the same query parameters or headers between several endpoints (for example consider `limit`, `offset`, `orderBy`, `Access-Token` and so on), body parameters are often single use. Snitch aims at encouraging best  practices while reducing verbosity and clutter as much as possible, and in that spirit body parameter types are declared very simply:
```kotlin
POST("mypath") with body<MyRequest>() isHandleBy {
    // already parsed to MyRequest domain type
    request.body
}
```
This approach is typesafe, so if you were to omit the declaration of the body type, it would not be possible for you to access it within the handler:

```kotlin
POST("mypath") isHandleBy {
    // this resolves to Kotlin's Nothing special type and would not compile
    request.body
}
```
Binary path can also be supported inituitively by: `with(body<ByteArray>())`

### Middleware 
Snitch supports a very powerful and flexible middleware mechanism that can be used to implement a wide variety of features. Let's see how you can use it to create a simple logging behaviour applied to a route hierarchy:

```kotlin
val Router.log get() = decorateWith {
    logger().info("Begin Request: ${request.method.name} ${request.path}")
    next().also {
        logger().info("End Request: ${request.method.name} ${request.path} ${it.statusCode.code} ${it.value(parser)}")
    }
}
```

here `log` is a custom defined middleware logging behaviour. Its usage is very intuitive, and it's clear that such behaviour should be applied to any route defined within its block. Defining a new middleware is as straightforward as possible, here's the identity middleware, that simply calls the next action:
```kotlin
val Router.identity get() = decorateWith { next() }
```

the code block provided to `decorateWith` works similarly to the way handlers work, you can still access the request parameter in the same way with `request[myParam]` and can return responses with `ok` `created` `badRequest()` etc like in normal handlers.

Calling `next()` executes the code in the block of any nested middleware until it gets to the code block of the handler. `next()` returns the response from the next layer of the middleware and as such it can be transformed as appropriate. 

#### Order of execution
The order of execution, that is, what code is executed by the `next()` call, is dependent on the order of declaration. It works as your intuition would expect, inside out, from most nested to least nested:
```kotlin
//called second
log {
    // called first
    statistics {
        GET() ...
    }
}
```

### Security and access control
middleware allows for the implementation of powerful and granular access control systems. Here's a realistic example:

```kotlin
val Router.authenticated
    get() = transformEndpoints {
        with(listof(accessToken)).decorate {
            when (request[accessToken]) {
                is Authentication.Authenticated -> next()
                is Authentication.Unauthenticated -> UNAUTHORIZED()
            }
        }
    }

val accessToken: Authentication by header(validAccesstoken)

val validAccesstoken = validator<String, Authentication> { jwt().validate(it) }

sealed interface Authentication {
    data class Authenticated(val claims: JwtClaims) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object ExpiredToken : Unauthenticated
    object MissingToken : Unauthenticated
    object InvalidClaims : Unauthenticated
}
```

and this is how this is used:
```kotlin
authenticated {
        ...
        GET(userId / "posts") isHandledBy getPosts
        ...
    }
}
```
now, there's a lot to unpack in a few lines of code, let's break it down:
```kotlin
val Router.authenticated
    get() = decorateEndpoints {
        withHeader(accessToken).decorate {
            when (request[accessToken]) {
                is Authentication.Authenticated -> next()
                is Authentication.Unauthenticated -> UNAUTHORIZED()
            }
        }
    }
```

`decorateEndpoints` will apply whatever transformation inside the block to any endpoint to which this will be applied. `withHeader(accessToken)` is declaring and adding the `accessToken` header parameter to the endpoints, documentation will reflect that. `request[accessToken]` parses, validates and transforms the access token provided in the headers. It returns a domain type, and we can proceed to the next layer of middleware in case the token is valid, and return a 401 error in case it is not.

### Dependency Injection with Shank

Snitch integrates seamlessly with [Shank](/tutorials/UsingShank.md), the highest-performing dependency injection library available for the JVM. Shank provides best-in-class performance with strictly type-safe dependency management, built-in cycle detection, and zero reflection overhead - all in a lightweight 300kb package.

#### Setting Up Shank Modules

Organize your dependencies by creating modules:

```kotlin
import snitch.shank.ShankModule
import snitch.shank.single
import snitch.shank.new

// Application-wide dependencies
object ApplicationModule : ShankModule {
    val clock = single { -> Clock.systemUTC() }
    val logger = single { -> LoggerImpl() }
    val now = new { -> Instant.now(clock()) }
}

// Database-related dependencies
object DatabaseModule : ShankModule {
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/postgres",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    val database = single { -> PostgresDatabase(connection()) }
}

// Repository dependencies
object RepositoryModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }
}
```

#### Using Dependencies in Handlers

Inject dependencies into your handlers:

```kotlin
val getUsers by handling {
    val logger = ApplicationModule.logger()
    val usersRepo = RepositoryModule.usersRepository()
    
    logger.info("Fetching all users")
    usersRepo.getUsers().ok
}

val createUser by parsing<CreateUserRequest>() handling {
    val usersRepo = RepositoryModule.usersRepository()
    usersRepo.createUser(body.name, body.email).created
}
```

#### Creating Middleware with Dependency Injection

Combine middleware with dependency injection for powerful patterns:

```kotlin
val Router.withLogging get() = decorateWith {
    val logger = ApplicationModule.logger()
    logger.info("Request: ${request.method} ${request.path}")
    next().also {
        logger.info("Response: ${it.statusCode}")
    }
}

val Router.withTransaction get() = decorateWith {
    val db = DatabaseModule.database()
    db.transaction {
        next()
    }
}
```

Then use these in your routes:

```kotlin
routes {
    withLogging {
        withTransaction {
            "users" / {
                GET() isHandledBy getUsers
                POST() with body<CreateUserRequest>() isHandledBy createUser
            }
        }
    }
}
```

For a comprehensive guide to using Shank with Snitch, see the [Using Shank with Snitch](/tutorials/UsingShank.md) guide.

### Database Integration
Snitch is an HTTP focused tool, and as such it abstains from offering solutions to non-HTTP problems such as deeply integrating with databases. We believe it is better to leave that job to specialized tools such as Jooq or Exposed. That said what snitch does offer is an extremely easy way of integrating with such tools. For example, here's how simple it is to declare that endpoints within a given hierarchy should all execute the code within an `Exposed` transaction:

```kotlin
withTransaction {
    POST() with body<CreateUserRequest>() isHandledBy createUser
    POST("login") with body<LoginRequest>() isHandledBy userLogin

    userId / "posts" / {
        authenticated {
            GET() onlyIf principalEquals(userId) isHandledBy getPosts
            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost

            GET(postId) isHandledBy getPost
            PUT(postId) with body<UpdatePostRequest>() onlyIf principalEquals(userId) isHandledBy updatePost
            DELETE(postId) onlyif (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
        }
    }
}
```

here's how withtransaction is implemented:
```kotlin
// transaction {} from Exposed framework
val Router.withTransaction get() = decorateWith { transaction { next() } }
```
The ease with which this feature can be implemented is a testament to the power and flexibility of middleware. This can also be done in a granular way, by endpoint:
```kotlin
GET() decorated withExposedTransaction onlyIf principalEquals(userId) isHandledBy getPosts
```
and this is the declaration of this decoration, which can be reused across different endpoints:
```kotlin
val withExposedTransaction = decoration { transaction { next() } }
```
this code hardly needs any explanation, in the spirit of Snitch philosophy. 

the transaction example was just one way of showing how the flexibility and power of the dsl makes it extremely convenient to integrate with purpose built tools for database and other purposes. Snitch focuses on HTTP, but it seamlessly integrates with other tools with other focuses.

### Guards
Still on top of the same underlying mechanism we've built a powerful and granular guard mechanism, here's an example of it at work:

```kotlin
val requestWrapper.role: Role get() = (request[accessToken] as Authentication.Authenticated).claims.role

val hasAdminRole = condition {
    when (role) {
        ADMIN -> Successful()
        else -> Failed(FORBIDDEN())
    }
}
```
and this is how it's used
```kotlin
DELETE(postId) onlyIf hasAdminRole isHandledBy deletePost
```

`onlIf` takes a condition which can be either `Successful` or `Failed` and will either proceed with the request or terminate early accordingly.

This offers a high degree of granularity when specifying access control as applied to individual routes.

#### Composing conditions
Conditions are composable and support basic boolean logic operations:

```kotlin
DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
```

The code above hardly needs an explanation for what it's doing, despite the fact that it's not trivial behaviour.

here's the definition of `principalEquals`:
```kotlin
fun principalEquals(param: Parameter<out Any, *>) = condition {
    if (principal.value == request[param]) Successful()
    else Failed(FORBIDDEN())
}

val RequestWrapper.principal: UserId get() = (request[accessToken] as Authentication.Authenticated).claims.userId
```

#### Reusing conditions
Although it's possible to customize each and every endpoint to lock it down to the exact security guarantees your business logic needs to enforce, it's often the case that you need to share the same guard logic across several endpoints. Snitch offers two ways of doing this, the first one is obvious:

```kotlin
val ownerOrAdmin = principalEquals(userId) or hasAdminRole

DELETE(postId) onlyIf ownerOrAdmin isHandledBy deletePost
```

The second one is even more generic, as it can be applied to an entire sub-hierarchy of routes. It works similarly to how middleware does:

```kotlin
onlyIf(principalEquals(userId) or hasAdminRole) {
    ...
    DELETE(postId) isHandledBy deletePost
    PATCH(postId) with body<UpdatePostRequest>() isHandledBy updatePost
    ...
}
```

Note that this approach to Guards is in line with what we call "Snitch's way" or "Snitchy". Of course good old imperative checks inside the handler are still possible and supported, and in some cases that's the best thing to do. But sticking to Snitch's way allows for more consistent, readable and manageable codebases at any scale.

### Error handling
Although Snitch encourages a more functional approach to errors, it also supports global exception handling for both unexpected behaviour and for flow control.

```kotlin
snitch(GsonJsonParser)
    .onRoutes(root)
    .handleException(MyException::class) { exception ->
        MyCustomErroResponse(exception.reason)
            .also { logger().error(it.toString()) }
            .badRequest()
    }
    .start()
```

Note that the body of the exception handler works like the normal handlers', with the only difference that it has a referfence to the exception being handled, thie `it` of the lambda, which can be optionally named as in the example above. Note that it's not necessary to return an error response, it's possible to return an alternative successful response instead. You can see that there is a lot of functionality packed in a small amount of code, yet it still remains fairly intuitive and readable.

#### Polymorphic error handling
Note that error handling is polymorphic, so if `MyException` extends `MyBaseException` `.handleException(MyBaseException::class)...` would handle `MyException` as well as any other subclass of `MyBaseException`. For this reason, ordering of the declaration of exception handlers matters. You should always put the most specific handlers first, otherwise a more generic polymorphic handler would handle the exception instead. Note that this feature implementation relies on some reflection, and while it's relatively efficient, it's not as efficient as a more functional approach. For that reason this should not be used as a main flow control mechanism for performance critical applications.

### Testing
Snitch supports a fluent and concise integration testing DSL. In accordance with the rest of the library, it is designed with simplicity, intuitiveness and readability in mind. The expressiveness and simplicity is aimed at encouraging a TDD approach. Here is what simple tests would look like, including an example of the base class and application object:
```kotlin
class HealthTest : BaseTest() {
    @Test
    fun `foo does bar`() {
        GET("/foo/bar")
            .expectCode(200)
            .expectBody("""{"status": "ok"}""")
    }
    
    @Test
    fun `post`() {
        POST("/foo/bar")
            .withBody(myRequestBody)
            .expectCode(200)
            .expectBody("""{"status": "ok"}""")
    }
}

@TestInstance(Testinstance.Lifecycle.PER_CLASS)
abstract class BaseTest : SnitchTest({ Application.setup(it) }) {
    @BeforeAll
    fun beforeAll() = super.before()

    @AfterAll
    fun afterAll() = super.after()
}

object Application {
    fun setup(port: Int): RoutedService =
        snitch(GsonJsonParser, snitchConfig(Service(port = port)))
            .onRoutes(rootRouter)
            .handleExceptions()
}
```
please refer to the `example` module in the repository source code for more in-depth examples involving real-world use cases complete with database setup and access, dependency injection and more.

### Intellij integration
Snitch has the best in class IntelliJ integration plugin and it ships by default with the IDE: Jetbrain's Kotlin plugin. that's all that's needed to unleash the full power of snitch and have autocompletion, syntax higlighting and so on. because snitch aims at being plain kotlin only, without reflection or annotation processing or code generation, the kotlin compiler is fully capable of understanding each aspect of the library and its uses. Snitch usage errors are more often than not resolved at compile time. One of the leading design principles of Snitch is that the user of the library should always be able to use the IDE to navigate to middleware definitions, follow the nesting of routes upsream and downstream, and so on. A user should never be in the position of not knowing what some code does. They might not necessarily understand every aspect of how the internals work, but they should at the very least be able to see the internals, and explore them with their IDE. The pure kotlin approach makes this easy.

### Showcase

#### DSL extension usecase: API versioning

It is often the case that your API will need versioning for backwards compatibility with deployed clients. There are several approaches to versioning. A common and annoying problem is handling relatively minor version differences on only a subset of endpoints. Setting up a whole separate path hierarchy may be an overkill in such cases. E.g you want to have these routes:

```
GET /v1/hey/there/foo
GET /v2/hey/there/foo
GET /v1/hey/all/bar
```

This is how easy it is to extend Snitch's DSL to support this type of versioning:

```kotlin
val baseVersion = "v1"

baseVersion / {
    "hey" / {
        "there" / {
            GET("foo") isHandledBy { "this is foo v1".ok }
            GET("foo").v2 isHandledBy { "this is foo v2".ok }
        }
        "all" / {
            GET("bar") isHandledBy { "this is bar v1".ok }
        }
    }
}

// demo only, use a more robust path editing logic for production
val <T : Any> Endpoint<T>.v2 get() = copy(path = path.replace("/$baseVersion/", "/v2/"))
```

And that's it. Endpoints are data classes and can be customized like any other data class in Kotlin.  

This style is also supported, if you prefer:
```kotlin
GET("foo") v 2 isHandledBy { "this is foo v2".ok }
```
This uses an extension function instead of an extension property.
```
// demo only, use a more robust path editing logic for production
infix fun <T: Any> Endpoint<T>.v(version: Int) = copy(
    path = path.replace("/$baseVersion/", "/v$version/")
)
```

### Coroutine support
Snitch is asynchronous by default, and as such it works well with coroutines. You can use your suspend functions just like normal code, just use a `coHandling` or `isCoHandledBy`. 

```kotlin
val getUsers by coHandling {
    usersRepository().getUsersAsync().ok
}

GET("users") isHandledBy getUsers
GET("posts") isCoHandledBy { postsRepository().getPostsAsync().ok }
```

Coroutine support are not included by default, so you need to add this to your gradle build file:
```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-coroutines:1.0.0")
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = freeCompilerArgs + "-Xcontext-receivers"
    }
}
```
Depending on usage patterns we might include coroutines as part of the main API and thus remove the need for the `coHandling` and `isCoHandledBy` functions and extra gradle code.

### FAQ
#### How does Snitch handle concurrency?
Snitch is a thin layer on top of the underlying HTTP server. By default, that's Undertow, so Snitch will handle concurrency in the samw way Undertow does.
#### Just how "light" and "fast" is Snitch?
Snitch is a small library with very little overhead on top of the HTTP server. By default that's Undertow, and multiple benchmarks have put Undertow consistently in the top 3 servers in the JVM for years. Undertow is also one of the lightest embedded HTTP servers. In short, Snitch is in practice as fast and as lightweight as Undertow is.
#### How does the automatic OpenApi 3 documentation generation work?
Snitch uses information from the type system to know everything there is to know about an endpoint and its inputs and outputs. 
#### Why is Snitch typesafe?
Snitch enforces explicit declarations on any inputs and outputs for each endpoint, and these declarations include type information. This way when the inputs are used inside the handlers, they are already verified and transformed, and any unexpected inputs automatically and consistently dealt with.
#### How does Snitch handle HTTP sessions and cookies? 
It doesn't and it won't. Snitch is designed for highly scalable stateless applications. Session management, caching and any other stateful solution, can and should be implemented at the infrastructure layer.
#### Does Snitch support X database integration?
Yes it does as long as X has a Java api. The middleware system's flexibility makes it easy to add support for X. No Snitch does not ship with X support by default because your needs are most likely than not unique and you'd rather have an easy way of doing it your way than a default that won't suit you.
#### How does Snitch handle scalability? 
Snitch is a low overhead, fast execution framework. It is stateless by default, and it's designed for deployment in clusters. Snitch once containerized and deployed in Kubernetes, ECS or analogous clusters will scale to fit any requirement. Most likely your limiting factor will be your database system.
#### How does Snitch handle security, particularly in terms of input validation?
Snitch offers both Validators, Guards and Middleware as powerful tools to implement granular and effective security. Used in combination, these features will greatly enhance the security of your endpoints. Refer to the documentation to learn how to use these features. Do keep in mind security is a multi-layer issue, so do not rely exclusively on application layer security for your critical use cases.
#### How does Snitch compare to other Kotlin web frameworks like Ktor or Spring Boot in terms of performance and ease of use?
Snitch was developed keeping a variety of other frameworks in mind, shamelessly taking inspiration from them. As such it is aimed at improving the development experience over those frameworks too. In the case of Spring, we believe that framework is overly complicated for most use cases. The "convention over configuration" approach most often than not shifts the burden from the explicit, to the implicit, greatly aggravating cognitive load. KTor is somewhat better in that regard, but we believe it does not go far enough and does not exploit Kotlin's full potential, despite its pedigree. Snitch is aimed at being the most powerful simple tool you can use while retaining excellent readability qualities and a minimal API.

---

## From: QuickStart.md

# Snitch Quick Start Guide

This guide will help you quickly set up a basic web service using Snitch.

## Installation

Add Snitch to your project dependencies:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

## Hello World Example

Create a simple "Hello World" service:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.snitch
import snitch.dsl.routes
import snitch.dsl.response.ok

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("hello") isHandledBy { "world".ok }
        }
        .start()
        .serveDocumenation()
}
```

This creates a service that:
- Responds with "world" when you make a GET request to `/hello`
- Automatically generates API documentation available at `/docs`

## Creating a RESTful API

Let's create a more realistic example with multiple endpoints:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.*
import snitch.dsl.response.*

// Define our data classes
data class User(val id: String, val name: String, val email: String)
data class CreateUserRequest(val name: String, val email: String)

// In-memory storage for this example
val users = mutableMapOf<String, User>()

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            "users" / {
                // GET /users - List all users
                GET() isHandledBy { 
                    users.values.toList().ok 
                }
                
                // POST /users - Create a new user
                POST() with body<CreateUserRequest>() isHandledBy { 
                    val id = java.util.UUID.randomUUID().toString()
                    val user = User(id, body.name, body.email)
                    users[id] = user
                    user.created
                }
                
                // GET /users/{userId} - Get a specific user
                userId / {
                    GET() isHandledBy {
                        val id = request[userId]
                        users[id]?.ok ?: "User not found".notFound()
                    }
                    
                    // DELETE /users/{userId} - Delete a user
                    DELETE() isHandledBy {
                        val id = request[userId]
                        if (users.containsKey(id)) {
                            users.remove(id)
                            "User deleted".ok
                        } else {
                            "User not found".notFound()
                        }
                    }
                }
            }
        }
        .start()
        .serveDocumenation()
}

// Define a path parameter
val userId by path()
```

## Parameter Validation

Let's enhance our API with parameter validation:

```kotlin
// Define validated parameters
val limit by query(ofNonNegativeInt(max = 30, default = 10))
val offset by query(ofNonNegativeInt(default = 0))
val email by query(ofEmail)

// Define our own custom validator
val ofEmail = stringValidator("valid email") { 
    it.contains("@") && it.contains(".") 
}

// Use in routes
"users" / {
    // GET /users?limit=10&offset=0
    GET() with listOf(limit, offset) isHandledBy {
        users.values
            .toList()
            .drop(request[offset])
            .take(request[limit])
            .ok
    }
    
    // GET /users/search?email=user@example.com
    "search" / {
        GET() with email isHandledBy {
            val searchEmail = request[email]
            users.values
                .filter { it.email == searchEmail }
                .toList()
                .ok
        }
    }
}
```

## Adding Middleware

Implement a simple logging middleware:

```kotlin
// Simple logging middleware that doesn't require parameters
val Router.log get() = decorateWith {
    println("➡️ ${request.method} ${request.path} - Request started")
    val response = next()
    println("⬅️ ${request.method} ${request.path} - Response: ${response.statusCode}")
    response
}

// Apply middleware to routes
routes {
    log {
        "users" / {
            // All user routes will be logged
            GET() isHandledBy { users.values.toList().ok }
            // ...
        }
    }
}
```

## Authentication

Implement a basic authentication system:

```kotlin
// Define the header parameter for authentication
val accessToken by header(
    condition = validAccessToken,
    name = "Authorization",
    description = "Bearer token for authentication"
)

// Validator for access token
val validAccessToken = stringValidator { token ->
    if (token.startsWith("Bearer ")) {
        val actualToken = token.substring(7)
        if (isValidToken(actualToken)) {
            Authentication.Authenticated(JWTClaims(getUserId(actualToken), getRole(actualToken)))
        } else {
            Authentication.InvalidToken
        }
    } else {
        Authentication.MissingToken
    }
}

// Authentication result model
sealed interface Authentication {
    data class Authenticated(val claims: JWTClaims) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object MissingToken : Unauthenticated
}

// Data class for JWT claims
data class JWTClaims(val userId: UserId, val role: Role)
data class UserId(val value: String)
enum class Role { USER, ADMIN }

// Authentication middleware with proper parameter declaration
val Router.authenticated get() = decorateWith(accessToken) {
    when (val auth = request[accessToken]) {
        is Authentication.Authenticated -> {
            next() // Proceed to the handler
        }
        is Authentication.Unauthenticated -> "Authentication required".unauthorized()
    }
}

// Extension properties to access authentication data
val RequestWrapper.principal: UserId get() = 
    (request[accessToken] as Authentication.Authenticated).claims.userId
val RequestWrapper.role: Role get() = 
    (request[accessToken] as Authentication.Authenticated).claims.role

// Apply to protected routes
routes {
    "public" / {
        // Public endpoints...
    }
    
    "api" / {
        authenticated {
            // Protected endpoints...
            "profile" / {
                GET() isHandledBy { 
                    getUserProfile(request.principal).ok 
                }
            }
            
            // Example of using principal in a handler
            "posts" / {
                GET() isHandledBy { 
                    getPostsByUser(request.principal).ok 
                }
                
                POST() with body<CreatePostRequest>() isHandledBy {
                    createPost(request.principal, body.title, body.content).created
                }
            }
        }
    }
}
```

## Using Conditions

Implement access control with conditions:

```kotlin
// Define conditions
val isAdmin = condition("isAdmin") {
    if (request.role == Role.ADMIN) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("Admin access required".forbidden())
    }
}

// Condition to check if the user is the owner of a resource
fun isOwner(resourceIdParam: Parameter<String, *>) = condition("isOwner") {
    val resourceId = request[resourceIdParam]
    val resource = getResourceById(resourceId)
    
    if (resource?.ownerId == request.principal.value) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("You don't have permission to access this resource".forbidden())
    }
}

// Apply conditions to endpoints
routes {
    authenticated {
        // Admin-only endpoint
        "admin" / {
            GET("dashboard") onlyIf isAdmin isHandledBy { 
                getAdminDashboard().ok 
            }
        }
        
        // User can only access their own posts
        "posts" / postId / {
            GET() onlyIf isOwner(postId) isHandledBy { getPost() }
            PUT() onlyIf isOwner(postId) with body<UpdatePostRequest>() isHandledBy { updatePost() }
            DELETE() onlyIf isOwner(postId) isHandledBy { deletePost() }
        }
    }
}
```

## Handler Functions

Snitch provides a clean way to define handler functions that can access the request context:

```kotlin
// Define a path parameter
val postId by path()

// Handler for getting a post
private val getPost by handling {
    postsRepository().getPost(PostId(request[postId]))
        ?.toResponse?.ok
        ?: "Post not found".notFound()
}

// Handler for deleting a post
private val deletePost by handling {
    postsRepository().deletePost(request.principal, PostId(request[postId]))
        .noContent
}

// Handler for getting all posts for the current user
private val getPosts by handling {
    postsRepository().getPosts(request.principal)
        .toResponse.ok
}

// Handler with request body parsing
private val createPost by parsing<CreatePostRequest>() handling {
    postsRepository().putPost(
        CreatePostAction(
            request.principal,
            PostTitle(body.title),
            PostContent(body.content),
        )
    ).mapSuccess {
        SuccessfulCreation(value).created
    }.mapFailure {
        FailedCreation().badRequest()
    }
}

// Usage in routes
routes {
    authenticated {
        "posts" / {
            GET() isHandledBy getPosts
            POST() with body<CreatePostRequest>() isHandledBy createPost
            
            postId / {
                GET() isHandledBy getPost
                DELETE() isHandledBy deletePost
            }
        }
    }
}
```

## Testing Your API

Test your endpoints with the built-in testing DSL:

```kotlin
class UserApiTest : SnitchTest({ port -> setupApp(port) }) {
    
    @Test
    fun `get all users returns 200`() {
        GET("/users")
            .expectCode(200)
            .expectBodyContains("[]") // Initially empty
    }
    
    @Test
    fun `create user returns 201`() {
        POST("/users")
            .withBody("""{"name":"John","email":"john@example.com"}""")
            .expectCode(201)
            .expectBodyContains("John")
    }
}
```

## Next Steps

Now that you have a basic understanding of Snitch, explore:

1. **Documentation Generation**: Learn how to enhance your API documentation
2. **Error Handling**: Implement global exception handlers
3. **Custom Validators**: Create complex validation rules
4. **Coroutines**: Use Kotlin coroutines for asynchronous operations

For more details, check out:
- [Snitch Documentation](../Docs.md)
- [In Depth Guides](../in%20depth/)

---

## From: README.md

# Snitch Tutorials
Welcome to the Snitch tutorials! This section contains step-by-step guides to help you master different aspects of Snitch.

## Available Tutorials

- [Quick Start Guide](QuickStart.md) - Get up and running with Snitch quickly
- [Using Shank](UsingShank.md) - Learn how to use Shank for dependency injection
- [Shank Patterns](ShankPatterns.md) - Advanced patterns for using Shank effectively
- [Shank in Action](ShankInAction.md) - Build a real-world application with Shank and Snitch


---

## From: ShankInAction.md

# Shank in Action: Building a Real-World Application

This tutorial demonstrates how to use Shank, Snitch's powerful dependency injection library, to build a maintainable and testable real-world application. We'll create a blog platform with user authentication, post management, and comments.

## What is Shank?

[Shank](https://github.com/memoizr/shank) is a lightweight, high-performance dependency injection library for Kotlin that integrates seamlessly with Snitch. It provides:

- **Industry-leading performance**: Unmatched startup and runtime performance
- **Zero reflection**: No runtime overhead or class scanning
- **Strict type safety**: Will never throw runtime exceptions related to types
- **Polymorphism support**: Interface-based dependency injection
- **Testing support**: Easy factory overriding for testing

## Project Setup

Let's start by setting up our project structure:

```kotlin
// build.gradle.kts
plugins {
    kotlin("jvm") version "1.9.0"
    application
}

dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("org.jetbrains.exposed:exposed-core:0.41.1")
    implementation("org.jetbrains.exposed:exposed-dao:0.41.1")
    implementation("org.jetbrains.exposed:exposed-jdbc:0.41.1")
    implementation("org.postgresql:postgresql:42.6.0")
    implementation("de.mkammerer:argon2-jvm:2.11")
    
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")
    testImplementation("io.mockk:mockk:1.13.5")
}
```

## Domain Model

First, let's define our domain models:

```kotlin
// src/main/kotlin/blog/domain/models.kt
package blog.domain

import java.time.Instant
import java.util.UUID

data class User(
    val id: UUID,
    val username: String,
    val email: String,
    val createdAt: Instant
)

data class Post(
    val id: UUID,
    val title: String,
    val content: String,
    val authorId: UUID,
    val createdAt: Instant,
    val updatedAt: Instant
)

data class Comment(
    val id: UUID,
    val postId: UUID,
    val authorId: UUID,
    val content: String,
    val createdAt: Instant
)
```

## Setting Up Shank Modules

Now, let's organize our application using Shank modules. This is where Shank's elegance and convenience really shine:

```kotlin
// src/main/kotlin/blog/infrastructure/ApplicationModule.kt
package blog.infrastructure

import blog.domain.Clock
import blog.domain.SystemClock
import snitch.shank.ShankModule
import snitch.shank.new
import snitch.shank.single
import java.time.Instant

object ApplicationModule : ShankModule {
    // Core application dependencies
    val clock = single<Clock> { -> SystemClock() }
    
    // Creates a new timestamp each time it's called
    val now = new { -> Instant.now(clock().utc()) }
    
    // Logger is a singleton
    val logger = single { -> LoggerFactory.getLogger("blog-app") }
}
```

Notice how we're using `single` for dependencies that should have only one instance, and `new` for dependencies that should be created fresh each time they're requested. This is one of Shank's conveniences - clear, explicit scoping.

Let's add our database module:

```kotlin
// src/main/kotlin/blog/infrastructure/DatabaseModule.kt
package blog.infrastructure

import org.jetbrains.exposed.sql.Database
import snitch.shank.ShankModule
import snitch.shank.single

object DatabaseModule : ShankModule {
    // Database connection is a singleton
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/blog",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    // Database wrapper is a singleton
    val database = single { -> PostgresDatabase(connection()) }
}
```

And our repositories:

```kotlin
// src/main/kotlin/blog/infrastructure/RepositoryModule.kt
package blog.infrastructure

import blog.domain.repositories.*
import blog.infrastructure.repositories.*
import snitch.shank.ShankModule
import snitch.shank.single

object RepositoryModule : ShankModule {
    // Bind implementations to interfaces
    val userRepository = single<UserRepository> { -> 
        PostgresUserRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
    
    val postRepository = single<PostRepository> { -> 
        PostgresPostRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
    
    val commentRepository = single<CommentRepository> { -> 
        PostgresCommentRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
}
```

Finally, let's add our security module:

```kotlin
// src/main/kotlin/blog/infrastructure/SecurityModule.kt
package blog.infrastructure

import de.mkammerer.argon2.Argon2Factory
import snitch.shank.ShankModule
import snitch.shank.single
import java.security.KeyPairGenerator
import java.security.interfaces.RSAPrivateCrtKey

object SecurityModule : ShankModule {
    // Generate a key pair for JWT signing
    val keyPair = single { ->
        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")
        keyPairGenerator.initialize(2048)
        keyPairGenerator.genKeyPair()
    }

    // Extract keys from the key pair
    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }
    val publicKey = single { -> keyPair().public }
    
    // Password hashing
    val argon = single { -> Argon2Factory.create() }
    val passwordHasher = single<PasswordHasher> { -> Argon2PasswordHasher(argon()) }
    
    // JWT management
    val jwtManager = single { -> JWTManager(privateKey(), publicKey()) }
}
```

## The Power of Shank: Service Layer

Now, let's create our service layer. This is where Shank's convenience becomes evident - we can easily compose our services using dependencies from different modules:

```kotlin
// src/main/kotlin/blog/application/ServiceModule.kt
package blog.application

import blog.application.services.*
import blog.infrastructure.ApplicationModule
import blog.infrastructure.RepositoryModule
import blog.infrastructure.SecurityModule
import snitch.shank.ShankModule
import snitch.shank.single

object ServiceModule : ShankModule {
    // User service with dependencies from multiple modules
    val userService = single<UserService> { -> 
        UserServiceImpl(
            RepositoryModule.userRepository(),
            SecurityModule.passwordHasher(),
            SecurityModule.jwtManager(),
            ApplicationModule.now()
        ) 
    }
    
    // Post service
    val postService = single<PostService> { -> 
        PostServiceImpl(
            RepositoryModule.postRepository(),
            RepositoryModule.userRepository(),
            ApplicationModule.now()
        ) 
    }
    
    // Comment service
    val commentService = single<CommentService> { -> 
        CommentServiceImpl(
            RepositoryModule.commentRepository(),
            RepositoryModule.postRepository(),
            ApplicationModule.now()
        ) 
    }
}
```

## API Layer with Snitch and Shank

Now, let's create our API layer using Snitch and Shank together:

```kotlin
// src/main/kotlin/blog/api/Router.kt
package blog.api

import blog.application.ServiceModule
import blog.domain.exceptions.NotFoundException
import blog.domain.exceptions.UnauthorizedException
import snitch.dsl.*
import snitch.dsl.response.*
import snitch.parsers.GsonJsonParser
import snitch.router.decorateWith
import snitch.service.RoutedService
import snitch.undertow.snitch

// Request/response models
data class LoginRequest(val username: String, val password: String)
data class LoginResponse(val token: String)

data class CreatePostRequest(val title: String, val content: String)
data class PostResponse(val id: String, val title: String, val content: String, val author: String)

// Path parameters
val userId by path()
val postId by path()
val commentId by path()

// Header parameters for authentication
val accessToken by header(
    condition = validAccessToken,
    name = "Authorization",
    description = "Bearer token for authentication"
)

// Validator for access token
val validAccessToken = stringValidator { token ->
    if (token.startsWith("Bearer ")) {
        try {
            // Use jwtManager from SecurityModule to validate the token
            val jwtManager = SecurityModule.jwtManager()
            val userId = jwtManager.validateToken(token.substring(7))
            Authentication.Authenticated(userId)
        } catch (e: Exception) {
            Authentication.InvalidToken
        }
    } else {
        Authentication.MissingToken
    }
}

// Authentication result model
sealed interface Authentication {
    data class Authenticated(val userId: String) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object MissingToken : Unauthenticated
}

// Authentication middleware using Shank with proper parameter declaration
val authenticated = decorateWith(accessToken) {
    when (val auth = request[accessToken]) {
        is Authentication.Authenticated -> {
            // Set user ID in request attributes for use in handlers
            request.attributes["userId"] = auth.userId
            next()
        }
        is Authentication.Unauthenticated -> "Authentication required".unauthorized()
    }
}

// Main router
val router = routes {
    "api" / {
        "auth" / {
            // Login endpoint
            POST("login") with body<LoginRequest>() isHandledBy {
                val userService = ServiceModule.userService()
                try {
                    val token = userService.login(body.username, body.password)
                    LoginResponse(token).ok
                } catch (e: UnauthorizedException) {
                    "Invalid credentials".unauthorized()
                }
            }
        }
        
        "posts" / {
            // Get all posts
            GET() isHandledBy {
                val postService = ServiceModule.postService()
                postService.getAllPosts().ok
            }
            
            // Get post by ID
            postId / {
                GET() isHandledBy {
                    val postService = ServiceModule.postService()
                    try {
                        val id = request[postId]
                        postService.getPostById(id).ok
                    } catch (e: NotFoundException) {
                        "Post not found".notFound()
                    }
                }
            }
            
            // Protected routes
            authenticated {
                // Create post
                POST() with body<CreatePostRequest>() isHandledBy {
                    val postService = ServiceModule.postService()
                    val userId = request.attributes["userId"] as String
                    val post = postService.createPost(userId, body.title, body.content)
                    post.created
                }
                
                // Update post
                postId / {
                    PUT() with body<CreatePostRequest>() isHandledBy {
                        val postService = ServiceModule.postService()
                        val userId = request.attributes["userId"] as String
                        val id = request[postId]
                        try {
                            val post = postService.updatePost(id, userId, body.title, body.content)
                            post.ok
                        } catch (e: NotFoundException) {
                            "Post not found".notFound()
                        } catch (e: UnauthorizedException) {
                            "Not authorized to update this post".forbidden()
                        }
                    }
                    
                    // Delete post
                    DELETE() isHandledBy {
                        val postService = ServiceModule.postService()
                        val userId = request.attributes["userId"] as String
                        val id = request[postId]
                        try {
                            postService.deletePost(id, userId)
                            "Post deleted".ok
                        } catch (e: NotFoundException) {
                            "Post not found".notFound()
                        } catch (e: UnauthorizedException) {
                            "Not authorized to delete this post".forbidden()
                        }
                    }
                }
            }
        }
    }
}
```

## Application Entry Point

Finally, let's create our application entry point:

```kotlin
// src/main/kotlin/blog/Application.kt
package blog

import blog.api.router
import blog.infrastructure.DatabaseModule
import snitch.config.SnitchConfig
import snitch.parsers.GsonJsonParser
import snitch.undertow.snitch

fun main() {
    // Initialize database
    val database = DatabaseModule.database()
    database.createSchema()
    
    // Start the service
    snitch(GsonJsonParser, SnitchConfig(port = 3000))
        .onRoutes(router)
        .handleExceptions()
        .start()
        .serveDocumenation()
}
```

## Testing with Shank

One of Shank's most convenient features is its support for testing. Let's see how to test our service layer:

```kotlin
// src/test/kotlin/blog/application/services/UserServiceTest.kt
package blog.application.services

import blog.domain.User
import blog.domain.repositories.UserRepository
import blog.infrastructure.ApplicationModule
import blog.infrastructure.RepositoryModule
import blog.infrastructure.SecurityModule
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.time.Instant
import java.util.UUID
import kotlin.test.assertEquals

class UserServiceTest {
    private val mockUserRepository = mockk<UserRepository>()
    private val mockPasswordHasher = mockk<PasswordHasher>()
    private val mockJwtManager = mockk<JwtManager>()
    
    @BeforeEach
    fun setup() {
        // Override real implementations with mocks
        RepositoryModule.userRepository.overrideFactory { -> mockUserRepository }
        SecurityModule.passwordHasher.overrideFactory { -> mockPasswordHasher }
        SecurityModule.jwtManager.overrideFactory { -> mockJwtManager }
        
        // Set up a fixed timestamp for testing
        val fixedInstant = Instant.parse("2023-01-01T00:00:00Z")
        ApplicationModule.now.overrideFactory { -> fixedInstant }
    }
    
    @AfterEach
    fun tearDown() {
        // Restore original implementations
        RepositoryModule.userRepository.restore()
        SecurityModule.passwordHasher.restore()
        SecurityModule.jwtManager.restore()
        ApplicationModule.now.restore()
    }
    
    @Test
    fun `login should return token when credentials are valid`() {
        // Arrange
        val username = "testuser"
        val password = "password123"
        val hashedPassword = "hashed_password"
        val userId = UUID.randomUUID()
        val token = "jwt_token"
        
        val user = User(
            id = userId,
            username = username,
            email = "test@example.com",
            createdAt = Instant.now()
        )
        
        every { mockUserRepository.findByUsername(username) } returns user
        every { mockPasswordHasher.verify(hashedPassword, password) } returns true
        every { mockJwtManager.createToken(userId.toString()) } returns token
        
        // Act
        val userService = ServiceModule.userService()
        val result = userService.login(username, password)
        
        // Assert
        assertEquals(token, result)
        verify { mockUserRepository.findByUsername(username) }
        verify { mockPasswordHasher.verify(hashedPassword, password) }
        verify { mockJwtManager.createToken(userId.toString()) }
    }
}
```

## Why Shank is Convenient

As you've seen throughout this tutorial, Shank offers several conveniences that make it an excellent choice for dependency injection in Snitch applications:

1. **Explicit Dependencies**: Dependencies are clearly defined and easy to trace, making your code more maintainable.

2. **No Magic**: Unlike other DI frameworks, Shank doesn't use reflection or annotations, making it faster and more predictable.

3. **Type Safety**: Shank leverages Kotlin's type system to ensure type safety at compile time.

4. **Testability**: Shank's ability to override dependencies makes testing straightforward and reliable.

5. **Performance**: Shank's lightweight design ensures minimal overhead, making it ideal for high-performance applications.

6. **Modularity**: Shank encourages organizing your code into cohesive modules, improving code organization.

7. **Flexibility**: Shank supports various dependency scopes (singleton, factory, scoped), giving you control over object lifecycles.

## Conclusion

In this tutorial, we've built a complete blog application using Snitch and Shank. We've seen how Shank's convenient dependency injection system makes it easy to:

- Organize code into logical modules
- Manage dependencies between different parts of the application
- Test components in isolation
- Create maintainable and flexible code

Shank's simplicity and power make it an excellent choice for dependency injection in Kotlin applications, especially when combined with Snitch's elegant routing and request handling.

## Next Steps

To further explore Shank and Snitch:

1. Check out the [Shank Patterns](./ShankPatterns.md) guide for advanced usage patterns
2. Explore the [Using Shank](./UsingShank.md) guide for more details on Shank's features
3. Look at the example project in the repository for a complete working example 

---

## From: ShankPatterns.md

# Advanced Shank Design Patterns

This document explores powerful design patterns and techniques for using Shank effectively in your applications. While Shank is intuitive and straightforward by design, these patterns can help you tackle more complex scenarios with elegance and maintainability.

## Table of Contents

1. [Module Organization Strategies](#module-organization-strategies)
2. [Dependency Layering](#dependency-layering)
3. [Testing Patterns](#testing-patterns)
4. [Domain-Driven Design with Shank](#domain-driven-design-with-shank)
5. [Feature Toggling](#feature-toggling)
6. [Lifecycle Management](#lifecycle-management)
7. [Configuration Injection](#configuration-injection)
8. [Conditional Dependencies](#conditional-dependencies)

## Module Organization Strategies

### Domain Module Pattern

Organize your modules by domain context rather than technical layers:

```kotlin
// Instead of "RepositoryModule", "ServiceModule", etc.
object UserDomainModule : ShankModule {
    // Domain-specific repositories
    val userRepository = single<UserRepository> { -> UserRepositoryImpl() }
    
    // Domain-specific services
    val userService = single<UserService> { -> UserServiceImpl(userRepository()) }
    
    // Domain-specific validation
    val userValidator = single { -> UserValidator() }
}

object PaymentDomainModule : ShankModule {
    val paymentRepository = single<PaymentRepository> { -> PaymentRepositoryImpl() }
    val paymentService = single<PaymentService> { -> PaymentServiceImpl(paymentRepository()) }
    val paymentProcessor = single { -> PaymentProcessor() }
}
```

This approach aligns better with domain-driven design principles and improves cohesion, making each module more focused and self-contained.

### Feature Module Pattern

For larger applications, organize modules by features that cut across domain boundaries:

```kotlin
object AuthenticationModule : ShankModule {
    val passwordEncoder = single { -> BCryptPasswordEncoder() }
    val tokenService = single { -> JwtTokenService() }
    val authenticationService = single { -> 
        AuthenticationServiceImpl(
            UserDomainModule.userRepository(),
            passwordEncoder(),
            tokenService()
        )
    }
}

object CheckoutModule : ShankModule {
    val checkoutService = single { -> 
        CheckoutServiceImpl(
            UserDomainModule.userService(),
            PaymentDomainModule.paymentService(),
            ShippingDomainModule.shippingService()
        ) 
    }
}
```

This pattern maximizes code organization around user-facing features, making it clear which dependencies belong to which features.

## Dependency Layering

Shank allows you to create clear architectural boundaries while maintaining explicit dependency relationships:

```kotlin
// Infrastructure Layer
object InfrastructureModule : ShankModule {
    val database = single { -> PostgresDatabase(connectionString()) }
    val httpClient = single { -> OkHttpClient() }
    val cache = single { -> RedisCache(redisConfig()) }
}

// Repository Layer
object RepositoryModule : ShankModule {
    val userRepository = single<UserRepository> { -> 
        UserRepositoryImpl(InfrastructureModule.database())
    }
}

// Service Layer
object ServiceModule : ShankModule {
    val userService = single<UserService> { -> 
        UserServiceImpl(RepositoryModule.userRepository())
    }
}

// Application Layer
object ApplicationModule : ShankModule {
    val userController = single { -> 
        UserController(ServiceModule.userService())
    }
}
```

This approach enforces the dependency rule (dependencies only point inward) while maintaining Shank's explicit dependency tracing.

## Testing Patterns

### Test Double Pattern

Create specialized modules for testing that override production dependencies:

```kotlin
// Production module
object PaymentModule : ShankModule {
    val paymentGateway = single<PaymentGateway> { -> StripePaymentGateway() }
    val paymentService = single { -> PaymentServiceImpl(paymentGateway()) }
}

// Test module
object TestPaymentModule : ShankModule {
    val mockPaymentGateway = single<PaymentGateway> { -> MockPaymentGateway() }
    
    fun setupForTesting() {
        // Override the real implementation with our mock
        PaymentModule.paymentGateway.overrideFactory { -> mockPaymentGateway() }
    }
    
    fun tearDown() {
        // Restore the original implementation
        PaymentModule.paymentGateway.restore()
    }
}
```

Then in your tests:

```kotlin
class PaymentServiceTest {
    @BeforeEach
    fun setup() {
        TestPaymentModule.setupForTesting()
    }
    
    @AfterEach
    fun tearDown() {
        TestPaymentModule.tearDown()
    }
    
    @Test
    fun `test payment processing`() {
        // This will use the mock gateway
        val paymentService = PaymentModule.paymentService()
        
        // Configure the mock
        val mockGateway = TestPaymentModule.mockPaymentGateway()
        mockGateway.setupToReturnSuccessfulPayment()
        
        // Execute the test
        val result = paymentService.processPayment(100.0, "USD")
        
        // Verify the result
        assertEquals(PaymentStatus.SUCCESS, result.status)
    }
}
```

This approach provides fine-grained control over which dependencies are mocked in tests while preserving the rest of the dependency tree.

### Component Testing Pattern

For integration/component testing, create specialized test configurations:

```kotlin
object TestDatabaseModule : ShankModule {
    val inMemoryDatabase = single { -> H2Database() }
    
    fun setupTestEnvironment() {
        // Override production database with in-memory version
        InfrastructureModule.database.overrideFactory { -> inMemoryDatabase() }
    }
}

object IntegrationTestModule : ShankModule {
    val testHelper = single { -> IntegrationTestHelper() }
    
    fun prepareIntegrationTest() {
        TestDatabaseModule.setupTestEnvironment()
        // Additional test setup...
    }
}
```

## Domain-Driven Design with Shank

Shank works beautifully with Domain-Driven Design (DDD) principles:

```kotlin
// Domain layer - contains pure domain logic
object DomainModule : ShankModule {
    val userFactory = single { -> UserFactory() }
    val paymentPolicy = single { -> BusinessPaymentPolicy() }
}

// Application layer - orchestrates use cases
object ApplicationModule : ShankModule {
    val createUserUseCase = single { -> 
        CreateUserUseCase(
            DomainModule.userFactory(),
            RepositoryModule.userRepository()
        )
    }
    
    val processPaymentUseCase = single { -> 
        ProcessPaymentUseCase(
            DomainModule.paymentPolicy(),
            RepositoryModule.paymentRepository()
        )
    }
}

// Infrastructure layer - provides implementations
object InfrastructureModule : ShankModule {
    val userRepositoryImpl = single<UserRepository> { -> 
        PostgresUserRepository(DatabaseModule.database())
    }
}
```

This structure helps maintain a clean domain model while keeping infrastructure concerns separate. The domain module doesn't depend on any external modules, preserving the domain's purity.

## Feature Toggling

Implement feature toggling with Shank:

```kotlin
object FeatureToggleModule : ShankModule {
    val featureManager = single { -> FeatureManager() }
    
    // Define toggleable implementations
    val paymentProcessor = single<PaymentProcessor> { ->
        val featureManager = featureManager()
        if (featureManager.isEnabled("new-payment-processor")) {
            NewPaymentProcessor()
        } else {
            LegacyPaymentProcessor()
        }
    }
    
    // Conditionally provide implementations
    val betaFeatures = single { -> 
        val featureManager = featureManager()
        if (featureManager.isEnabled("beta-features")) {
            BetaFeaturesImpl() 
        } else {
            EmptyBetaFeatures()
        }
    }
}
```

This pattern allows you to toggle features at runtime while maintaining Shank's type safety and explicit dependency structure.

## Lifecycle Management

For dependencies that need initialization or cleanup:

```kotlin
object ResourceModule : ShankModule {
    val databaseClient = single { -> 
        DatabaseClient().also { client ->
            // Register shutdown hook
            Runtime.getRuntime().addShutdownHook(Thread {
                client.close()
            })
        }
    }
    
    // Auto-closeable resources
    val httpClient = single { -> 
        OkHttpClient().also { client ->
            registerForCleanup(client)
        }
    }
    
    // Track resources that need to be closed
    private val managedResources = mutableListOf<AutoCloseable>()
    
    private fun registerForCleanup(resource: AutoCloseable) {
        managedResources.add(resource)
    }
    
    fun closeAll() {
        managedResources.forEach { it.close() }
        managedResources.clear()
    }
}
```

To use in your application:

```kotlin
fun main() {
    try {
        // Use your application...
        val app = startApplication()
        app.waitForShutdown()
    } finally {
        ResourceModule.closeAll()
    }
}
```

## Configuration Injection

Manage configuration values through Shank modules:

```kotlin
object ConfigModule : ShankModule {
    val config = single { -> 
        ConfigFactory.load() 
    }
    
    val databaseConfig = single { -> 
        val config = config()
        DatabaseConfig(
            url = config.getString("db.url"),
            username = config.getString("db.username"),
            password = config.getString("db.password")
        )
    }
    
    val apiConfig = single { -> 
        val config = config()
        ApiConfig(
            baseUrl = config.getString("api.baseUrl"),
            timeout = config.getDuration("api.timeout")
        )
    }
}

// Usage in other modules
object DatabaseModule : ShankModule {
    val database = single { -> 
        val config = ConfigModule.databaseConfig()
        Database.connect(
            url = config.url,
            username = config.username,
            password = config.password
        )
    }
}
```

This pattern centralizes configuration while maintaining type safety.

## Conditional Dependencies

Provide different implementations based on environment or other conditions:

```kotlin
object NotificationModule : ShankModule {
    val emailSender = single<EmailSender> { ->
        when (Environment.current) {
            Environment.PRODUCTION -> SmtpEmailSender(ConfigModule.emailConfig())
            Environment.STAGING -> SmtpEmailSender(ConfigModule.emailConfig())
            Environment.DEVELOPMENT -> ConsoleEmailSender()
            Environment.TEST -> NoOpEmailSender()
        }
    }
    
    val pushNotificationService = single<PushNotificationService> { ->
        if (Environment.isProduction()) {
            FirebasePushService(ConfigModule.firebaseConfig())
        } else {
            LoggingPushService()
        }
    }
}
```

This approach provides environment-specific implementations while maintaining the same dependency interface.

## Summary

These patterns demonstrate Shank's flexibility and power in handling complex dependency scenarios while maintaining its core advantages of explicitness, type safety, and performance. By applying these patterns, you can build well-structured, maintainable applications that scale with your needs.

Shank's design philosophy emphasizes clarity and explicitness, making it not just a technical tool but a design aid that helps you think more clearly about your application's structure and dependencies.

---

## From: UsingShank.md

# Using Shank with Snitch

[Shank](https://github.com/memoizr/shank) is a lightweight dependency injection (DI) library for Kotlin that integrates seamlessly with Snitch. This guide covers how to use Shank effectively in your Snitch applications.

## Introduction to Shank

Shank provides best-in-class performance among all dependency injection frameworks on the JVM, with a simple, strictly type-safe approach that eliminates common pitfalls. Its remarkable features include:

- **Industry-leading performance**: Unmatched startup and runtime performance
- **Zero reflection**: No runtime overhead or class scanning
- **Cycle detection**: Built-in circular dependency detection using only the Kotlin compiler
- **Strict type safety**: Will never throw runtime exceptions related to types
- **Runtime resolution**: All dependencies are resolved at runtime, supporting hot reloading
- **Polymorphism support**: Interface-based dependency injection
- **Scoped dependencies**: Context-aware dependency scoping
- **Parameterized injection**: Dependencies can be scoped to injection parameters
- **Testing support**: Easy factory overriding for testing
- **Lightweight**: Only 300kb, with virtually no startup overhead
- **Lazy initialization**: Modules are objects initialized only when needed
- **Infinite extensibility**: Supports any custom dependency resolution strategy

## Adding Shank to Your Project

The Shank library is included as a transitive dependency when you include Snitch, so no additional dependency is needed:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

## Core Concepts

### ShankModule

The primary building block in Shank is the `ShankModule` interface. You create modules by implementing this interface:

```kotlin
object ApplicationModule : ShankModule {
    // Dependencies will be defined here
}
```

### Dependency Scopes

Shank offers three main scopes for dependencies:

1. **Singleton** (`single`) - A single instance for the entire application's lifecycle
2. **Factory** (`new`) - Creates a new instance each time
3. **Scoped** (`scoped`) - Instances are scoped to a specific context

## Defining Dependencies

### Singleton Dependencies

Use `single` for dependencies that should have a single instance throughout the application's lifecycle:

```kotlin
object ApplicationModule : ShankModule {
    // Clock is provided as a singleton
    val clock = single { -> Clock.systemUTC() }
    
    // Logger is a singleton with a typed interface
    val logger = single<Logger> { -> LoggerImpl() }
}
```

### Factory Dependencies (new instance each time)

Use `new` for dependencies that should be recreated each time they're requested:

```kotlin
object ApplicationModule : ShankModule {
    // Returns a new Instant every time it's called
    val now = new { -> Instant.now(clock()) }
}
```

### Scoped Dependencies

Use `scoped` for dependencies that are tied to a specific context or lifecycle:

```kotlin
object SessionModule : ShankModule {
    // User context scoped to a session
    val userContext = scoped { sessionId: String -> UserContext(sessionId) }
}
```

## Dependency Injection with Shank in Snitch

### Creating Modules

In a Snitch application, you typically organize dependencies by creating modules for different parts of your application:

```kotlin
// Database-related dependencies
object DBModule : ShankModule {
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/postgres",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    val database = single { -> PostgresDatabase(connection()) }
}

// Repositories
object RepositoriesModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }
}

// Security-related dependencies
object SecurityModule : ShankModule {
    val keyPair = single { ->
        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")
        keyPairGenerator.initialize(2048)
        keyPairGenerator.genKeyPair()
    }
    
    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }
    val publicKey = single { -> keyPair().public }
    val hasher = single<IPasswordHasher> { -> PasswordHasher(argon()) }
    val argon = single { -> Argon2Factory.create() }
    val jwt = single { -> JWTManager() }
}
```

### Using Dependencies in Handlers

Once you've defined your dependencies, you can use them in your Snitch handlers:

```kotlin
// User repository is injected
val usersRepository = RepositoriesModule.usersRepository()

val createUser by parsing<CreateUserRequest>() handling {
    // jwt manager is injected
    val jwt = SecurityModule.jwt()
    
    // passwordHasher is injected
    val hasher = SecurityModule.hasher()
    
    // Hash the password
    val hashedPassword = hasher.hash(body.password)
    
    // Save the user
    val user = usersRepository.createUser(body.username, hashedPassword)
    
    // Generate a token
    val token = jwt.createToken(user.id)
    
    // Return the response
    CreateUserResponse(user.id, token).created
}
```

## Advanced Shank Features

### Parameterized Dependencies

Shank supports dependencies with parameters:

```kotlin
object CacheModule : ShankModule {
    val cache = single { region: String -> Cache(region) }
}

// Usage
val userCache = CacheModule.cache("users")
val postCache = CacheModule.cache("posts")
```

### Type-bound Dependencies

You can bind an implementation to an interface:

```kotlin
object RepositoriesModule : ShankModule {
    // Bind PostgresUsersRepository to UsersRepository interface
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
}

// Usage
val repo: UsersRepository = RepositoriesModule.usersRepository()
```

### Testing with Shank

Shank makes testing easier by allowing you to override dependencies:

```kotlin
@BeforeEach
fun setup() {
    // Override real implementation with mock
    RepositoriesModule.usersRepository.overrideFactory { -> mockUsersRepository }
}

@AfterEach
fun tearDown() {
    // Restore original implementation
    RepositoriesModule.usersRepository.restore()
    
    // Or reset all overrides
    resetShank()
}
```

## Integrating with Snitch Middleware

You can create middleware that injects dependencies:

```kotlin
val Router.withTransaction get() = decorateWith {
    val database = DBModule.postgresDatabase()
    database.transaction {
        next()
    }
}

// Usage
routes {
    withTransaction {
        POST("users") with body<CreateUserRequest>() isHandledBy createUser
    }
}
```

## Best Practices

1. **Organize by Module**: Group related dependencies in modules
2. **Interface-based Design**: Bind implementations to interfaces
3. **Single Responsibility**: Keep modules focused on a specific area
4. **Lazy Initialization**: Dependencies are only created when needed
5. **Testing**: Use overrides for test mocks

## Complete Example

Here's a complete example of using Shank with Snitch:

```kotlin
import snitch.dsl.*
import snitch.gson.GsonJsonParser
import snitch.shank.ShankModule
import snitch.shank.single

// Define modules
object AppModule : ShankModule {
    val logger = single { -> Logger() }
}

object UserModule : ShankModule {
    val userRepository = single { -> UserRepositoryImpl() }
    val userService = single { -> UserService(userRepository()) }
}

// Define handlers using dependencies
val getUserById by handling {
    val userService = UserModule.userService()
    val logger = AppModule.logger()
    
    logger.info("Getting user with ID: ${request[userId]}")
    
    val user = userService.getUser(request[userId])
    user?.ok ?: "User not found".notFound()
}

// Define parameters
val userId by path()

// Configure routes
fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("users" / userId) isHandledBy getUserById
        }
        .start()
        .serveDocumenation()
}
```

## Performance Advantages

Shank's performance advantages come from several key design decisions:

1. **Zero reflection**: Unlike Spring or Guice which rely on runtime reflection, Shank uses pure Kotlin function references and type inference
2. **No proxy generation**: Dependencies are direct instances, not proxies, eliminating overhead
3. **No annotation processing**: No compile-time code generation or annotation scanning
4. **Lazy evaluation**: Dependencies are only instantiated when needed
5. **Minimal dependency graph traversal**: Optimized dependency resolution algorithm

These advantages result in:
- Faster application startup times
- Lower memory consumption
- Reduced CPU overhead
- Smaller deployment artifacts

## Summary

Shank provides the highest-performing, most type-safe dependency injection solution available for Kotlin applications, with unmatched integration with Snitch. By organizing dependencies into modules and leveraging Shank's powerful yet simple API, you can create maintainable, testable applications with minimal boilerplate and maximum performance.

---

## From: Anatomy-of-Endpoints.md

# Endpoint DSL

Endpoints are the fundamental building blocks of your API in Snitch. This guide explores the internal structure of the Endpoint DSL, explaining how endpoints are defined, configured, and composed to create expressive, type-safe APIs.

## The Endpoint Data Class

At the core of Snitch's routing system is the `Endpoint` data class:

```kotlin
data class Endpoint<T: Any>(
    val method: Method,
    val path: String,
    val parameters: List<Parameter<*, *>> = emptyList(),
    val conditions: List<Condition> = emptyList(),
    val decorations: List<Decoration> = emptyList(),
    val beforeActions: List<RequestWrapper.() -> Response?> = emptyList(),
    val afterActions: List<RequestWrapper.() -> Unit> = emptyList(),
    val handler: (RequestWrapper.() -> T)? = null
)
```

Let's examine each component:

1. **Type Parameter**:
   - `T`: The return type of the handler function, which determines the response type

2. **Properties**:
   - `method`: The HTTP method (GET, POST, etc.)
   - `path`: The URL path, potentially including parameter placeholders
   - `parameters`: List of parameters (path, query, header, body) this endpoint uses
   - `conditions`: List of conditions that must be satisfied for the endpoint to execute
   - `decorations`: List of decorations that modify the endpoint's behavior
   - `beforeActions`: Actions executed before the handler runs
   - `afterActions`: Actions executed after the handler completes
   - `handler`: The function that processes the request and produces a response

The data class design is crucial for Snitch's flexibility and composability. Since endpoints are immutable data objects, they can be transformed and combined in powerful ways without side effects.

## Creating Endpoints

Endpoints are typically created through the HTTP method functions and then configured with additional features.

### HTTP Method Functions

Snitch provides functions for each HTTP method:

```kotlin
fun GET(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.GET, path = ensureLeadingSlash(path))

fun POST(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.POST, path = ensureLeadingSlash(path))

fun PUT(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.PUT, path = ensureLeadingSlash(path))

fun DELETE(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.DELETE, path = ensureLeadingSlash(path))

fun PATCH(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.PATCH, path = ensureLeadingSlash(path))

fun OPTIONS(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.OPTIONS, path = ensureLeadingSlash(path))

fun HEAD(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.HEAD, path = ensureLeadingSlash(path))
```

Each function creates an `Endpoint` with the specified HTTP method and path, returning a fresh `Endpoint` instance ready for further configuration.

**Usage Example**:

```kotlin
GET("users")       // Creates a GET endpoint for /users
POST("users")      // Creates a POST endpoint for /users
PUT("users/123")   // Creates a PUT endpoint for /users/123
```

### Path Construction

Paths can be constructed in several ways:

1. **String literals**:
   ```kotlin
   GET("users/profile")
   ```

2. **Path parameters**:
   ```kotlin
   val userId by path()
   GET("users" / userId)
   ```

3. **Path composition with the `/` operator**:
   ```kotlin
   GET("users" / userId / "posts" / postId)
   ```

The `/` operator is an extension function on `String` that concatenates path segments:

```kotlin
operator fun String.div(other: String): String = 
    "$this/$other".replace("//", "/")

operator fun String.div(param: Parameter<*, *>): String = 
    "$this/{${param.name}}".replace("//", "/")
```

This elegant approach allows paths to be constructed in a readable, composable way.

### Route Nesting

Snitch supports route nesting through a DSL that allows hierarchical organization:

```kotlin
routes {
    "api" / {
        "v1" / {
            "users" / {
                GET() isHandledBy getUsersHandler
                POST() with body<CreateUserRequest>() isHandledBy createUserHandler
                
                userId / {
                    GET() isHandledBy getUserHandler
                    PUT() with body<UpdateUserRequest>() isHandledBy updateUserHandler
                    DELETE() isHandledBy deleteUserHandler
                }
            }
        }
    }
}
```

Behind the scenes, this is implemented using a hierarchical context that tracks the current path prefix:

```kotlin
class RouterContext(private val pathPrefix: String = "") {
    fun String.div(block: RouterContext.() -> Unit) {
        val newContext = RouterContext("$pathPrefix/$this".replace("//", "/"))
        newContext.block()
    }
    
    fun GET(path: String = ""): Endpoint<Any> = 
        Endpoint(Method.GET, "$pathPrefix/$path".replace("//", "/"))
    
    // Other HTTP method functions...
}
```

This approach allows you to organize routes according to your API's logical structure.

## Configuring Endpoints

Once an endpoint is created, it can be configured with various features. These configurations are applied through extension functions that return new `Endpoint` instances with the desired modifications.

### Parameters

Parameters are added using the `with` function and its variants:

```kotlin
fun <T: Any> Endpoint<T>.with(vararg params: Parameter<*, *>): Endpoint<T> =
    copy(parameters = parameters + params)

fun <T: Any> Endpoint<T>.withQueries(vararg params: Parameter<*, *>): Endpoint<T> =
    with(*params)

fun <T: Any> Endpoint<T>.withHeaders(vararg params: Parameter<*, *>): Endpoint<T> =
    with(*params)
```

**Usage Example**:

```kotlin
val limit by query(ofIntRange(1, 100), default = 20)
val offset by query(ofNonNegativeInt, default = 0)
val apiKey by header(ofNonEmptyString)

GET("users")
    .withQueries(limit, offset)
    .withHeaders(apiKey)
```

Internally, these functions simply add the parameters to the endpoint's parameter list, making them available for validation and access in the handler.

### Conditions

Conditions are added using the `onlyIf` function:

```kotlin
infix fun <T: Any> Endpoint<T>.onlyIf(condition: Condition): Endpoint<T> =
    copy(conditions = conditions + condition)
```

**Usage Example**:

```kotlin
val hasAdminRole = condition("hasAdminRole") { /* implementation */ }

GET("admin/dashboard") onlyIf hasAdminRole
```

The `onlyIf` function appends the condition to the endpoint's conditions list. During request processing, all conditions are evaluated before the handler executes.

### Decorations

Decorations are added using the `decorated` function:

```kotlin
infix fun <T: Any> Endpoint<T>.decorated(with: Decoration): Endpoint<T> =
    copy(decorations = decorations + with)
```

**Usage Example**:

```kotlin
val withLogging = decoration { /* implementation */ }

GET("users") decorated withLogging
```

Decorations provide a way to wrap handler execution with custom logic, similar to middleware in other frameworks.

### Before and After Actions

Before and after actions allow executing code before and after the handler:

```kotlin
fun <T: Any> Endpoint<T>.doBefore(action: RequestWrapper.() -> Response?): Endpoint<T> =
    copy(beforeActions = beforeActions + action)

fun <T: Any> Endpoint<T>.doAfter(action: RequestWrapper.() -> Unit): Endpoint<T> =
    copy(afterActions = afterActions + action)
```

**Usage Example**:

```kotlin
GET("users")
    .doBefore { 
        logger.info("Accessing users endpoint")
        // Optionally return a Response to short-circuit
        null 
    }
    .doAfter { 
        logger.info("Completed users endpoint request")
    }
```

These functions append actions to the respective lists in the endpoint. During request processing, before actions run in reverse declaration order (last declared, first executed), while after actions run in declaration order.

## Endpoint Handlers

While we won't delve deeply into handlers here, it's worth understanding how they connect to endpoints:

```kotlin
infix fun <T: Any> Endpoint<T>.isHandledBy(handler: RequestWrapper.() -> T): Endpoint<T> =
    copy(handler = handler)
```

The `isHandledBy` function associates a handler with an endpoint. The handler is a function that:
1. Receives a `RequestWrapper` as its receiver
2. Returns a value of type `T`, which determines the response type

This type-safe design ensures that handlers return appropriate values that can be converted to HTTP responses.

## The Router Interface

The `Router` interface defines a collection of endpoints:

```kotlin
interface Router {
    val endpoints: List<Endpoint<*>>
}
```

Routers can be composed and nested, allowing for modular API organization:

```kotlin
fun routes(block: RouterBuilder.() -> Unit): Router {
    val builder = RouterBuilder()
    builder.block()
    return builder.build()
}
```

The `RouterBuilder` class accumulates endpoints during DSL execution:

```kotlin
class RouterBuilder {
    private val mutableEndpoints = mutableListOf<Endpoint<*>>()
    
    fun <T: Any> endpoint(endpoint: Endpoint<T>) {
        mutableEndpoints.add(endpoint)
    }
    
    fun build(): Router = object : Router {
        override val endpoints = mutableEndpoints.toList()
    }
}
```

This builder-based approach allows for a clean DSL while maintaining immutability of the resulting routers.

## Extension and Customization

One of Snitch's most powerful features is its extensibility. Since endpoints are data classes and the DSL is built from extension functions, you can easily add new capabilities.

### Extending Endpoint with New Capabilities

You can add new features to endpoints by defining extension functions:

```kotlin
fun <T: Any> Endpoint<T>.withTimeout(milliseconds: Long): Endpoint<T> =
    decorated(TimeoutDecoration(milliseconds))

// Usage
GET("slow-operation") withTimeout 5000
```

This approach allows you to create domain-specific extensions tailored to your application's needs.

### Creating DSL Extensions

You can even extend the DSL with new constructs:

```kotlin
infix fun <T: Any> Endpoint<T>.v(version: Int): Endpoint<T> =
    copy(path = path.replace("/v1/", "/v$version/"))

// Usage
GET("v1/users") v 2 isHandledBy getUsersV2Handler
```

This creates an expressive way to define versioned endpoints. Because endpoints are data classes, transformations like this are straightforward and composable.

## Type Safety Aspects

Snitch's Endpoint DSL is designed with type safety as a primary consideration:

1. **Parameter Type Safety**:
   ```kotlin
   val userId by path(ofLong)
   
   // In the handler:
   val id: Long = request[userId] // Type-safe access
   ```

2. **Handler Return Types**:
   ```kotlin
   GET("users") isHandledBy {
       // Must return a value compatible with the endpoint type
       listOf("user1", "user2").ok
   }
   ```

3. **Condition Composition**:
   ```kotlin
   GET("resource") onlyIf (isAuthenticated and (isResourceOwner or hasAdminRole))
   ```
   The boolean operators (`and`, `or`, `not`) are type-checked at compile time.

4. **Method Chaining**:
   ```kotlin
   GET("users")
       .withQueries(limit, offset)
       .onlyIf(isAuthenticated)
       .doBefore { /* ... */ }
       .isHandledBy { /* ... */ }
   ```
   Each method returns the appropriate endpoint type, ensuring the chain remains type-safe.

This comprehensive type safety catches many potential errors at compile time, dramatically reducing runtime issues.

## Under the Hood: Request Processing

When a request arrives, Snitch processes it through several stages:

1. **Route Matching**: Snitch finds the endpoint that matches the HTTP method and path
2. **Parameter Extraction and Validation**: Parameters are extracted from the request and validated
3. **Condition Evaluation**: All conditions are evaluated; if any fail, the request is rejected
4. **Decoration Setup**: Decorations are arranged to wrap the handler execution
5. **Before Actions**: Before actions are executed in reverse order
6. **Handler Execution**: The handler processes the request
7. **After Actions**: After actions are executed in declaration order

This pipeline is reflected in the `Endpoint` data class structure, with each component corresponding to a stage in request processing.

## Best Practices

Based on the internal workings of endpoints, here are some best practices:

1. **Organize by Resource**: Structure your routes around resources and sub-resources
   ```kotlin
   "users" / {
       GET() // List users
       POST() // Create user
       
       userId / {
           GET() // Get user
           PUT() // Update user
           DELETE() // Delete user
           
           "posts" / {
               // User's posts resources
           }
       }
   }
   ```

2. **Keep Endpoints Focused**: Each endpoint should handle a single responsibility

3. **Extract Shared Logic**: Use decorations and conditions to extract cross-cutting concerns
   ```kotlin
   val authenticated = decorateWith { /* authentication logic */ }
   
   authenticated {
       // All routes here require authentication
   }
   ```

4. **Leverage Type-Safe Parameters**: Define all parameters with appropriate validators
   ```kotlin
   val limit by query(ofIntRange(1, 100), default = 20)
   
   // Better than:
   val limit by query() // String that needs manual validation
   ```

5. **Use Extension Methods for Common Patterns**: Create extension functions for frequent use cases
   ```kotlin
   fun <T: Any> Endpoint<T>.withCache(durationSeconds: Int): Endpoint<T> =
       decorated(CacheDecoration(durationSeconds))
   ```

6. **Modularize Routers**: Break large APIs into smaller, composable routers
   ```kotlin
   val userRoutes = routes { /* user endpoints */ }
   val postRoutes = routes { /* post endpoints */ }
   
   val apiRoutes = routes {
       "api" / {
           "users" / userRoutes
           "posts" / postRoutes
       }
   }
   ```

7. **Follow RESTful Conventions**: Use appropriate HTTP methods for different operations
   ```kotlin
   GET(resourceId)   // Read a resource
   POST()            // Create a resource
   PUT(resourceId)   // Update a resource
   DELETE(resourceId) // Delete a resource
   ```

## Conclusion

The Endpoint DSL in Snitch provides a powerful, type-safe way to define and configure API endpoints. By understanding its internal structure and capabilities, you can create expressive, maintainable APIs that leverage Kotlin's type system for robust error checking.

The data class foundation, combined with extension functions and builders, creates a DSL that is both flexible and type-safe, allowing for easy customization while catching errors at compile time.

This design exemplifies how thoughtful API design can leverage language features to create expressive yet safe interfaces for complex functionality.

---

## From: Anatomy-of-Handlers.md

# Handler DSL

Handlers are the core of your API's business logic in Snitch. They process incoming requests, execute application code, and produce responses. This guide explores the inner workings of Snitch's Handler DSL, explaining how handlers are defined, composed, and integrated with the rest of the framework.

## Handler Fundamentals

At its core, a handler in Snitch is simply a function that:
1. Takes a `RequestWrapper` as its receiver (via Kotlin's function literal with receiver syntax)
2. Returns a value that can be converted to an HTTP response

The basic signature looks like this:

```kotlin
typealias Handler<T> = RequestWrapper.() -> T
```

This simple design allows handlers to:
- Access request data through the `RequestWrapper` receiver
- Return any type that can be serialized to a response
- Leverage Kotlin's powerful type system

Let's explore how this works in practice.

## The RequestWrapper

The `RequestWrapper` is the handler's interface to the incoming request. It provides access to:

```kotlin
interface RequestWrapper {
    val method: Method
    val path: String
    val queryParams: Map<String, Collection<String>>
    val headerParams: Map<String, Collection<String>>
    val pathParams: Map<String, String>
    val parser: Parser
    val attributes: MutableMap<String, Any>
    
    operator fun <T> get(parameter: Parameter<*, T>): T
    
    // Additional utility methods...
}
```

The key components are:

1. **Request metadata**: Method, path, and raw parameter maps
2. **Parser**: For converting strings to/from structured data
3. **Attributes**: A mutable map for storing request-scoped data
4. **Parameter access**: Type-safe access to validated parameters via the `get` operator

The `get` operator is particularly important, as it provides type-safe access to parameters:

```kotlin
val userId = request[userId] // Returns the validated parameter value with correct type
```

Under the hood, this operator:
1. Looks up the parameter's value(s) from the appropriate source (path, query, header, body)
2. Validates the value(s) using the parameter's validator
3. Transforms the value(s) to the target type
4. Returns the strongly-typed result

If validation fails, the framework automatically returns an appropriate error response.

## Response Creation

Snitch provides a rich DSL for creating HTTP responses. The core mechanism is extension properties and functions on any type, which create subclasses of the sealed `HttpResponse` class.

### The HttpResponse Hierarchy

`HttpResponse` is a sealed class with three implementations:

```kotlin
sealed class HttpResponse<T, out S : StatusCodes> {
    abstract val statusCode: StatusCodes
    abstract val headers: Map<String, String>
    abstract val value: context(Parser) () -> Any?
    abstract fun header(header: Pair<String, String>): HttpResponse<T, S>
    
    // Provides a way to transform responses based on their type
    fun map(
        failure: ErrorHttpResponse<T, *, S>.() -> HttpResponse<Any, *> = { this as HttpResponse<Any, *> },
        success: SuccessfulHttpResponse<T, S>.() -> HttpResponse<Any, *>,
    ): HttpResponse<Any, *> = when (this) {
        is SuccessfulHttpResponse -> this.success()
        is ErrorHttpResponse<T, *, S> -> this.failure()
        is RawHttpResponse -> throw UnsupportedOperationException()
    }
}
```

The three implementations are:

1. **SuccessfulHttpResponse**: For 2xx status codes, with typed body content
   ```kotlin
   data class SuccessfulHttpResponse<T, out S : StatusCodes>(
       override val statusCode: S,
       val body: T,
       val _format: Format = Format.Json,
       override val value: context(Parser) () -> Any? = { /* serialization logic */ },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

2. **ErrorHttpResponse**: For error status codes (4xx, 5xx), with typed error details
   ```kotlin
   data class ErrorHttpResponse<T, E, out S : StatusCodes>(
       override val statusCode: StatusCodes,
       val details: E,
       override val value: context(Parser) () -> Any? = { details?.serialized },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

3. **RawHttpResponse**: For sending raw content with minimal processing
   ```kotlin
   data class RawHttpResponse<T, out S : StatusCodes>(
       override val statusCode: S,
       val body: Any,
       val _format: Format = Format.Json,
       override val value: context(Parser) () -> Any? = { body },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

### Response Extensions

The `CommonResponses` interface provides extension properties and functions to create responses with minimal syntax:

```kotlin
// Success responses
val <T> T.ok get() = SuccessfulHttpResponse(StatusCodes.OK, this)
val <T> T.created get() = SuccessfulHttpResponse(StatusCodes.CREATED, this)
val <T> T.accepted get() = SuccessfulHttpResponse(StatusCodes.ACCEPTED, this)
val <T> T.noContent get() = SuccessfulHttpResponse(StatusCodes.NO_CONTENT, this)

// Error responses
fun <T, E, S: StatusCodes> E.badRequest() = ErrorHttpResponse<T, _, S>(StatusCodes.BAD_REQUEST, this)
fun <T, E, S: StatusCodes> E.unauthorized() = ErrorHttpResponse<T, _,S>(StatusCodes.UNAUTHORIZED, this)
fun <T, E, S: StatusCodes> E.forbidden() = ErrorHttpResponse<T, _, S>(StatusCodes.FORBIDDEN, this)
fun <T, E, S: StatusCodes> E.notFound() = ErrorHttpResponse<T, _, S>(StatusCodes.NOT_FOUND, this)
fun <T, E, S: StatusCodes> E.serverError() = ErrorHttpResponse<T, _, S>(StatusCodes.INTERNAL_SERVER_ERROR, this)

// Format control
fun <T, S : StatusCodes> HttpResponse<T, S>.format(newFormat: Format) = /* ... */
val <T, S : StatusCodes> HttpResponse<T, S>.plainText get() = /* ... */
```

This allows handlers to return responses in a concise, readable way:

```kotlin
val getUser by handling {
    val user = userRepository.findById(request[userId])
    if (user != null) user.ok
    else "User not found".notFound()
}
```

### Status Codes

Status codes are modeled as singleton objects within the `StatusCodes` abstract class:

```kotlin
abstract class StatusCodes(val code: Int = 200) {
    object OK : StatusCodes(200)
    object CREATED : StatusCodes(201)
    object ACCEPTED : StatusCodes(202)
    object NO_CONTENT : StatusCodes(204)
    
    object BAD_REQUEST : StatusCodes(400)
    object UNAUTHORIZED : StatusCodes(401)
    object FORBIDDEN : StatusCodes(403)
    object NOT_FOUND : StatusCodes(404)
    object TOO_MANY_REQUESTS : StatusCodes(429)
    
    object INTERNAL_SERVER_ERROR : StatusCodes(500)
    object SERVICE_UNAVAILABLE : StatusCodes(503)
    // Plus many other standard HTTP status codes
}
```

When the response is rendered, the framework:
1. Sets the HTTP status code to `statusCode.code`
2. Serializes the body or details based on the response type and format
3. Adds any custom headers defined in the response

This design provides several advantages:
- Type safety through generics
- Clear distinction between success and error responses
- Flexible content format handling (JSON, plain text, etc.)
- Support for response transformation with the `map` function

## Handler Definition Approaches

Snitch offers several ways to define handlers, each with its own use cases.

### Inline Handlers

The simplest approach is defining handlers inline with routes:

```kotlin
GET("users" / userId) isHandledBy {
    userRepository.findById(request[userId])
        ?.ok
        ?: "User not found".notFound()
}
```

This works well for simple endpoints with minimal logic.

### Named Handlers

For more complex endpoints, you can define named handlers:

```kotlin
val getUser by handling {
    val id = request[userId]
    val user = userRepository.findById(id)
    if (user != null) user.ok
    else "User not found".notFound()
}

// In routes
GET("users" / userId) isHandledBy getUser
```

The `handling` function is defined as:

```kotlin
fun <T: Any> handling(handler: Handler<T>): HandlerReference<T> =
    HandlerReference(handler)

class HandlerReference<T: Any>(val handler: Handler<T>)
```

This allows handlers to be:
- Reused across multiple routes
- Tested independently
- Named for better code organization

### Reusable Handlers

For handlers that need access to request body data, there's a specialized approach:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // body is the parsed CreateUserRequest
    val result = userService.createUser(body.name, body.email)
    CreatedUser(result.id, result.name).created
}
```

The `parsing` function is:

```kotlin
inline fun <reified B: Any> parsing(): BodyHandlerBuilder<B> =
    BodyHandlerBuilder(B::class)

class BodyHandlerBuilder<B: Any>(private val bodyClass: KClass<B>) {
    infix fun handling(handler: BodyHandler<B, *>): BodyHandlerReference<B, *> =
        BodyHandlerReference(handler, bodyClass)
}

typealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T
```

This pattern provides:
- Type-safe access to the request body
- Automatic body parsing and validation
- Clear separation of body handling from other request processing

## Type-Safe Parameter Access

One of Snitch's core strengths is type-safe parameter access. When you define a parameter:

```kotlin
val userId by path(ofLong)
```

You can access it with the correct type in handlers:

```kotlin
val getUser by handling {
    val id: Long = request[userId] // Type is Long, not String
    // ...
}
```

Behind the scenes, this works through the interaction of:
1. The `Parameter` class that captures the validator
2. The `get` operator on `RequestWrapper` that applies the validator
3. Kotlin's type inference that understands the return type

Let's explore how parameters are implemented:

```kotlin
class Parameter<From, To>(
    val name: String,
    val description: String,
    val validator: Validator<From, To>,
    val source: ParameterSource,
    val required: Boolean = true,
    val default: To? = null,
    // Additional metadata...
)
```

When you access a parameter, the framework:
1. Extracts the raw value from the request based on `source`
2. Validates and transforms it using `validator`
3. Falls back to `default` if the parameter is missing and not `required`

This ensures that by the time your handler code executes, all parameters are valid and properly typed.

## Body Handling

Request bodies require special treatment due to their potentially complex structure:

```kotlin
data class CreateUserRequest(val name: String, val email: String)

val userBody by body<CreateUserRequest>()

POST("users") with userBody isHandledBy {
    val request: CreateUserRequest = request[userBody]
    // Use typed request body
}
```

The `body` function creates a special parameter that:
1. Extracts the raw request body from the HTTP request
2. Uses the configured JSON parser to deserialize it to the target type
3. Makes it available via `request[bodyParam]`

For handlers that need frequent body access, the `parsing` pattern simplifies this:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // Direct access to body without request[bodyParam]
    val user = userService.createUser(body.name, body.email)
    // ...
}
```

Under the hood, `parsing` creates a specialized `BodyRequestWrapper` that exposes the parsed body:

```kotlin
interface BodyRequestWrapper<B> : RequestWrapper {
    val body: B
}
```

This provides a cleaner API for body-centric handlers.

## Error Handling in Handlers

Handlers can approach error handling in several ways:

### 1. Return explicit error responses:

```kotlin
val getUser by handling {
    try {
        val user = userService.findById(request[userId])
        if (user != null) user.ok
        else "User not found".notFound()
    } catch (e: DatabaseException) {
        "Database error: ${e.message}".serverError()
    }
}
```

### 2. Throw exceptions that are handled globally:

```kotlin
// In application setup
snitch(parser)
    .onRoutes(routes)
    .handleException(ResourceNotFoundException::class) { ex ->
        ErrorResponse(ex.message ?: "Resource not found").notFound()
    }
    .handleException(DatabaseException::class) { ex ->
        ErrorResponse("Internal error").serverError()
    }
    .start()

// In handler - let exceptions propagate
val getUser by handling {
    userService.findById(request[userId])?.ok
        ?: throw ResourceNotFoundException("User not found")
}
```

The exception handling is implemented by wrapping handler execution:

```kotlin
try {
    handler.invoke(requestWrapper)
} catch (e: Exception) {
    // Find appropriate exception handler
    exceptionHandlers[e::class]?.invoke(e) ?: throw e
}
```

This allows for centralized error handling while keeping handlers focused on the happy path.

## Asynchronous Handlers

Snitch supports asynchronous handlers through coroutines:

```kotlin
val getUser by coHandling {
    // Suspend function call
    val user = userRepository.findByIdAsync(request[userId])
    user?.ok ?: "User not found".notFound()
}
```

The `coHandling` function is defined as:

```kotlin
fun <T: Any> coHandling(handler: suspend Handler<T>): CoHandlerReference<T> =
    CoHandlerReference(handler)
```

This leverages Kotlin's coroutine support to allow non-blocking execution while maintaining the same expressive handler syntax.

## The Handler Execution Pipeline

When a request is processed, handlers go through a specific execution pipeline:

1. **Parameter Validation**: All required parameters are validated
2. **Condition Evaluation**: All conditions are checked
3. **Before Actions**: Before actions execute in reverse order
4. **Decoration Setup**: Decorations wrap the handler
5. **Handler Execution**: The handler processes the request
6. **After Actions**: After actions execute in declaration order

This pipeline ensures that by the time your handler executes:
- All parameters are validated and available
- All conditions are satisfied
- Any pre-processing logic has run

The handler's result then flows through:
1. Any transformation logic in decorations
2. Serialization based on content negotiation
3. Response status code and header application

This structured flow keeps handlers focused on business logic while the framework handles HTTP concerns.

## Testing Handlers

Snitch's design makes handler testing straightforward:

```kotlin
@Test
fun `getUser returns user when found`() {
    // Setup mock repository
    val mockRepo = mockk<UserRepository>()
    every { mockRepo.findById(1) } returns User(1, "Test User")
    
    // Create test request wrapper
    val request = TestRequestWrapper().apply {
        // Set up parameter for testing
        setParameter(userId, 1L)
    }
    
    // Execute handler directly
    val handler = UserHandlers(mockRepo).getUser.handler
    val response = handler.invoke(request)
    
    // Verify response
    assertThat(response.statusCode).isEqualTo(StatusCode.OK)
    assertThat(response.value).isInstanceOf(User::class.java)
    assertThat((response.value as User).name).isEqualTo("Test User")
}
```

For more comprehensive testing, Snitch also provides a testing DSL:

```kotlin
@Test
fun `getUser endpoint returns user when found`() {
    // Setup mock repository
    val mockRepo = mockk<UserRepository>()
    every { mockRepo.findById(1) } returns User(1, "Test User")
    
    // Test the endpoint
    testApp {
        // Register routes with mock dependencies
        registerRoutes(userRoutes(mockRepo))
        
        // Execute request
        GET("/users/1")
            .expectCode(200)
            .expectJson {
                it.path("id").asInt() shouldBe 1
                it.path("name").asText() shouldBe "Test User"
            }
    }
}
```

This approach allows for both unit testing of individual handlers and integration testing of entire endpoints.

## Handler Implementation Details

Let's look at some of the key implementation details behind handlers:

### Handler Function Types

Snitch uses several function types for different handler scenarios:

```kotlin
// Basic handler
typealias Handler<T> = RequestWrapper.() -> T

// Body handler
typealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T

// Coroutine handler
typealias CoHandler<T> = suspend Handler<T>
```

### Handler References

Handler references wrap handler functions to make them usable with the DSL:

```kotlin
class HandlerReference<T: Any>(val handler: Handler<T>)

class BodyHandlerReference<B: Any, T: Any>(
    val handler: BodyHandler<B, T>,
    val bodyClass: KClass<B>
)

class CoHandlerReference<T: Any>(val handler: suspend Handler<T>)
```

### Handler Execution

The endpoint processor executes handlers through a series of steps:

```kotlin
// Simplified flow
fun executeHandler(endpoint: Endpoint<*>, request: Request): Response {
    // Create request wrapper
    val wrapper = RequestWrapperImpl(request, parser)
    
    // Validate parameters
    validateParameters(endpoint.parameters, wrapper)
    
    // Check conditions
    evaluateConditions(endpoint.conditions, wrapper)
    
    // Execute before actions
    for (action in endpoint.beforeActions.reversed()) {
        val earlyResponse = action(wrapper)
        if (earlyResponse != null) return earlyResponse
    }
    
    // Execute handler with decorations
    val result = applyDecorations(endpoint.decorations, endpoint.handler!!)(wrapper)
    
    // Convert result to response
    val response = when (result) {
        is Response -> result
        else -> Response(result, OK)
    }
    
    // Execute after actions
    for (action in endpoint.afterActions) {
        action(wrapper)
    }
    
    return response
}
```

This structured approach ensures consistent request handling while giving handlers access to all the information they need.

## Best Practices

Based on the inner workings of handlers, here are some best practices:

### 1. Keep Handlers Focused

Handlers should focus on their primary responsibility:

```kotlin
// Good: Focused on user retrieval
val getUser by handling {
    userRepository.findById(request[userId])
        ?.ok
        ?: "User not found".notFound()
}

// Avoid: Mixing concerns
val getUser by handling {
    // Authentication logic
    if (!isAuthenticated()) return "Unauthorized".unauthorized()
    
    // Logging
    logger.info("Getting user ${request[userId]}")
    
    // Business logic
    val user = userRepository.findById(request[userId])
    
    // Response creation
    if (user != null) user.ok
    else "User not found".notFound()
}
```

Use conditions, decorations, and actions for cross-cutting concerns.

### 2. Leverage Type Safety

Take advantage of Snitch's type safety features:

```kotlin
// Define parameters with specific types
val userId by path(ofLong)
val userRole by query(ofEnum<UserRole>())

// Use typed parameters in handlers
val getUser by handling {
    val id: Long = request[userId]
    val role: UserRole = request[userRole]
    // No need for manual parsing or validation
}
```

### 3. Use Named Handlers for Complex Logic

```kotlin
// Named handler for better organization
val createUser by parsing<CreateUserRequest>() handling {
    // Validation
    if (!isValidEmail(body.email)) {
        return ValidationError("Invalid email").badRequest()
    }
    
    // Business logic
    try {
        val id = userService.createUser(body.name, body.email)
        CreatedUser(id).created
    } catch (e: DuplicateUserException) {
        ValidationError("User already exists").badRequest()
    }
}
```

### 4. Structure Error Handling Appropriately

For application-specific exceptions, use global handlers:

```kotlin
snitch(parser)
    .handleException(ResourceNotFoundException::class) { ex ->
        ErrorResponse(ex.message ?: "Resource not found").notFound()
    }

// Then throw from handlers
val getUser by handling {
    userRepository.findById(request[userId]) 
        ?: throw ResourceNotFoundException("User not found")
}
```

For business logic validation, return explicit responses:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    if (!isValidEmail(body.email)) {
        return ValidationError("Invalid email").badRequest()
    }
    // Proceed with valid input
}
```

### 5. Use Coroutines for I/O-Bound Operations

```kotlin
val getUser by coHandling {
    // Non-blocking database call
    val user = userRepository.findByIdAsync(request[userId])
    user?.ok ?: "User not found".notFound()
}
```

### 6. Group Related Handlers

```kotlin
class UserHandlers(private val userRepository: UserRepository) {
    val getUser by handling {
        // Implementation
    }
    
    val createUser by parsing<CreateUserRequest>() handling {
        // Implementation
    }
    
    val updateUser by parsing<UpdateUserRequest>() handling {
        // Implementation
    }
    
    val deleteUser by handling {
        // Implementation
    }
}

// In routes
val userHandlers = UserHandlers(userRepository)

"users" / {
    GET(userId) isHandledBy userHandlers.getUser
    POST() with userBody isHandledBy userHandlers.createUser
    PUT(userId) with userBody isHandledBy userHandlers.updateUser
    DELETE(userId) isHandledBy userHandlers.deleteUser
}
```

This approach:
- Groups related functionality
- Makes dependency injection straightforward
- Improves code organization

## Conclusion

Snitch's Handler DSL provides a powerful, type-safe way to implement API business logic. By understanding its internal workings, you can leverage its full potential to create expressive, maintainable handlers.

The combination of type-safe parameter access, flexible response creation, and structured execution pipeline allows you to focus on your business logic while the framework handles HTTP concerns.

Whether you're writing simple endpoints or complex business processes, Snitch's Handler DSL offers the tools to express your intent clearly and safely.

---

## From: Anatomy-of-Validators.md

# Validator DSL

Validators are a cornerstone of Snitch's design, ensuring that HTTP inputs are properly validated and transformed into domain types. This guide explores the internal workings of the validator DSL, explaining each component and how they fit together.

## The Validator Interface

At the heart of the validation system is the `Validator` interface:

```kotlin
interface Validator<T, R> {
    val regex: Regex
    val description: String
    val parse: Parser.(Collection<String>) -> R
    fun optional(): Validator<T?, R?> = this as Validator<T?, R?>
}
```

Let's break down each component:

1. **Type Parameters**:
   - `T`: The input type that the validator accepts (typically `String`)
   - `R`: The output type that the validator produces (your domain type)

2. **Properties**:
   - `regex`: A regular expression used for initial string validation
   - `description`: A human-readable description used for documentation
   - `parse`: A function that takes a collection of strings and transforms them into the output type
   
3. **Methods**:
   - `optional()`: Converts a required validator to an optional one

The interface is intentionally minimal, focusing on the essential components of validation: pattern matching, transformation, and documentation.

## Creating Validators

Snitch provides several factory functions for creating validators with different behaviors:

### The `validator` Function

The most general factory function:

```kotlin
inline fun <From, To> validator(
    descriptions: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    crossinline mapper: Parser.(String) -> To
) = object : Validator<From, To> {
    override val description = descriptions
    override val regex = regex
    override val parse: Parser.(Collection<String>) -> To = { mapper(it.single()) }
}
```

This function creates a validator that:
- Has a custom description
- Uses a specified regex (or a default that matches any non-empty string)
- Applies a mapping function to transform the input

The `crossinline` modifier ensures that the mapper function can be used inside a lambda that will be inlined.

**Typical Usage**:

```kotlin
val ofUUID = validator<String, UUID>(
    "valid UUID",
    """^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$""".toRegex(RegexOption.IGNORE_CASE)
) {
    try {
        UUID.fromString(it)
    } catch (e: IllegalArgumentException) {
        throw IllegalArgumentException("Invalid UUID format")
    }
}
```

### The `stringValidator` Function

A specialized version for string inputs:

```kotlin
inline fun <To> stringValidator(
    description: String = "",
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    crossinline mapper: Parser.(String) -> To,
) = validator<String, To>(description, regex, mapper)
```

This is a convenience function that defaults the input type to `String`, which is the most common case.

**Typical Usage**:

```kotlin
val ofEmail = stringValidator(
    "email address",
    """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
) { it }
```

### The `validatorMulti` Function

For handling collections of values:

```kotlin
fun <From, To> validatorMulti(
    descriptions: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
) = object : Validator<From, To> {
    override val description = descriptions
    override val regex = regex
    override val parse: Parser.(Collection<String>) -> To = mapper
}
```

This function allows working with multiple input values, such as repeated query parameters.

**Typical Usage**:

```kotlin
val ofStringSet = validatorMulti<String, Set<String>>(
    "set of strings"
) { strings ->
    strings.flatMap { it.split(",") }.toSet()
}
```

### The `stringValidatorMulti` Function

A specialized version for string inputs that return collections:

```kotlin
fun <To> stringValidatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To,
) = validatorMulti<String, To>(description, regex, mapper)
```

This combines the convenience of `stringValidator` with the collection handling of `validatorMulti`.

**Typical Usage**:

```kotlin
val ofTags = stringValidatorMulti<List<String>>(
    "comma-separated tags"
) { params ->
    params.flatMap { it.split(",") }
        .map { it.trim() }
        .filter { it.isNotEmpty() }
}
```

## How Validators Work

Now that we understand the interface and creation functions, let's explore how validators operate at runtime.

### Regex Validation

The first step in validation is pattern matching using the `regex` property:

```kotlin
// Inside parameter handler code
if (!validator.regex.matches(value)) {
    throw ValidationException("Value doesn't match pattern for ${validator.description}")
}
```

This provides a fast first-pass validation before more complex logic is applied. For example, checking that an email string has a basic email-like structure before attempting further validation.

### Transformation Logic

After regex validation passes, the `parse` function is called with the collection of parameter values:

```kotlin
// Inside parameter handler code
try {
    return validator.parse(parser, values)
} catch (e: Exception) {
    throw ValidationException("Failed to parse ${validator.description}: ${e.message}")
}
```

The parse function is responsible for:
1. Handling single vs. multiple values
2. Converting strings to the target type
3. Performing business-specific validation
4. Throwing exceptions for invalid inputs

The transformation typically has access to the `Parser` instance, which provides useful utilities for working with common formats like JSON.

### Error Handling

Validators report errors by throwing exceptions, which Snitch catches and converts to appropriate HTTP responses (typically 400 Bad Request).

This happens at several levels:
1. **Regex mismatch**: Throws a `ValidationException`
2. **Empty collection**: Throws a `NoSuchElementException` from the `single()` call
3. **Custom validation**: Validator-specific exceptions from the mapper function

Snitch provides automatic handling for all of these, generating clear error messages for API consumers.

## The Parser's Role

You may have noticed that the validator functions all pass a `Parser` instance to the mapper function. The `Parser` is an interface for converting between strings and structured data:

```kotlin
interface Parser {
    fun <T> fromJson(json: String): T
    fun <T> toJson(value: T): String
    fun <T : Enum<T>> String.parse(enumClass: Class<T>): T
}
```

This allows validators to leverage the application's JSON parser for complex transformations, particularly for request bodies.

**Example using the Parser**:

```kotlin
val ofUser = stringValidator<User>("user") {
    parser.fromJson<User>(it)
}
```

This is particularly powerful for body validators, allowing seamless conversion between JSON strings and domain objects.

## Custom Validators

While the factory functions cover most use cases, you can also implement the `Validator` interface directly for complete control:

```kotlin
object UserIdValidator : Validator<String, UserId> {
    override val description = "Valid user ID"
    override val regex = """^[a-zA-Z0-9]{8,12}$""".toRegex()
    override val parse: Parser.(Collection<String>) -> UserId = { collection ->
        val value = collection.first()
        // Custom validation logic
        if (!userRepository.exists(value)) {
            throw IllegalArgumentException("User ID does not exist")
        }
        UserId(value)
    }
}
```

This approach is useful when:
- You need complex validation logic
- You want to encapsulate validation in a self-contained object
- You need to inject dependencies (like repositories) into the validator

## Validator Internals

Let's explore what happens when a validator is used with a parameter:

```kotlin
val userId by path(ofUUID)
```

Here's the sequence of events:

1. The `path` function creates a `Parameter` object, storing the validator
2. When a request arrives, Snitch extracts the raw path parameter value
3. The validator's regex is checked against the value
4. If the regex matches, the parse function is called
5. The parse function converts the string to a UUID
6. The result is cached and made available via `request[userId]`

If any step fails, the request processing is halted, and an error response is returned to the client.

## Best Practices

Based on the internal workings of validators, here are some best practices:

1. **Use specific regex patterns**: The more specific your regex, the faster you can reject invalid inputs
   
2. **Keep transformation functions pure**: Avoid side effects in mapper functions for easier testing and reasoning

3. **Provide clear error messages**: When throwing exceptions, include specific details about why validation failed

4. **Define domain-specific validators**: Create validators for your domain types to encapsulate validation logic

5. **Compose validators**: Build complex validators by combining simpler ones

6. **Avoid heavy computation in validators**: Validators run on every request, so keep them efficient

7. **Use the optional() method**: For truly optional parameters, apply `optional()` to your validator instead of handling nullability in mapper functions

## Putting It All Together

Let's see a complete example of a custom validator used in an endpoint:

```kotlin
// Domain type
data class UserId(val value: String)

// Custom validator
val ofUserId = validator<String, UserId>(
    "valid user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    if (it.length < 8 || it.length > 12) {
        throw IllegalArgumentException("User ID must be 8-12 characters long")
    }
    
    if (!it.matches("""^[a-zA-Z0-9]*$""".toRegex())) {
        throw IllegalArgumentException("User ID must contain only letters and numbers")
    }
    
    UserId(it)
}

// Parameter definition
val userId by path(ofUserId)

// Route with validated parameter
GET("users" / userId) isHandledBy {
    // UserId is already validated and transformed
    val id: UserId = request[userId]
    userRepository.findById(id).ok
}
```

This approach ensures:
1. Early validation at the HTTP layer
2. Type-safe access to domain types
3. Clean separation of validation and business logic
4. Clear error messages for API consumers

## Conclusion

The validator DSL in Snitch provides a powerful, type-safe way to transform raw HTTP inputs into domain types. By understanding its internal workings, you can create more robust, maintainable APIs with clear error handling and strong type safety.

Remember that validators aren't just about rejecting invalid inputs—they're about bridging the gap between the untyped world of HTTP and the strongly-typed world of your domain model.

---

## From: Mastering-Snitch-BeforeAfter.md

# Before and After Actions

The Before and After action mechanism in Snitch provides a powerful way to run code around your route handlers. It allows you to execute logic before a request is processed and after a response is generated, which is useful for cross-cutting concerns such as logging, authentication, authorization, and performance monitoring.

## Understanding Before and After Actions

Before and After actions are similar to middleware in other frameworks. They allow you to:

1. **Before Actions**: Execute code before the route handler is called
2. **After Actions**: Execute code after the route handler has completed and a response is generated

These actions have full access to the request context, including path, query, and header parameters, and can also modify the response returned by the handler.

## Route-Level Actions

Route-level actions are applied to individual routes, allowing for fine-grained control over which routes need specific pre- or post-processing.

### Defining Before Actions

```kotlin
GET("users" / userId)
    .doBefore { 
        // Code to run before the handler
        logger.info("Accessing user: ${request[userId]}")
    }
    .isHandledBy {
        // Handler code
        userRepository.getUser(request[userId]).ok
    }
```

### Defining After Actions

```kotlin
GET("users" / userId)
    .doAfter { 
        // Code to run after the handler has generated a response
        logger.info("User access completed with status: ${response.statusCode}")
    }
    .isHandledBy {
        // Handler code
        userRepository.getUser(request[userId]).ok
    }
```

### Combining Before and After Actions

You can chain multiple before and after actions on a single route:

```kotlin
GET("users" / userId)
    .doBefore { logger.info("Request started") }
    .doBefore { metrics.incrementRequestCount() }
    .doAfter { metrics.recordResponseTime() }
    .doAfter { logger.info("Request completed") }
    .isHandledBy {
        userRepository.getUser(request[userId]).ok
    }
```

## Global Actions

Global actions let you apply the same logic to multiple routes or across your entire application, reducing code duplication.

### Applying to Multiple Routes

```kotlin
applyToAll_({
    GET("users" / userId) isHandledBy getUserHandler
    POST("users") with body<CreateUserRequest>() isHandledBy createUserHandler
    PUT("users" / userId) with body<UpdateUserRequest>() isHandledBy updateUserHandler
}) {
    doBefore { 
        logger.info("${request.method} ${request.path} started")
    }
    doAfter { 
        logger.info("${request.method} ${request.path} completed with status ${response.statusCode}")
    }
}
```

## Execution Order

Understanding the execution order of before and after actions is crucial for building correct, predictable behavior.

### Order for Before Actions

1. **Before actions execute in reverse declaration order** (last declared, first executed)
2. **Global before actions execute before route-level before actions**

For example:

```kotlin
applyToAll_({
    GET("foo")
        .doBefore { /* Route before 1 */ }
        .doBefore { /* Route before 2 */ }
        .isHandledBy { /* Handler */ }
}) {
    doBefore { /* Global before 1 */ }
    doBefore { /* Global before 2 */ }
}
```

Execution order:
1. Global before 2
2. Global before 1
3. Route before 2
4. Route before 1
5. Handler

### Order for After Actions

1. **After actions execute in declaration order** (first declared, first executed)
2. **Route-level after actions execute before global after actions**

For example:

```kotlin
applyToAll_({
    GET("foo")
        .doAfter { /* Route after 1 */ }
        .doAfter { /* Route after 2 */ }
        .isHandledBy { /* Handler */ }
}) {
    doAfter { /* Global after 1 */ }
    doAfter { /* Global after 2 */ }
}
```

Execution order:
1. Handler
2. Route after 1
3. Route after 2
4. Global after 1
5. Global after 2

### Complete Execution Flow

The complete execution flow for a request is:

1. Global before actions (in reverse declaration order)
2. Route-level before actions (in reverse declaration order)
3. Route handler
4. Route-level after actions (in declaration order)
5. Global after actions (in declaration order)

## Error Handling

The behavior of before and after actions differs slightly when errors occur:

### Exceptions in Before Actions

When an exception occurs in a before action:

1. The exception is caught and processed by any registered exception handlers
2. The route handler is **not** executed
3. After actions are **not** executed automatically (as of the current implementation)

```kotlin
GET("foo")
    .doBefore { 
        throw RuntimeException("Error in before action")
    }
    .doAfter { 
        // Currently not executed when before action throws an exception
    }
    .isHandledBy {
        // Not executed when before action throws an exception
    }
```

### Exceptions in Handlers

When an exception occurs in a route handler:

1. The exception is caught and processed by any registered exception handlers
2. After actions are **not** executed automatically (as of the current implementation)

```kotlin
// Register exception handler
handleException(RuntimeException::class) {
    logger.error("Exception caught: ${it.message}")
    "Error occurred".serverError()
}

GET("foo")
    .doBefore { /* Executes normally */ }
    .doAfter { 
        // Currently not executed when handler throws an exception
    }
    .isHandledBy {
        throw RuntimeException("Error in handler")
    }
```

> **Note**: According to the test file, there's a TODO comment indicating that after actions don't currently run in case of exceptions in before actions or handlers, but this behavior may be implemented in future versions.

## Common Use Cases

Before and after actions are ideal for many cross-cutting concerns:

### Logging

```kotlin
val Router.withLogging get() = transformEndpoints {
    doBefore { 
        logger.info("Request started: ${request.method} ${request.path}")
        request.attributes["startTime"] = System.currentTimeMillis()
    }
    doAfter {
        val startTime = request.attributes["startTime"] as Long
        val duration = System.currentTimeMillis() - startTime
        logger.info("Request completed: ${request.method} ${request.path} - ${response.statusCode} (${duration}ms)")
    }
}

// Usage
withLogging {
    GET("users") isHandledBy { /* handler */ }
    POST("users") isHandledBy { /* handler */ }
}
```

### Authentication

```kotlin
val accessToken by header(validJwtValidator)

val Router.authenticated get() = transformEndpoints {
    with(queries(accessToken)).doBefore {
        val token = request[accessToken]
        if (token is Authentication.Unauthenticated) {
            return@doBefore "Unauthorized".unauthorized()
        }
    }
}

// Usage
authenticated {
    GET("profile") isHandledBy getUserProfile
    PUT("settings") isHandledBy updateUserSettings
}
```

### Request Metrics

```kotlin
val Router.withMetrics get() = transformEndpoints {
    doBefore {
        metrics.incrementRequestCount(request.path)
        request.attributes["startTime"] = System.nanoTime()
    }
    doAfter {
        val duration = System.nanoTime() - (request.attributes["startTime"] as Long)
        metrics.recordResponseTime(request.path, duration)
        metrics.recordStatusCode(request.path, response.statusCode.code)
    }
}
```

### Database Transactions

```kotlin
val Router.withTransaction get() = transformEndpoints {
    doBefore {
        transaction.begin()
    }
    doAfter {
        if (response.isSuccessful()) {
            transaction.commit()
        } else {
            transaction.rollback()
        }
    }
}

// Usage
withTransaction {
    POST("orders") isHandledBy createOrder
    PUT("orders" / orderId) isHandledBy updateOrder
}
```

## Best Practices

### 1. Keep Before and After Actions Focused

Each before and after action should have a single responsibility. Instead of having one big action that does multiple things, chain smaller, focused actions:

```kotlin
// Good
GET("users")
    .doBefore { validateRequest() }
    .doBefore { authenticate() }
    .doBefore { authorize() }
    .doAfter { logResponse() }
    .doAfter { collectMetrics() }
    .isHandledBy { /* handler */ }

// Avoid
GET("users")
    .doBefore { 
        validateRequest()
        authenticate()
        authorize()
    }
    .doAfter { 
        logResponse()
        collectMetrics()
    }
    .isHandledBy { /* handler */ }
```

### 2. Use Global Actions for Cross-Cutting Concerns

When actions need to be applied across multiple routes or your entire application, use global actions to reduce duplication:

```kotlin
// Error logging applied to all routes
applyToAll_({
    // All your routes
}) {
    doAfter { 
        if (response.statusCode.isError()) {
            logger.error("Error response: ${response.statusCode} - ${response.body}")
        }
    }
}
```

### 3. Be Careful with Response Modification

After actions have the ability to modify the response. Use this power with care:

```kotlin
GET("users")
    .doAfter { 
        // Only modify the response when needed
        if (response.statusCode.isSuccess() && response is JsonResponse) {
            // Add additional info to JSON response
            response.addAttribute("serverTime", System.currentTimeMillis())
        }
    }
    .isHandledBy { /* handler */ }
```

### 4. Handle Errors Explicitly

Be explicit about error handling in your before and after actions:

```kotlin
GET("users")
    .doBefore { 
        try {
            // Risky operation
        } catch (e: Exception) {
            logger.error("Error in before action", e)
            return@doBefore "An error occurred".serverError()
        }
    }
    .isHandledBy { /* handler */ }
```

### 5. Be Mindful of Execution Order

Remember that before actions execute in reverse order and after actions execute in declaration order:

```kotlin
GET("users")
    // Executes third
    .doBefore { logger.info("Authorization check") }
    // Executes second
    .doBefore { logger.info("Authentication check") }
    // Executes first
    .doBefore { logger.info("Request validation") }
    
    // Executes first after handler
    .doAfter { logger.info("Log response") }
    // Executes second after handler
    .doAfter { logger.info("Collect metrics") }
    
    .isHandledBy { /* handler */ }
```

## Conclusion

The Before and After action mechanism in Snitch provides a powerful way to organize cross-cutting concerns in your HTTP application. By understanding how these actions are executed and how they interact with exception handling, you can build clean, maintainable, and robust applications.

Remember that actions should be focused, reusable, and predictable. Use global actions for common functionality and route-level actions for specific requirements. Be aware of the current limitations in error handling, and always consider the execution order when designing your action chains.

---

## From: Mastering-Snitch-Conditions.md

# Conditions

Conditions are one of Snitch's most powerful features, allowing you to implement sophisticated access control and request validation with minimal code. This tutorial will guide you through everything you need to know about conditions, from basic usage to advanced patterns.

## Understanding Conditions

In Snitch, a condition is a predicate that evaluates a request and determines whether it should proceed or be rejected. Conditions are represented by the `Condition` interface, which has three key components:

1. **Description**: A human-readable description of what the condition checks
2. **Transform function**: A function that can modify an endpoint (usually for documentation purposes)
3. **Check function**: The actual logic that evaluates the request

When a condition is applied to an endpoint using `onlyIf`, it becomes part of the request processing pipeline. If the condition evaluates to `Successful`, the request proceeds; if it evaluates to `Failed`, the request is rejected with the specified error response.

## Basic Condition Usage

The simplest way to use conditions is with the `onlyIf` method on an endpoint:

```kotlin
GET("resource" / resourceId) onlyIf isResourceOwner isHandledBy { getResource() }
```

This ensures that the endpoint will only be accessible if the `isResourceOwner` condition evaluates to `Successful`.

## Creating Custom Conditions

You can create custom conditions using the `condition` factory function:

```kotlin
val hasAdminRole = condition("hasAdminRole") {
    val role = (request[accessToken] as? Authentication.Authenticated)?.claims?.role
    
    when (role) {
        Role.ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Admin role required".forbidden())
    }
}
```

The first parameter is the description, which will be used in documentation and error messages. The lambda receives a `RequestWrapper` and should return a `ConditionResult`.

### Parameterized Conditions

You can create reusable condition factories that accept parameters:

```kotlin
fun hasMinimumAge(minAge: Int) = condition("hasMinimumAge($minAge)") {
    val userAge = userRepository.getAge(request[userId])
    
    if (userAge >= minAge) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("User must be at least $minAge years old".forbidden())
    }
}

// Usage
GET("adult-content") onlyIf hasMinimumAge(18) isHandledBy { getAdultContent() }
```

## Logical Operators

Snitch conditions support three logical operators:

### AND (`and`)

The `and` operator creates a condition that succeeds only if both conditions succeed:

```kotlin
val canAccessResource = isAuthenticated and hasPermission
```

When evaluating an `and` condition, if the first condition fails, the second one is not evaluated (short-circuit evaluation).

### OR (`or`)

The `or` operator creates a condition that succeeds if either condition succeeds:

```kotlin
val canModifyResource = isResourceOwner or hasAdminRole
```

When evaluating an `or` condition, if the first condition succeeds, the second one is not evaluated.

### NOT (`not` or `!`)

The `not` operator inverts a condition:

```kotlin
val isNotLocked = !isResourceLocked
```

You can combine these operators to create complex access rules:

```kotlin
val canEditDocument = isAuthenticated and (isDocumentOwner or hasEditorRole) and !isDocumentLocked
```

## Applying Conditions to Route Hierarchies

You can apply conditions to entire route hierarchies using the `onlyIf` block:

```kotlin
onlyIf(isAuthenticated) {
    GET("profile") isHandledBy { getProfile() }
    
    onlyIf(hasAdminRole) {
        GET("admin/dashboard") isHandledBy { getDashboard() }
        GET("admin/users") isHandledBy { getUsers() }
    }
}
```

In this example, all routes require authentication, and the admin routes additionally require the admin role.

## Short-Circuit Evaluation

Snitch's condition operators use short-circuit evaluation for efficiency:

- For `and`, if the first condition fails, the second is not evaluated
- For `or`, if the first condition succeeds, the second is not evaluated

This is particularly useful when you have conditions with side effects or expensive operations:

```kotlin
// The database query will only run if the user is authenticated
val canAccessResource = isAuthenticated and hasPermissionInDatabase
```

You can test this behavior:

```kotlin
@Test
fun `short-circuits condition evaluation`() {
    var secondConditionEvaluated = false
    
    val trackingCondition = condition("tracking") {
        secondConditionEvaluated = true
        ConditionResult.Successful
    }
    
    given {
        GET("short-circuit")
            .onlyIf(alwaysFalse and trackingCondition)
            .isHandledBy { "".ok }
    } then {
        GET("/short-circuit").expectCode(403)
        assert(!secondConditionEvaluated) { "Second condition should not have been evaluated" }
    }
}
```

## Error Handling and Custom Responses

When a condition fails, it returns a `ConditionResult.Failed` with an error response. You can customize this response:

```kotlin
val isResourceOwner = condition("isResourceOwner") {
    if (principal.id == request[resourceId]) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed(
            ErrorResponse(
                code = "FORBIDDEN",
                message = "You don't have permission to access this resource",
                details = mapOf("resourceId" to request[resourceId])
            ).error(StatusCodes.FORBIDDEN)
        )
    }
}
```

This allows you to provide detailed, context-specific error messages to clients.

## Best Practices

### 1. Keep Conditions Focused

Each condition should check one specific thing. This makes them more reusable and easier to understand.

### 2. Use Descriptive Names

Choose condition names that clearly describe what they check:

```kotlin
// Good
val hasAdminRole = condition("hasAdminRole") { ... }

// Not as good
val adminCheck = condition("adminCheck") { ... }
```

### 3. Leverage Composition

Build complex access rules by composing simple conditions:

```kotlin
val canEditDocument = isAuthenticated and isDocumentOwner and !isDocumentLocked
```

### 4. Provide Helpful Error Messages

When a condition fails, the error message should help the client understand why:

```kotlin
ConditionResult.Failed("Resource not found or you don't have permission to access it".forbidden())
```

### 5. Document Conditions

Use the description parameter to document what the condition checks:

```kotlin
val hasPermission = condition("User has permission to access the resource") { ... }
```

This description will appear in the generated API documentation.

## Real-World Examples

### Authentication and Authorization

```kotlin
// Authentication
val isAuthenticated = condition("isAuthenticated") {
    when (request[accessToken]) {
        is Authentication.Authenticated -> ConditionResult.Successful
        else -> ConditionResult.Failed("Authentication required".unauthorized())
    }
}

// Authorization
val hasAdminRole = condition("hasAdminRole") {
    val auth = request[accessToken] as? Authentication.Authenticated
        ?: return@condition ConditionResult.Failed("Authentication required".unauthorized())
    
    when (auth.claims.role) {
        Role.ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Admin role required".forbidden())
    }
}

// Resource ownership
fun isResourceOwner(resourceIdParam: Parameter<String, *>) = condition("isResourceOwner") {
    val auth = request[accessToken] as? Authentication.Authenticated
        ?: return@condition ConditionResult.Failed("Authentication required".unauthorized())
    
    if (auth.claims.userId == request[resourceIdParam]) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("You don't own this resource".forbidden())
    }
}

// Usage
val routes = routes {
    onlyIf(isAuthenticated) {
        GET("profile") isHandledBy { getProfile() }
        
        "resources" / resourceId / {
            GET() onlyIf isResourceOwner(resourceId) isHandledBy { getResource() }
            PUT() onlyIf (isResourceOwner(resourceId) or hasAdminRole) isHandledBy { updateResource() }
            DELETE() onlyIf (isResourceOwner(resourceId) or hasAdminRole) isHandledBy { deleteResource() }
        }
        
        onlyIf(hasAdminRole) {
            GET("admin/dashboard") isHandledBy { getDashboard() }
            GET("admin/users") isHandledBy { getUsers() }
        }
    }
}
```

### Rate Limiting

```kotlin
fun rateLimit(maxRequests: Int, perTimeWindow: Duration) = condition("rateLimit($maxRequests per $perTimeWindow)") {
    val clientIp = request.remoteAddress
    val requestCount = rateLimiter.getRequestCount(clientIp, perTimeWindow)
    
    if (requestCount <= maxRequests) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed(
            ErrorResponse(
                code = "TOO_MANY_REQUESTS",
                message = "Rate limit exceeded. Try again later.",
                details = mapOf(
                    "maxRequests" to maxRequests,
                    "timeWindow" to perTimeWindow.toString(),
                    "retryAfter" to rateLimiter.getRetryAfter(clientIp)
                )
            ).error(StatusCodes.TOO_MANY_REQUESTS)
        )
    }
}

// Usage
onlyIf(rateLimit(100, Duration.ofMinutes(1))) {
    POST("api/v1/messages") isHandledBy { sendMessage() }
}
```

### Feature Flags

```kotlin
fun featureEnabled(featureName: String) = condition("featureEnabled($featureName)") {
    if (featureFlagService.isEnabled(featureName)) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("Feature not available".notFound())
    }
}

// Usage
GET("new-feature") onlyIf featureEnabled("new-feature") isHandledBy { useNewFeature() }
```

By mastering Snitch's condition system, you can implement sophisticated access control and request validation with minimal code, keeping your routes clean and focused on business logic. 

---

## From: Mastering-Snitch-Decorations.md

# Decorations

Decorations are a powerful feature in Snitch that allow you to modify request handling behavior across multiple routes. They provide a clean, composable way to implement cross-cutting concerns like logging, authentication, transaction management, and more. This tutorial will guide you through everything you need to know about decorations, from basic usage to advanced patterns.

## Understanding Decorations

In Snitch, a decoration is a higher-order function that wraps around route handlers to modify their behavior. Decorations can:

1. Execute code before the handler runs
2. Execute code after the handler runs
3. Transform the response from the handler
4. Short-circuit the request and return a response without calling the handler
5. Handle exceptions thrown by the handler

Decorations are implemented using the `decorateWith` function, which creates a decorator that can be applied to routes or route hierarchies.

## Basic Decoration Usage

The simplest way to use decorations is to apply them to a route or route hierarchy:

```kotlin
val logged = decorateWith {
    val method = request.method.name
    val path = request.path
    Logger.info("Begin Request: $method $path")
    next().also {
        Logger.info("End Request: $method $path ${it.statusCode.code}")
    }
}

val routes = routes {
    logged {
        GET("hello").isHandledBy { "Hello, world!".ok }
        POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }
    }
}
```

In this example, all requests to `/hello` and `/users` will be logged before and after handling.

## Creating Custom Decorations

You can create custom decorations using the `decorateWith` function:

```kotlin
val withTransaction = decorateWith { 
    transaction { 
        next() 
    } 
}
```

The lambda passed to `decorateWith` receives a `RequestWrapper` implicitly and should call `next()` to execute the next decoration or handler in the chain. It should return a `Response`.

### Parameterized Decorations

You can create reusable decoration factories that accept parameters:

```kotlin
fun withMetricLabel(label: String) = decorateWith {
    val startTime = System.currentTimeMillis()
    val response = next()
    val endTime = System.currentTimeMillis()
    metrics.record(label, endTime - startTime)
    response
}

// Usage
withMetricLabel("user-service") {
    GET("users").isHandledBy { getUsers() }
}
```

## Decoration Composition

One of the most powerful features of Snitch decorations is their composability. You can combine multiple decorations using the `+` operator:

```kotlin
val combinedDecoration = withTransaction + logged

// Execution order:
// 1. withTransaction (applied first)
// 2. logged (applied second)
// 3. handler
```

When decorations are composed, they are applied from right to left. In the example above, the execution order would be:

1. `withTransaction`
2. `logged`
3. The actual handler

This means that the request flows through the decorations in the order they are composed, and the response flows back in the reverse order.

### Composition Properties

Decoration composition has several important properties:

1. **Associativity**: `(a + b) + c` is equivalent to `a + (b + c)`
2. **Identity**: There exists an identity decoration that, when composed with any decoration, yields the original decoration
3. **Right-to-left evaluation**: In `a + b + c`, decoration `c` is applied first, then `b`, then `a`

These properties make decorations a powerful tool for building complex middleware chains.

## Nesting Decorations

In addition to composition, decorations can also be nested:

```kotlin
logged {
    withTransaction {
        GET("users").isHandledBy { getUsers() }
    }
}
```

When decorations are nested, they are applied from outside to inside. In the example above, the execution order would be:

1. `logged`
2. `withTransaction`
3. The actual handler

This is different from composition, where the order is right to left.

## Decoration Order and Execution Flow

Understanding the execution flow of decorations is crucial for using them effectively. Let's look at a more complex example:

```kotlin
// Composition
(decoration1 + decoration2) {
    // Nesting
    decoration3 {
        GET("hello").isHandledBy { "Hello, world!".ok }
    }
}
```

In this example, the execution order would be:

1. `decoration2` (from composition, right to left)
2. `decoration1` (from composition, right to left)
3. `decoration3` (from nesting, outside to inside)
4. The actual handler

And the response would flow back in the reverse order:

1. The actual handler
2. `decoration3`
3. `decoration1`
4. `decoration2`

This allows you to create sophisticated middleware chains with precise control over the execution order.

## Integration with Conditions

Decorations work seamlessly with Snitch's condition system. You can use the `transformEndpoints` function to create decorations that also add parameters and apply conditions:

```kotlin
val authenticated = transformEndpoints {
    with(listOf(accessToken)).decorated {
        when (request[accessToken]) {
            is Authentication.Authenticated -> next()
            is Authentication.Unauthenticated -> UNAUTHORIZED()
        }
    }
}

// Usage
authenticated {
    GET("profile").isHandledBy { getProfile() }
}
```

This approach is particularly useful for authentication and authorization, where you need to both add parameters (like access tokens) and check conditions before proceeding.

## Common Use Cases

### Logging

```kotlin
val logged = decorateWith {
    val method = request.method.name
    val path = request.path
    Logger.info("Begin Request: $method $path")
    next().also {
        Logger.info("End Request: $method $path ${it.statusCode.code}")
    }
}
```

### Authentication

```kotlin
// Define auth token parameter
val authToken by header("X-Auth-Token")

// Authentication decoration
val authenticated = decorateWith(authToken) {
    when (request[authToken]) {
        "user-token" -> next()
        null -> "Unauthorized".unauthorized()
        else -> "Unauthorized".unauthorized()
    }

}

// Role-based authorization
val requireAdmin = decorateWith(authToken) {
    val token = request[authToken]
    if (token == "admin-token") {
        next()
    } else {
        "Forbidden - Admin access required".forbidden()
    }
}

// Usage
authenticated {
    // Public endpoint - just needs authentication
    GET("profile").isHandledBy { "User profile".ok }

    // Admin endpoint - needs both authentication and admin role
    requireAdmin {
        GET("admin/dashboard").isHandledBy { "Admin dashboard".ok }
    }
}
```

### Transaction Management

```kotlin
val withTransaction = decorateWith { 
    transaction { 
        next() 
    } 
}
```

### Error Handling

```kotlin
val handleErrors = decorateWith {
    try {
        next()
    } catch (e: Exception) {
        logger.error("Error handling request: ${e.message}")
        "Internal server error".serverError()
    }
}
```

### Response Transformation

```kotlin
val addCorsHeaders = decorateWith {
    val response = next()
    response.copy(
        headers = response.headers + mapOf(
            "Access-Control-Allow-Origin" to "*",
            "Access-Control-Allow-Methods" to "GET, POST, PUT, DELETE, OPTIONS",
            "Access-Control-Allow-Headers" to "Content-Type, Authorization"
        )
    )
}
```

## Best Practices

### 1. Keep Decorations Focused

Each decoration should handle one specific concern. This makes them more reusable and easier to understand.

### 2. Use Composition for Complex Behavior

Instead of creating complex decorations, compose simple ones:

```kotlin
// Good
val combinedDecoration = logged + withTransaction

// Not as good
val complexDecoration = decorateWith {
    logger().info("Request started")
    transaction { 
        next() 
    }.also {
        logger().info("Request completed")
    }
}
```

### 3. Be Mindful of Decoration Order

The order of decorations matters. For example, if you want to measure the time including transaction overhead, you would do:

```kotlin
val measureTime + withTransaction
```

But if you want to measure only the time spent in the handler, excluding transaction overhead, you would do:

```kotlin
val withTransaction + measureTime
```

### 4. Always Call `next()` Unless Short-Circuiting

If your decoration doesn't call `next()`, the handler will never be executed. This is useful for short-circuiting (e.g., for authentication), but make sure it's intentional.

### 5. Handle Exceptions Appropriately

If your decoration might throw exceptions, consider wrapping the `next()` call in a try-catch block to ensure proper cleanup.

## Real-World Examples

### Authentication and Authorization

Looking at a real-world example from a production codebase:

```kotlin
// Authentication decoration
val authenticated = transformEndpoints {
    with(listOf(accessToken)).decorated {
        when (request[accessToken]) {
            is Authentication.Authenticated -> next()
            is Authentication.Unauthenticated -> UNAUTHORIZED()
        }
    }
}

// Access to user principal and role
val RequestWrapper.principal: UserId get() = 
    (request[accessToken] as Authentication.Authenticated).claims.userId
val RequestWrapper.role: Role get() = 
    (request[accessToken] as Authentication.Authenticated).claims.role

// Condition for checking principal equality
fun principalEquals(param: Parameter<out Any, *>) = condition("Principal equals ${param.name}") {
    if (principal.value == params(param.name)) Successful
    else Failed(FORBIDDEN())
}

// Usage in routes
val usersController = routes {
    withTransaction {
        POST() with body<CreateUserRequest>() isHandledBy createUser
        
        userId / "posts" / {
            authenticated {
                GET() onlyIf principalEquals(userId) isHandledBy getPosts
                POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost
            }
        }
    }
}
```

This example shows how decorations (`withTransaction`, `authenticated`) can be combined with conditions (`principalEquals`) to create a comprehensive authentication and authorization system.

### Logging with Transaction Management

```kotlin
val routes = routes {
    logged {
        withTransaction {
            GET("users").isHandledBy { getUsers() }
            POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }
        }
    }
}
```

### API Versioning

```kotlin
fun withApiVersion(version: Int) = decorateWith {
    request.attributes["apiVersion"] = version
    next()
}

// Usage
val routes = routes {
    withApiVersion(1) {
        GET("api/users").isHandledBy { getUsersV1() }
    }
    
    withApiVersion(2) {
        GET("api/users").isHandledBy { getUsersV2() }
    }
}
```

### Rate Limiting

```kotlin
fun rateLimit(maxRequests: Int, perTimeWindow: Duration) = decorateWith {
    val clientIp = request.undertow.exchange.sourceAddress.address.hostAddress
    val requestCount = rateLimiter.getRequestCount(clientIp, perTimeWindow)
    
    if (requestCount >= maxRequests) {
        return@decorateWith "Rate limit exceeded. Try again later.".error(TOO_MANY_REQUESTS)
    }
    
    rateLimiter.incrementRequestCount(clientIp)
    next()
}

// Usage
rateLimit(2, Duration.ofMinutes(1)) {
    GET("api/messages").isHandledBy { "Messages".ok }
}
```

### Caching

```kotlin
fun cache(ttl: Duration) = decorateWith {
    val cacheKey = "${request.method.name}-${request.path}"
    val cachedResponse = cacheService.get(cacheKey)

    if (cachedResponse != null) {
        return@decorateWith RawHttpResponse(StatusCodes.OK, cachedResponse)
    }

    val response = next()
    cacheService.put(cacheKey, response.value(parser) as String, ttl)
    response
}

// Usage
cache(Duration.ofMinutes(5)) {
    GET("api/products").isHandledBy { getProducts() }
}
```

By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application. By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application. 


---

## From: Mastering-Snitch-Parameters.md

# Parameters

Parameters are a fundamental part of HTTP communication, allowing clients to send data to your server. Snitch provides an expressive, type-safe approach to handling various types of parameters including path parameters, query parameters, headers, and request bodies.

This tutorial will guide you through the complete parameter system in Snitch, from basic usage to advanced validation and transformation techniques.

## Basic Parameter Types

Snitch supports all common HTTP parameter types:

- **Path parameters**: Values embedded in the URL path (e.g., `/users/{userId}`)
- **Query parameters**: Key-value pairs appended to the URL (e.g., `?page=1&limit=10`)
- **Header parameters**: HTTP headers sent with the request
- **Request body**: Data sent in the request payload

Let's see how each is defined and accessed.

## Path Parameters

Path parameters are defined using the `path()` factory function:

```kotlin
// Define a path parameter
val userId by path()
```

Once defined, you can use it in route definitions:

```kotlin
GET("users" / userId) isHandledBy {
    // Access the parameter value with request[userId]
    val userIdValue = request[userId]
    userRepository.findById(userIdValue).ok
}
```

You can also define paths with validation in one line:

```kotlin
// Define a path parameter with validation
val postId by path(ofNonEmptyString, description = "Post identifier")
```

## Query Parameters

Query parameters are defined using the `query()` factory function:

```kotlin
// Define a required query parameter
val searchTerm by query(description = "Term to search for")

// With validation
val limit by query(ofNonNegativeInt, description = "Maximum number of results")
```

Using query parameters in routes:

```kotlin
GET("search") withQuery searchTerm withQuery limit isHandledBy {
    // Access the parameters
    val term = request[searchTerm] // String
    val maxResults = request[limit] // Int
    
    searchService.search(term, maxResults).ok
}
```

## Header Parameters

Header parameters are defined using the `header()` factory function:

```kotlin
// Define a required header parameter
val contentType by header(description = "Content type of the request")

// With validation
val apiVersion by header(ofNonEmptyString, description = "API version to use")
```

Using header parameters:

```kotlin
POST("data") withHeader contentType withHeader apiVersion isHandledBy {
    // Access the headers
    val type = request[contentType]
    val version = request[apiVersion]
    
    // Use the header values
    dataService.processData(request.body(), type, version).created
}
```

## Request Body

Request bodies are handled differently from other parameters. Instead of defining them separately, you declare them directly in the route definition:

```kotlin
// Define a route with a body parameter
POST("users") with body<CreateUserRequest>() isHandledBy {
    // Access the body with the `body` property
    val newUser = body
    
    userService.createUser(newUser.name, newUser.email).created
}
```

For more complex scenarios, you can use the `parsing` function:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    userService.createUser(body.name, body.email).created
}

// Use the handler
POST("users") with body<CreateUserRequest>() isHandledBy createUser
```

## Parameter Validation and Transformation

Snitch parameters are not just for accessing raw values - they also validate and transform the input data. The framework provides several built-in validators:

```kotlin
// String validation
val name by query(ofNonEmptyString)

// Numeric validation
val age by query(ofPositiveInt)
val price by query(ofNonNegativeDouble)

// Boolean validation
val enabled by query(ofBoolean)

// Date validation
val birthdate by query(ofIsoDate)
```

These validators:
1. Check if the input matches expected format
2. Convert the input to the appropriate type
3. Return 400 Bad Request with descriptive error messages if validation fails

## Optional Parameters

Not all parameters are required. For optional parameters, use the `optionalQuery()` and `optionalHeader()` functions:

```kotlin
// Optional parameter without default (can be null)
val sort by optionalQuery(ofNonEmptyString, description = "Sort direction")

// Optional parameter with default value
val page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")
val limit by optionalQuery(ofNonNegativeInt, default = 20, description = "Results per page")
```

When using optional parameters:

```kotlin
GET("users") withQuery page withQuery limit withQuery sort isHandledBy {
    // Access the parameters (with default values applied)
    val pageNum = request[page]     // Int, defaults to 1 if not provided
    val pageSize = request[limit]   // Int, defaults to 20 if not provided
    val sortDir = request[sort]     // String or null if not provided
    
    userService.getUsers(pageNum, pageSize, sortDir).ok
}
```

## Custom Validators

While built-in validators cover many scenarios, you'll often need custom validation logic, especially when working with domain-specific types.

### Creating Custom Validators

Use `stringValidator` or `validator` to create custom validators:

```kotlin
// Simple custom validator for email format
val ofEmail = stringValidator("valid email address", """^[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,}$""".toRegex()) { it }

// Custom validator with transformation to domain type
val ofUserId = stringValidator("valid UUID") { UserId(UUID.fromString(it)) }
```

Using custom validators:

```kotlin
val email by query(ofEmail, description = "User email address")
val userId by path(ofUserId, description = "User identifier")
```

## Domain Type Conversion

Converting raw parameter values to domain types is a best practice. Snitch makes this seamless:

```kotlin
// Define domain types
data class UserId(val value: UUID)
data class OrderStatus(val value: String) {
    init {
        require(value in listOf("PENDING", "COMPLETED", "CANCELLED")) {
            "Invalid order status: $value"
        }
    }
}

// Create validators for domain types
val ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }
val ofOrderStatus = stringValidator("order status") { OrderStatus(it.uppercase()) }

// Use with parameters
val userId by path(ofUserId)
val status by query(ofOrderStatus)
```

## Parameter Naming

By default, parameter names in requests match their property names in code. You can customize this:

```kotlin
// Custom parameter name
val searchQuery by query(name = "q", description = "Search query")
val userIdentifier by path(name = "user_id", description = "User ID")
```

With these definitions:
- The query parameter will be accessed as `?q=search terms`
- The path parameter will be defined as `/users/{user_id}`

## Advanced Parameter Handling

### Handling Empty Values

Control how empty values are treated:

```kotlin
// Empty values treated as missing
val tag by query(emptyAsMissing = true)

// Invalid values treated as missing (for optional parameters)
val count by optionalQuery(ofNonNegativeInt, invalidAsMissing = true, default = 0)
```

### Parameter Visibility in Documentation

Control whether parameters appear in public API documentation:

```kotlin
// Internal parameter not shown in public docs
val debugMode by optionalQuery(ofBoolean, visibility = Visibility.INTERNAL)
```

### Handling Multiple Values

For parameters that may be provided multiple times:

```kotlin
// Define a repeatable parameter
val tags by query(ofStringSet)  // Will collect all values into a Set<String>

// Custom repeatable validator
val ofUserIds = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }
val userIds by query(ofUserIds)  // Will collect all values into a Collection<UserId>
```

## Best Practices

1. **Use Domain Types**: Convert raw strings to meaningful domain types as early as possible.

2. **Validate Thoroughly**: Define validation rules that catch all potential issues before they reach your business logic.

3. **Provide Descriptive Error Messages**: Set clear validator descriptions so clients receive helpful error messages.

4. **Set Sensible Defaults**: For optional parameters, choose default values that make sense for most use cases.

5. **Document Parameters**: Always include a description for parameters to generate comprehensive API documentation.

6. **Consistent Naming**: Use a consistent naming convention for parameter properties.

7. **Explicitly Register Parameters**: Always declare parameter usage with `withQuery`, `withHeader`, etc., even if the validation is done elsewhere.

```kotlin
// Good practice
GET("users") withQuery page withQuery limit isHandledBy { ... }

// Not recommended (parameters not explicitly registered)
GET("users") isHandledBy {
    // Using parameters without registering them
    val pageValue = request.queryParams("page")
}
```

## Complete Example

Here's a complete example demonstrating different parameter types together:

```kotlin
// Domain types
data class UserId(val value: UUID)
data class PostId(val value: String)

// Validators
val ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }
val ofPostId = stringValidator("valid post ID") { PostId(it) }

// Parameters
val userId by path(ofUserId, description = "User identifier")
val postId by path(ofPostId, description = "Post identifier")
val includeComments by query(ofBoolean, description = "Whether to include comments")
val limit by optionalQuery(ofNonNegativeInt, default = 10, description = "Maximum results")
val apiVersion by header(ofNonEmptyString, description = "API version")

// Routes
val userController = routes {
    GET("users" / userId) withHeader apiVersion isHandledBy getUser
    
    GET("users" / userId / "posts") withQuery limit isHandledBy getUserPosts
    
    GET("posts" / postId) withQuery includeComments isHandledBy getPost
}

// Handlers
val getUser by handling {
    val user = userService.getUser(request[userId])
    user.ok
}

val getUserPosts by handling {
    val posts = postService.getUserPosts(
        userId = request[userId],
        limit = request[limit]
    )
    posts.ok
}

val getPost by handling {
    val post = postService.getPost(
        postId = request[postId],
        includeComments = request[includeComments]
    )
    post.ok
}
```

With Snitch's parameter system, you can build robust, type-safe APIs that validate input data before it reaches your business logic, resulting in cleaner code and better error handling.

---

## From: Mastering-Snitch-Validators.md

# Validators

Validators are a core feature of Snitch that ensure your HTTP inputs are properly validated, transformed, and documented. This guide will walk you through everything you need to know about validators, from basic usage to advanced customization.

## Introduction to Validators

In HTTP applications, inputs from requests (path parameters, query parameters, headers, body) are always strings or collections of strings. However, your business logic typically requires strongly-typed values with guaranteed validity. Validators are the bridge that transforms these raw inputs into safe, typed values.

At their core, validators in Snitch serve three main purposes:

1. **Validation**: Ensuring inputs meet specific criteria
2. **Transformation**: Converting strings to appropriate target types
3. **Documentation**: Providing clear descriptions for API documentation

The `Validator<T, R>` interface is defined with two type parameters:
- `T`: The input type (usually `String`)
- `R`: The output type (the type you want to work with in your code)

And three main components:
- `regex`: A regular expression pattern for basic string validation
- `description`: A human-readable description for documentation
- `parse`: A function that transforms validated input into the output type

## Built-in Validators

Snitch comes with a comprehensive set of built-in validators for common use cases:

### Numeric Validators

```kotlin
// Integer validators
val ofInt: Validator<Int, Int>
val ofNonNegativeInt: Validator<Int, Int>
val ofPositiveInt: Validator<Int, Int>
fun ofIntRange(min: Int, max: Int): Validator<Int, Int>

// Decimal validators
val ofDouble: Validator<Double, Double>
fun ofDoubleRange(min: Double, max: Double): Validator<Double, Double>
```

### String Validators

```kotlin
val ofNonEmptyString: Validator<String, String>
val ofNonEmptySingleLineString: Validator<String, String>
fun ofStringLength(minLength: Int, maxLength: Int): Validator<String, String>
val ofAlphanumeric: Validator<String, String>
fun ofRegexPattern(pattern: String, description: String): Validator<String, String>
```

### Special Format Validators

```kotlin
val ofEmail: Validator<String, String>
val ofUrl: Validator<String, URI>
val ofIpv4: Validator<String, String>
val ofPhoneNumber: Validator<String, String>
val ofJson: Validator<String, String>
```

### Date/Time Validators

```kotlin
val ofDate: Validator<String, LocalDate>
val ofDateTime: Validator<String, LocalDateTime>
fun ofDateFormat(format: String): Validator<String, LocalDate>
```

### Collection Validators

```kotlin
val ofStringSet: Validator<String, Set<String>>
val ofNonEmptyStringSet: Validator<String, Set<String>>
```

### Boolean Validators

```kotlin
val ofBoolean: Validator<Boolean, Boolean>  // Handles true/false, yes/no, 1/0
```

### ID Validators

```kotlin
val ofUuid: Validator<String, UUID>
```

### Enum Validators

```kotlin
inline fun <reified E : Enum<*>> ofEnum(): Validator<String, E>
inline fun <reified E : Enum<*>> ofRepeatableEnum(): Validator<String, Collection<E>>
```

## Using Validators with Parameters

Validators are typically used when defining parameters:

```kotlin
// Path parameters
val userId by path(ofNonNegativeInt)
val username by path(ofAlphanumeric)

// Query parameters
val limit by query(ofIntRange(1, 100))
val sortBy by query(ofEnum<SortField>())
val email by query(ofEmail)

// Header parameters
val apiKey by header(ofUuid)
val contentType by header(ofNonEmptyString)
```

When used in routes, parameters are automatically validated:

```kotlin
GET("users" / userId) withQuery limit isHandledBy {
    // Access validated parameters
    val id: Int = request[userId]      // Already validated and parsed
    val maxItems: Int = request[limit] // Already validated and parsed
    
    usersRepository.getUsers(id, maxItems).ok
}
```

## Creating Custom Validators

While built-in validators cover many common cases, you'll often need custom validators for domain-specific types. Snitch makes this straightforward:

### Basic Custom Validator

```kotlin
// Define a domain type
data class UserId(val value: String)

// Create a validator
val ofUserId = validator<String, UserId>(
    "valid user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    UserId(it)
}

// Use it with a parameter
val userId by path(ofUserId)
```

### Full Custom Validator Implementation

For more complex validation logic:

```kotlin
object UserIdValidator : Validator<String, UserId> {
    override val description = "Valid user ID (8-12 alphanumeric characters)"
    override val regex = """^[a-zA-Z0-9]{8,12}$""".toRegex()
    override val parse: Parser.(Collection<String>) -> UserId = { collection ->
        val value = collection.first()
        if (userRepository.exists(value)) {
            UserId(value)
        } else {
            throw IllegalArgumentException("User ID does not exist")
        }
    }
}

// Use it with a parameter
val userId by path(UserIdValidator)
```

### Factory Functions

Snitch provides several factory functions to create validators:

```kotlin
// For generic validators
fun <From, To> validator(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(String) -> To
): Validator<From, To>

// For string validators
fun <To> stringValidator(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(String) -> To
): Validator<String, To>

// For multi-value validators
fun <From, To> validatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
): Validator<From, To>

// For string collection validators
fun <To> stringValidatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
): Validator<String, To>
```

## Advanced Validator Patterns

### Combining Validation and Business Logic

Sometimes validation involves checking against business rules:

```kotlin
val ofActiveUser = validator<String, User>(
    "active user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    val user = userRepository.findById(it) 
        ?: throw IllegalArgumentException("User not found")
        
    if (!user.isActive) {
        throw IllegalArgumentException("User is not active")
    }
    
    user
}
```

### Chaining Validations

You can chain validations by creating validators that build on others:

```kotlin
val ofEmail = validator<String, String>(
    "email address",
    """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
) { it }

val ofCorporateEmail = validator<String, String>(
    "corporate email address",
    """^[a-zA-Z0-9._%+-]+@company\.com$""".toRegex()
) { 
    // First validate it's an email
    ofEmail.regex.matchEntire(it) ?: throw IllegalArgumentException("Invalid email format")
    
    // Then check for specific domain
    if (!it.endsWith("@company.com")) {
        throw IllegalArgumentException("Must be a company.com email")
    }
    
    it
}
```

### JWT Validators

Here's an example of a JWT validator:

```kotlin
data class JwtClaims(val userId: String, val roles: List<String>)

sealed interface Authentication {
    data class Authenticated(val claims: JwtClaims) : Authentication
    sealed interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object ExpiredToken : Unauthenticated
    object MissingToken : Unauthenticated
}

val validAccessToken = stringValidator<Authentication>("valid JWT") { jwt ->
    try {
        val jwtVerifier = JWT.require(Algorithm.HMAC256(secretKey))
            .withIssuer("auth-service")
            .build()
            
        val decodedJWT = jwtVerifier.verify(jwt)
        val userId = decodedJWT.getClaim("userId").asString()
        val roles = decodedJWT.getClaim("roles").asList(String::class.java)
        
        Authentication.Authenticated(JwtClaims(userId, roles))
    } catch (e: TokenExpiredException) {
        Authentication.ExpiredToken
    } catch (e: Exception) {
        Authentication.InvalidToken
    }
}

// Use it with a parameter
val accessToken by header(validAccessToken, name = "Authorization")
```

## Handling Collections and Optional Values

### Multiple Values

For parameters that accept multiple values:

```kotlin
val tags by query(ofStringSet)
val roles by query(ofRepeatableEnum<UserRole>())

// In the handler
val userTags: Set<String> = request[tags]
val userRoles: Collection<UserRole> = request[roles]
```

### Optional Parameters

For optional parameters:

```kotlin
// Nullable parameter
val search by optionalQuery(ofNonEmptyString)

// Parameter with default value
val limit by optionalQuery(ofIntRange(1, 100), default = 20)

// Control empty and invalid handling
val page by optionalQuery(
    ofNonNegativeInt, 
    default = 1, 
    emptyAsMissing = true,  // Treat empty string as missing
    invalidAsMissing = true // Use default if parsing fails
)

// In the handler
val searchTerm: String? = request[search] // Nullable
val maxItems: Int = request[limit]       // Always has value (default if missing)
val pageNumber: Int = request[page]      // Has default if empty or invalid
```

## Best Practices

### 1. Use Domain Types

Instead of primitives, use domain-specific types with validators:

```kotlin
// Bad
val userId by path(ofNonEmptyString)

// Good
data class UserId(val value: String)
val ofUserId = validator<String, UserId>("user ID") { UserId(it) }
val userId by path(ofUserId)
```

### 2. Provide Clear Error Messages

When validation fails, provide clear, actionable error messages:

```kotlin
val ofWeekday = validator<String, DayOfWeek>(
    "weekday name (Monday-Friday)",
    """^[A-Za-z]+$""".toRegex()
) {
    try {
        DayOfWeek.valueOf(it.uppercase())
    } catch (e: IllegalArgumentException) {
        throw IllegalArgumentException("'$it' is not a valid weekday (Monday-Friday)")
    }
}
```

### 3. Keep Validators Reusable

If a validation logic is used in multiple places, define it once and reuse:

```kotlin
// Shared across multiple endpoints/controllers
object Validators {
    val ofEmail = validator<String, String>(
        "email address",
        """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
    ) { it }
    
    val ofZipCode = validator<String, String>(
        "ZIP code",
        """^\d{5}(-\d{4})?$""".toRegex()
    ) { it }
}
```

### 4. Validate at the Edge

Catch invalid inputs at the HTTP layer rather than deep in business logic:

```kotlin
// Let Snitch handle validation
val email by query(ofEmail)

// In the handler - already validated and safe to use
val emailAddress = request[email]
```

### 5. Test Your Validators

Create unit tests for your validators, especially custom ones:

```kotlin
@Test
fun `ofEmail validator should accept valid email addresses`() {
    val validEmails = listOf(
        "user@example.com",
        "firstname.lastname@example.com",
        "user+tag@example.com"
    )
    
    validEmails.forEach { email ->
        assertTrue(ofEmail.regex.matches(email))
    }
}

@Test
fun `ofEmail validator should reject invalid email addresses`() {
    val invalidEmails = listOf(
        "",
        "user@",
        "@example.com",
        "user@example"
    )
    
    invalidEmails.forEach { email ->
        assertFalse(ofEmail.regex.matches(email))
    }
}
```

## Conclusion

Validators are a powerful feature of Snitch that ensure your HTTP inputs are properly validated and transformed. By using validators effectively, you can:

- Create more robust APIs with clear, consistent validation
- Transform raw HTTP inputs into domain-specific types
- Generate accurate API documentation automatically
- Reduce boilerplate validation code in your handlers
- Enforce validation at the edge of your application

Remember that validators are not just for validation but also for transformation. Using them effectively enables you to work with strongly typed values throughout your codebase, making your application more maintainable and less error-prone.

---

## From: README.md

# Deep Dive

Welcome to the in-depth guides! This section contains detailed guides to help you master different aspects of Snitch.

## Getting Started
- [Quick Start Guide](../tutorials/QuickStart.md) - Set up a basic Snitch application in minutes
- [Artifacts Overview](../resources/Artifacts.md) - Learn about all the modules in the Snitch ecosystem
- [Using Shank with Snitch](../tutorials/UsingShank.md) - Dependency injection guide
- [Advanced Shank Patterns](../tutorials/ShankPatterns.md) - Design patterns for effective dependency management

## Core Concepts
- [Anatomy of Endpoints](Anatomy-of-Endpoints.md) - Understanding the structure of endpoints in Snitch
- [Anatomy of Handlers](Anatomy-of-Handlers.md) - Deep dive into request handlers
- [Anatomy of Validators](Anatomy-of-Validators.md) - Learn how validation works

## Advanced Features
- [Mastering Snitch Parameters](Mastering-Snitch-Parameters.md) - Everything about parameters
- [Mastering Snitch Conditions](Mastering-Snitch-Conditions.md) - Advanced access control
- [Mastering Snitch BeforeAfter](Mastering-Snitch-BeforeAfter.md) - Pre and post-processing
- [Mastering Snitch Decorations](Mastering-Snitch-Decorations.md) - Custom middleware
- [Mastering Snitch Validators](Mastering-Snitch-Validators.md) - Creating custom validators

## Case Studies
Check out our blog for real-world implementations and case studies:
- [Blog Posts](../../blog/)

---

## From: Artifacts.md

# Snitch Artifacts

Snitch is modular by design, providing several artifacts that can be used independently based on your needs. All artifacts are published to Maven Central with the prefix `io.github.memoizr:snitch-{module-name}`.

## Core Artifacts

### snitch-bootstrap

```kotlin
implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
```

This is the main artifact most users should depend on. It includes everything needed to create a complete web service using Snitch with Undertow as the server and Gson for JSON parsing.

**Dependencies**: Includes core, gsonparser, and undertow modules.

### snitch-core

```kotlin
implementation("io.github.memoizr:snitch-core:1.0.0")
```

The core module contains the essential building blocks of Snitch:
- DSL for defining routes and handlers
- Parameter definition and validation framework
- Middleware and conditions system
- Documentation generation engine

This module is server-agnostic and doesn't include any specific JSON parsing implementation.

### snitch-types

```kotlin
implementation("io.github.memoizr:snitch-types:1.0.0")
```

A lightweight module containing the basic types and interfaces used across the Snitch ecosystem. This module has minimal dependencies and can be used in your domain model to avoid pulling in the entire Snitch framework.

## Extensions and Implementations

### snitch-undertow

```kotlin
implementation("io.github.memoizr:snitch-undertow:1.0.0")
```

Provides Undertow server integration for Snitch. Undertow is a flexible, high-performance web server by JBoss that serves as the default server implementation for Snitch.

### snitch-gsonparser

```kotlin
implementation("io.github.memoizr:snitch-gsonparser:1.0.0")
```

Implements JSON parsing and serialization using Google's Gson library. This module allows Snitch to convert between JSON and Kotlin objects.

### snitch-coroutines

```kotlin
implementation("io.github.memoizr:snitch-coroutines:1.0.0")
```

Adds Kotlin Coroutines support to Snitch, allowing you to define suspending handlers and use the full power of Kotlin's asynchronous programming features.

Requires the `-Xcontext-receivers` compiler flag:

```kotlin
tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = freeCompilerArgs + "-Xcontext-receivers"
    }
}
```

### snitch-validation

```kotlin
implementation("io.github.memoizr:snitch-validation:1.0.0")
```

Provides integration with Hibernate Validator (Jakarta Bean Validation), allowing you to use standard validation annotations in your request/response models.

### snitch-tests

```kotlin
testImplementation("io.github.memoizr:snitch-tests:1.0.0")
```

Contains testing utilities and a fluent DSL for writing integration tests for Snitch services. Includes assertion helpers and logging configuration for tests.

## Choosing the Right Dependencies

For most applications, the bootstrap module is sufficient:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

For applications requiring coroutines:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("io.github.memoizr:snitch-coroutines:1.0.0")
}
```

For advanced validation with Hibernate Validator:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("io.github.memoizr:snitch-validation:1.0.0")
}
```

For a more customized setup using a different JSON library or web server, you can use just the core module and add your own implementations:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-core:1.0.0")
    // Add your preferred JSON parser and server
}
```

## Artifact Breakdown

| Artifact | Purpose | Key Features |
|----------|---------|--------------|
| snitch-bootstrap | Complete starter package | All-in-one solution for getting started quickly |
| snitch-core | Core framework | Route definitions, handlers, parameter validation, middleware |
| snitch-types | Common types | Basic types used throughout the framework |
| snitch-undertow | Server implementation | Integrates with Undertow web server |
| snitch-gsonparser | JSON parsing | Handles JSON serialization/deserialization with Gson |
| snitch-coroutines | Async support | Kotlin Coroutines integration for asynchronous handlers |
| snitch-validation | Enhanced validation | Hibernate Validator integration |
| snitch-tests | Testing utilities | Testing DSL and assertion helpers |

---

