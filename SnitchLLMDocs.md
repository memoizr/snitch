# Snitch Documentation

*This file was automatically generated by concatenating documentation files.*

---

## From: What is Snitch.md

# Kotlin's Most Elegant HTTP Framework

In today's microservices-driven world, creating robust, well-documented, and maintainable HTTP APIs has become a critical challenge for development teams. **Snitch** emerges as a game-changing solution in this landscape—a lightweight, type-safe Kotlin framework designed to help developers build production-grade HTTP layers with minimal effort while automatically generating comprehensive documentation.

## The Snitch Advantage: Why It's Transforming How We Build APIs

Snitch isn't just another web framework. It's a thoughtfully designed layer built on established embedded web servers like Undertow, offering the perfect balance of performance, type safety, and developer experience. Thanks to Kotlin's inlining capabilities, Snitch delivers exceptional performance without sacrificing readability or maintainability.

### What Sets Snitch Apart From Traditional API Frameworks

- **Zero-Effort Documentation**: Snitch automatically generates complete OpenAPI 3.0 documentation without requiring a single line of documentation code
- **Pure Kotlin Approach**: No reflection, annotations, or code generation for production code
- **Expressive DSL**: Creates the most readable and maintainable API for building HTTP services
- **Strong Type Safety**: Comprehensive parameter validation and domain type mapping
- **Performance-First Design**: As lightweight and fast as the underlying web server
- **Seamless Coroutines Support**: Async by default without sacrificing readability
- **Minimal Overhead**: Small learning curve despite its powerful DSL capabilities

## Getting Started with Snitch in Minutes

Adding Snitch to your project is straightforward:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

And creating your first API is just as simple:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.snitch
import snitch.dsl.routes
import snitch.dsl.response.ok

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("/hello") isHandledBy { "world".ok }
        }
        .start()
        .serveDocumenation()
}
```

This minimal example creates a service that:
- Responds with "world" when you make a GET request to `/hello`
- Automatically generates and serves interactive API documentation at `/docs`

## Snitch's Core Features: The Building Blocks of Modern APIs

### 1. Expressive Routing with Intuitive Syntax

Snitch's DSL allows you to define routes in a clear, intuitive way that makes even complex routing structures easy to understand:

```kotlin
val usersController = routes {
    POST() with body<CreateUserRequest>() isHandledBy createUser
    POST("login") with body<LoginRequest>() isHandledBy userLogin

    userId / "posts" / {
        authenticated {
            GET() onlyIf principalEquals(userId) isHandledBy getPosts
            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost

            GET(postId) isHandledBy getPost
            PUT(postId) with body<UpdatePostRequest>() onlyIf principalEquals(userId) isHandledBy updatePost
            DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
        }
    }
}
```

The DSL is flexible enough to support different team preferences—routes can be grouped by path, by HTTP method, or in a hybrid approach. This adaptability makes Snitch suitable for teams with different coding styles and organizational preferences.

### 2. Comprehensive Type-Safe Parameter Handling

Snitch's parameter handling system ensures all inputs are validated and mapped to appropriate domain types:

```kotlin
// Path parameters
val userId by path(ofUserId)
val postId by path(ofPostId)

// Query parameters with validation
val limit by query(ofNonNegativeInt(max = 30))
val offset by query(ofNonNegativeInt())
val sort by optionalQuery(ofEnum<Sorting>(), default = NEW)

// Headers with custom validation
val accessToken by header(ofValidAccessToken)

// Custom validators for domain types
val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }
val ofValidAccessToken = stringValidator("valid jwt") { jwt().validate(it) }
```

This approach ensures that by the time your handler code runs, all parameters have been validated and transformed into their proper domain types, eliminating the need for repetitive validation code.

### 3. Powerful Middleware System

Snitch provides a flexible middleware system that simplifies cross-cutting concerns:

```kotlin
// Simple logging middleware
val Router.log get() = decorateWith {
    logger().info("Begin Request: ${request.method.name} ${request.path}")
    next().also {
        logger().info("End Request: ${request.method.name} ${request.path} ${it.statusCode.code}")
    }
}

// Transaction middleware for database operations
val Router.withTransaction get() = decorateWith { 
    transaction { next() } 
}

// Apply middleware to routes
val rootRouter = routes {
    log {
        withTransaction {
            "users" / usersController
            "posts" / postsController
        }
    }
}
```

Middleware can be applied to entire route hierarchies or individual endpoints, giving you precise control over behavior.

### 4. Advanced Access Control with Guards and Conditions

Snitch's guard system provides a clean, expressive syntax for controlling access to endpoints:

```kotlin
// Define conditions
val hasAdminRole = condition("hasAdminRole") {
    when (role) {
        ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Not an admin".forbidden())
    }
}

val isResourceOwner = condition("isResourceOwner") {
    if (principal.id == request[resourceId]) ConditionResult.Successful
    else ConditionResult.Failed("Not the resource owner".forbidden())
}

// Apply conditions to endpoints
DELETE("resource" / resourceId) onlyIf (isResourceOwner or hasAdminRole) isHandledBy { deleteResource() }
```

Conditions support logical operators for complex access rules and can be applied to entire route hierarchies, providing a powerful yet readable way to implement authorization.

### 5. Automated Documentation That's Always Up-to-Date

Perhaps Snitch's most impressive feature is its ability to generate complete OpenAPI 3.0 documentation with absolutely no additional effort:

```kotlin
snitch(GsonJsonParser)
    .onRoutes(rootRouter)
    .generateDocumentation()
    .servePublicDocumenation()
    .start()
```

Every input, output, parameter, and response code is automatically documented, giving you interactive Swagger UI pages that stay perfectly in sync with your code. This eliminates the documentation drift that plagues many API projects.

### 6. Seamless Integration with Shank for Dependency Injection

Snitch integrates with Shank, a high-performance dependency injection library:

```kotlin
// Define modules with dependencies
object ApplicationModule : ShankModule {
    val logger = single { -> LoggerImpl() }
    val clock = single { -> Clock.systemUTC() }
}

object RepositoryModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
}

// Use dependencies in handlers
val getUsers by handling {
    val logger = ApplicationModule.logger()
    val usersRepo = RepositoryModule.usersRepository()
    
    logger.info("Fetching all users")
    usersRepo.getUsers().ok
}
```

Shank provides best-in-class performance with strictly type-safe dependency management, built-in cycle detection, and zero reflection overhead—all in a lightweight package.

## Real-World Applications: Where Snitch Shines

Snitch excels in a variety of scenarios:

### Microservices Architecture

In microservices environments, Snitch offers:
- **Light resource footprint**: Runs in as little as 12MB of RAM
- **Fast startup time**: Minimal overhead means services start quickly
- **Automatic documentation**: Each service self-documents its API
- **Strong contract enforcement**: Type safety ensures API contracts are maintained

### High-Performance APIs

When performance is critical, Snitch delivers:
- **Minimal overhead**: Thin layer on top of high-performance web servers
- **Low GC pressure**: Careful design minimizes object creation
- **No reflection**: Zero runtime reflection for request handling
- **Shallow call stack**: Optimized for execution speed

### Teams with Documentation Requirements

For teams that need to maintain API documentation:
- **Zero documentation effort**: Documentation generated automatically
- **Always up-to-date**: Documentation reflects the actual code
- **Interactive Swagger UI**: Test endpoints directly from documentation
- **OpenAPI 3.0 compatibility**: Integrates with API management tools

## Best Practices for Building with Snitch

### 1. Domain-Driven Design

Snitch encourages mapping HTTP inputs to domain types:

```kotlin
// Transform raw string to domain type
val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }
val userId by path(ofUserId)

// In handler, work with domain types
val getUser by handling {
    // userId is already a UserId domain type
    userRepository().getUser(request[userId]).ok
}
```

This approach creates a clean separation between your HTTP layer and domain logic.

### 2. Middleware for Cross-Cutting Concerns

Use middleware for aspects that span multiple endpoints:

```kotlin
// Apply logging, authentication, and transactions
routes {
    log {
        authenticated {
            withTransaction {
                "users" / usersController
            }
        }
    }
}
```

This keeps your handlers focused on business logic rather than infrastructure concerns.

### 3. Granular Access Control

Leverage Snitch's condition system for fine-grained access control:

```kotlin
onlyIf(hasAdminRole) {
    "admin" / adminController
}

"users" / userId / "posts" / {
    GET() isHandledBy getPosts // Anyone can read posts
    POST() onlyIf principalEquals(userId) isHandledBy createPost // Only post owner can create
    DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost // Owner or admin can delete
}
```

This makes your authorization rules explicit and declarative.

## The Future of API Development with Snitch

In an era where API development often involves significant boilerplate and documentation overhead, Snitch offers a refreshing alternative. By combining Kotlin's expressive syntax with automatic documentation generation and strong type safety, Snitch allows developers to focus on what matters most: building great services.

The framework's design philosophy—focused on readability, type safety, and minimal ceremony—represents the future direction of API development tools. As microservices continue to proliferate and API-first development becomes standard practice, tools like Snitch that streamline the development process while enforcing good practices will become increasingly valuable.

## Getting Started with Snitch Today

Ready to transform your API development experience? Here's how to get started:

1. **Add the dependency** to your Gradle build file
2. **Create your first endpoint** with the intuitive DSL
3. **Run your service** and explore the automatically generated documentation
4. **Learn more** through the comprehensive guides and tutorials

Join a growing community of developers who are discovering the power of Snitch for building elegant, performant, and well-documented APIs.

## Conclusion: Why Snitch Exists

The creators of Snitch believe that:
- Code should be as readable as possible
- Simple tasks shouldn't require complex ceremony
- Resources are precious and shouldn't be wasted
- Documentation is crucial but should be generated automatically
- Nobody should ever have to manually edit OpenAPI YAML or JSON files

Whether you're developing microservices, backend APIs, or full applications, Snitch provides the tools you need to create robust, well-documented HTTP layers with minimal effort and maximum readability.

[GitHub Repository](https://github.com/memoizr/snitch) | [Maven Central](https://central.sonatype.com/artifact/io.github.memoizr/snitch-bootstrap) | [Join Discord Community](https://discord.gg/bG6NW3UyxS) 

---

## From: Docs.md

# Snitch

### Introduction

Snitch is a small and typesafe web framework for Kotlin

```kotlin
fun main() {
    snitch(GsonJsonParser).onRoutes {
        GET("hello") isHandledBy { "world".ok }
    }.start()
} 
```

#### Features

- Lightweight and fast.
- Functional approach
- OpenAPI 3 support
- Fully asynchronous execution
- Plain Kotlin. No reflection, code generation, annotation processing.
- Kotlin compiler is enough. No Gradle plugins

### Getting started 

```Kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```
That's it, no need for command line tools, gradle plugins. It's just a simple library.


### Router
#### Routing basics
```kotlin
val root = routes {
    GET("foo") isHandledBy {
        "bar".ok
    }
    POST("foo") with body<FooRequest>() isHandledBy {
        "fooValue: ${body.fooValue}".created
    }
}
```        

The infix style is optional and a classic fluent approach is also supported.

```kotlin
val root = routes {
    GET("foo").isHandledBy {
        "bar".ok
    }
    POST("foo")
        .with(body<FooRequest>())
        .isHandledBy {
        "fooValue: ${body.fooValue}".created
    }
}
```        

Notice that `GET("/foo")` and `GET("foo")` are the same thing

You pass the router to the `onRoutes` function 
```kotlin
fun main() {
    snitch(GsonJsonParser).onRoutes(root).start()
} 
```

Of course in a real application you'd like to separate the route declarations from the endpoint implementations.

```kotlin
val root = routes {
    GET("foo") isHandledBy getFoo
    POST("foo") with body<FooRequest>() isHandledBy postFoo
}

val getFoo by handling {
    "bar".ok
}

val postFoo by parsing<FooRequest>() handling {
    "fooValue: ${body.fooValue}".created
}
```

#### Route Nesting
Services often have hundreds of routes, organized hierarchically. This can be modeled in Snitch:
```kotlin
val root = routes {
    "health" / healthController
    "users" / usersController
    "posts" / postsController
    ...
}

val usersController = routes {
    POST() with body<CreateUserRequest> isHandledBy createUser
    
    userId / {
        GET() isHandledBy getUser
        DELETE() isHandledBy deleteUser
        
        "posts" / {
            GET() isHandledBy getPosts
            POST() with body<CreatePostRequest> isHandledBy createPost
            postId / {
                GET() isHandledBy getPost
            }
        }
    }
}
```

This will define the following routes:
```
POST users
GET users/{userId}
DELETE users/{userId}
GET users/{userId}/posts
POST users/{userId}/posts
GET users/{userId}/posts/{postId}
```

Different teams however will have different styles that they endorse, so for those who would rather have a less DRY but more explicit route declaration, they can define the routes as:

```kotlin
val root = routes {
    healthController
    usersController
    postsController
    ...
}
val usersController = routes {
    POST("users") with body<CreateUserRequest> isHandledBy createUser
    
    GET("users" / userId) isHandledBy getUser
    DELETE("users" / userId) isHandledBy deleteUser

    GET("users" / userId / "posts") isHandledBy getPosts
    POST("users" / userId / "posts") with body<CreatePostRequest> isHandledBy createPost
    GET("users" / userId / "posts" / postId) isHandledBy getPost
}
```

The DSL is flexible so for teams that would like a measured and hybrid approach they can define the routes howerver they wish. For example grouping by path for all the actions supported on it:

```kotlin
val root = routes {
    healthController
    usersController
    postsController
    ...
}
val usersController = routes {
    "users" / {
        POST() with body<CreateUserRequest> isHandledBy createUser
    }
    "users" / userId / {
        GET() isHandledBy getUser
        DELETE() isHandledBy deleteUser
    }

    "users" / userId / "posts" / {
        GET() isHandledBy getPosts
        POST() with body<CreatePostRequest> isHandledBy createPost
    }

    "users" / userId / "posts" / postId / {
        GET() isHandledBy getPost
    }
}
```


#### HTTP input parameters

```kotlin
val userId by path()
val showDetails by query(ofBoolean)

val root = routes {
    GET("users" / userId / "profile")
        .with(showDetails)
        .isHandledBy {
            val user = UserId(request[userId])
            if (request[showDetails]) {
                usersRepository().profileDetails(user)
            } else {
                usersRepository().profileSummary(user)
            }.ok
        }
}
```        

Note: `userId` and `showDetails` are typed and validated. `request[showDetails]` will return a `Boolean` and `request[userId]` will return a `String`. If you don't pass a `Validator` such as `ofBoolean`, it defaults to `ofNonEmptyString`.  
Note: you have to declare the usage of a certain parameter in order to use it.

#### Input parameter validation and transformation
All parameters are validated and transformed to another type by default. Here's some more examples, let's add the type parameters explicitly so it's clear what's happening:

```Kotlin
val userId: String by path(nonEmptyString)  
val filters: Set<String> by path(ofNonEmptySet)
val showDetails: Boolean by path(ofBoolean)
```

#### Custom validations
Although there are a few built in validator-transformers, they offer a relatively weak typing. Best practice involves transforming and validating raw platform types into domain types. For example a `userId` is rarely actually just a string, for example it's unlikely the content of `Shakespeare.txt` parsed as string could possibly be a valid ID for a user. You most likely have a `value class UserId` defined somewhere. Likewise, a search filter is usually something like an `Enum` where you have a set of pre-determined filter values. 

Defining custom validator-transformers in snitch is simple:
```kotlin
value class UserId(val id: UUID)
enum class Filter { EXPIRED, ACTIVE, CANCELLED, PENDING }

val ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }

// explicit types can be omitted for conciseness, here included for illustrative purposes
val userId: UserId by path(ofUserId)
val filters: Collection<Filter> by query(ofRepeatableEnum<Filter>())
val filter: Filter by query(ofEnum<Filter>())
```

> *Note:* Snitch is optimized for production code use cases, and in the spirit of Kotlin, it *enforces* best practices. In production, you almost always need to validate and transfrom inputs consistently. Snitch lets you do this in only one line of code in most cases, leading to a more concise, explicit and consistent codebase, making it easier to maintain larger codebases and for new developers to quickly become productive. 

#### Optional input parameters
Declaring a parameter with `query` or `header` will make it required. If the parameter is not supplied a `400` message will be returned specifying that that particular parameter was expected but not provided, as well as any other parameter that also does not pass validation. Optional parameters can be declared as such:


```kotlin
// request[sort] is nullable
val sort: Sorting? by optionalQuery(ofEnum<Sorting>())
```

The optionality functionality is quite powerful, offering a clear and consistent way of specifying default values as well as defining a behaviour for when these values are provided as empty as or as invalid inputs:

```kotlin
// request[sort] is not nullable, NEW is the default value
val sort: Sorting by optionalQuery(ofEnum<Sorting>(), default = NEW)

val limit: Int by optionalQuery(ofNonNegativeInt, default = 20, emptyAsMissing = true, invalidAsMissing = true)
val offset: Int by optionalQuery(ofNonNegativeInt, default = 0, emptyAsMissing = true, invalidAsMissing = true)
```

#### Parameter naming
Snitch aims at being as concise and as less verbose as possible while delivering a full feature set for production use-cases. In this spirit when you define an input parameter such as `val q by query()` it will create a named query parameter that should be supplied as such for example:`?q=urlencodedquery`. Note that the name of the parameter `val` in the codebase is by default the same name as in the API. If you want it to be different, it's simple:
```kotlin
val searchQuery by query(name = "searchQuery")
```

`limit` and `offset` here are defined so that if these parameters were not provided, or provided incorrectly, a default value would be provided instead. This is in case a "fail quietly" behaviour is desired. By default, a `fail explicitly` behaviour is supported, so empty or invalid inputs will return a 400 to inform the API user they're probably doing something wrong.

#### Unsafe, undocumented parameter parsing
While Snitch *enforces* best practices, leading to a less verbose and more consistent codebase that implements them, it also supports an *unsafe* traditional approach. If you want to access a parameter sneakily, and you don't care for the parameter to be included in the documentation, you can do it very simply with the cowboy-friendly syntax:

```kotlin
val getCows by handling {
    ...
    request.queryParams("numberOfCows")
    request.headerParams("ranch")
    request.pathParams("ranchId")
    ...
}
```
Although this approach is supported for niche use cases, it is strongly discouraged that this be used for most production applications unless there is a good reason for it.

#### Repeated parameters
In HTTP one of the hidden challenges to creating a robust and production grade API is that of handling the edge case of query or header parameters provided repeatedly when exactly one or at most one is expected. By default `val searchQuery by query()` expects exactly one value being provided and `val searchQuery by optionalQuery()` provides at most one semantics, unexpected repetition will result in 400. Support for repeated parameters can be made explicity by using `... by query(ofStringSet)` for example, which uses a repeatable validator. Custom validator for repeatable can be created in a very similar way to non-repeatable validators:

```kotlin
val ofUserId = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }
```
#### Body parameter
Body parameters are treated differently than other input parameters as they are used in different ways. While it's common to share the same query parameters or headers between several endpoints (for example consider `limit`, `offset`, `orderBy`, `Access-Token` and so on), body parameters are often single use. Snitch aims at encouraging best  practices while reducing verbosity and clutter as much as possible, and in that spirit body parameter types are declared very simply:
```kotlin
POST("mypath") with body<MyRequest>() isHandleBy {
    // already parsed to MyRequest domain type
    request.body
}
```
This approach is typesafe, so if you were to omit the declaration of the body type, it would not be possible for you to access it within the handler:

```kotlin
POST("mypath") isHandleBy {
    // this resolves to Kotlin's Nothing special type and would not compile
    request.body
}
```
Binary path can also be supported inituitively by: `with(body<ByteArray>())`

### Middleware 
Snitch supports a very powerful and flexible middleware mechanism that can be used to implement a wide variety of features. Let's see how you can use it to create a simple logging behaviour applied to a route hierarchy:

```kotlin
val Router.log get() = decorateWith {
    logger().info("Begin Request: ${request.method.name} ${request.path}")
    next().also {
        logger().info("End Request: ${request.method.name} ${request.path} ${it.statusCode.code} ${it.value(parser)}")
    }
}
```

here `log` is a custom defined middleware logging behaviour. Its usage is very intuitive, and it's clear that such behaviour should be applied to any route defined within its block. Defining a new middleware is as straightforward as possible, here's the identity middleware, that simply calls the next action:
```kotlin
val Router.identity get() = decorateWith { next() }
```

the code block provided to `decorateWith` works similarly to the way handlers work, you can still access the request parameter in the same way with `request[myParam]` and can return responses with `ok` `created` `badRequest()` etc like in normal handlers.

Calling `next()` executes the code in the block of any nested middleware until it gets to the code block of the handler. `next()` returns the response from the next layer of the middleware and as such it can be transformed as appropriate. 

#### Order of execution
The order of execution, that is, what code is executed by the `next()` call, is dependent on the order of declaration. It works as your intuition would expect, inside out, from most nested to least nested:
```kotlin
//called second
log {
    // called first
    statistics {
        GET() ...
    }
}
```

### Security and access control
middleware allows for the implementation of powerful and granular access control systems. Here's a realistic example:

```kotlin
val Router.authenticated
    get() = transformEndpoints {
        with(listof(accessToken)).decorate {
            when (request[accessToken]) {
                is Authentication.Authenticated -> next()
                is Authentication.Unauthenticated -> UNAUTHORIZED()
            }
        }
    }

val accessToken: Authentication by header(validAccesstoken)

val validAccesstoken = validator<String, Authentication> { jwt().validate(it) }

sealed interface Authentication {
    data class Authenticated(val claims: JwtClaims) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object ExpiredToken : Unauthenticated
    object MissingToken : Unauthenticated
    object InvalidClaims : Unauthenticated
}
```

and this is how this is used:
```kotlin
authenticated {
        ...
        GET(userId / "posts") isHandledBy getPosts
        ...
    }
}
```
now, there's a lot to unpack in a few lines of code, let's break it down:
```kotlin
val Router.authenticated
    get() = decorateEndpoints {
        withHeader(accessToken).decorate {
            when (request[accessToken]) {
                is Authentication.Authenticated -> next()
                is Authentication.Unauthenticated -> UNAUTHORIZED()
            }
        }
    }
```

`decorateEndpoints` will apply whatever transformation inside the block to any endpoint to which this will be applied. `withHeader(accessToken)` is declaring and adding the `accessToken` header parameter to the endpoints, documentation will reflect that. `request[accessToken]` parses, validates and transforms the access token provided in the headers. It returns a domain type, and we can proceed to the next layer of middleware in case the token is valid, and return a 401 error in case it is not.

### Dependency Injection with Shank

Snitch integrates seamlessly with [Shank](/tutorials/UsingShank.md), the highest-performing dependency injection library available for the JVM. Shank provides best-in-class performance with strictly type-safe dependency management, built-in cycle detection, and zero reflection overhead - all in a lightweight 300kb package.

#### Setting Up Shank Modules

Organize your dependencies by creating modules:

```kotlin
import snitch.shank.ShankModule
import snitch.shank.single
import snitch.shank.new

// Application-wide dependencies
object ApplicationModule : ShankModule {
    val clock = single { -> Clock.systemUTC() }
    val logger = single { -> LoggerImpl() }
    val now = new { -> Instant.now(clock()) }
}

// Database-related dependencies
object DatabaseModule : ShankModule {
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/postgres",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    val database = single { -> PostgresDatabase(connection()) }
}

// Repository dependencies
object RepositoryModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }
}
```

#### Using Dependencies in Handlers

Inject dependencies into your handlers:

```kotlin
val getUsers by handling {
    val logger = ApplicationModule.logger()
    val usersRepo = RepositoryModule.usersRepository()
    
    logger.info("Fetching all users")
    usersRepo.getUsers().ok
}

val createUser by parsing<CreateUserRequest>() handling {
    val usersRepo = RepositoryModule.usersRepository()
    usersRepo.createUser(body.name, body.email).created
}
```

#### Creating Middleware with Dependency Injection

Combine middleware with dependency injection for powerful patterns:

```kotlin
val Router.withLogging get() = decorateWith {
    val logger = ApplicationModule.logger()
    logger.info("Request: ${request.method} ${request.path}")
    next().also {
        logger.info("Response: ${it.statusCode}")
    }
}

val Router.withTransaction get() = decorateWith {
    val db = DatabaseModule.database()
    db.transaction {
        next()
    }
}
```

Then use these in your routes:

```kotlin
routes {
    withLogging {
        withTransaction {
            "users" / {
                GET() isHandledBy getUsers
                POST() with body<CreateUserRequest>() isHandledBy createUser
            }
        }
    }
}
```

For a comprehensive guide to using Shank with Snitch, see the [Using Shank with Snitch](/tutorials/UsingShank.md) guide.

### Database Integration
Snitch is an HTTP focused tool, and as such it abstains from offering solutions to non-HTTP problems such as deeply integrating with databases. We believe it is better to leave that job to specialized tools such as Jooq or Exposed. That said what snitch does offer is an extremely easy way of integrating with such tools. For example, here's how simple it is to declare that endpoints within a given hierarchy should all execute the code within an `Exposed` transaction:

```kotlin
withTransaction {
    POST() with body<CreateUserRequest>() isHandledBy createUser
    POST("login") with body<LoginRequest>() isHandledBy userLogin

    userId / "posts" / {
        authenticated {
            GET() onlyIf principalEquals(userId) isHandledBy getPosts
            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost

            GET(postId) isHandledBy getPost
            PUT(postId) with body<UpdatePostRequest>() onlyIf principalEquals(userId) isHandledBy updatePost
            DELETE(postId) onlyif (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
        }
    }
}
```

here's how withtransaction is implemented:
```kotlin
// transaction {} from Exposed framework
val Router.withTransaction get() = decorateWith { transaction { next() } }
```
The ease with which this feature can be implemented is a testament to the power and flexibility of middleware. This can also be done in a granular way, by endpoint:
```kotlin
GET() decorated withExposedTransaction onlyIf principalEquals(userId) isHandledBy getPosts
```
and this is the declaration of this decoration, which can be reused across different endpoints:
```kotlin
val withExposedTransaction = decoration { transaction { next() } }
```
this code hardly needs any explanation, in the spirit of Snitch philosophy. 

the transaction example was just one way of showing how the flexibility and power of the dsl makes it extremely convenient to integrate with purpose built tools for database and other purposes. Snitch focuses on HTTP, but it seamlessly integrates with other tools with other focuses.

### Guards
Still on top of the same underlying mechanism we've built a powerful and granular guard mechanism, here's an example of it at work:

```kotlin
val requestWrapper.role: Role get() = (request[accessToken] as Authentication.Authenticated).claims.role

val hasAdminRole = condition {
    when (role) {
        ADMIN -> Successful()
        else -> Failed(FORBIDDEN())
    }
}
```
and this is how it's used
```kotlin
DELETE(postId) onlyIf hasAdminRole isHandledBy deletePost
```

`onlIf` takes a condition which can be either `Successful` or `Failed` and will either proceed with the request or terminate early accordingly.

This offers a high degree of granularity when specifying access control as applied to individual routes.

#### Composing conditions
Conditions are composable and support basic boolean logic operations:

```kotlin
DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost
```

The code above hardly needs an explanation for what it's doing, despite the fact that it's not trivial behaviour.

here's the definition of `principalEquals`:
```kotlin
fun principalEquals(param: Parameter<out Any, *>) = condition {
    if (principal.value == request[param]) Successful()
    else Failed(FORBIDDEN())
}

val RequestWrapper.principal: UserId get() = (request[accessToken] as Authentication.Authenticated).claims.userId
```

#### Reusing conditions
Although it's possible to customize each and every endpoint to lock it down to the exact security guarantees your business logic needs to enforce, it's often the case that you need to share the same guard logic across several endpoints. Snitch offers two ways of doing this, the first one is obvious:

```kotlin
val ownerOrAdmin = principalEquals(userId) or hasAdminRole

DELETE(postId) onlyIf ownerOrAdmin isHandledBy deletePost
```

The second one is even more generic, as it can be applied to an entire sub-hierarchy of routes. It works similarly to how middleware does:

```kotlin
onlyIf(principalEquals(userId) or hasAdminRole) {
    ...
    DELETE(postId) isHandledBy deletePost
    PATCH(postId) with body<UpdatePostRequest>() isHandledBy updatePost
    ...
}
```

Note that this approach to Guards is in line with what we call "Snitch's way" or "Snitchy". Of course good old imperative checks inside the handler are still possible and supported, and in some cases that's the best thing to do. But sticking to Snitch's way allows for more consistent, readable and manageable codebases at any scale.

### Error handling
Although Snitch encourages a more functional approach to errors, it also supports global exception handling for both unexpected behaviour and for flow control.

```kotlin
snitch(GsonJsonParser)
    .onRoutes(root)
    .handleException(MyException::class) { exception ->
        MyCustomErroResponse(exception.reason)
            .also { logger().error(it.toString()) }
            .badRequest()
    }
    .start()
```

Note that the body of the exception handler works like the normal handlers', with the only difference that it has a referfence to the exception being handled, thie `it` of the lambda, which can be optionally named as in the example above. Note that it's not necessary to return an error response, it's possible to return an alternative successful response instead. You can see that there is a lot of functionality packed in a small amount of code, yet it still remains fairly intuitive and readable.

#### Polymorphic error handling
Note that error handling is polymorphic, so if `MyException` extends `MyBaseException` `.handleException(MyBaseException::class)...` would handle `MyException` as well as any other subclass of `MyBaseException`. For this reason, ordering of the declaration of exception handlers matters. You should always put the most specific handlers first, otherwise a more generic polymorphic handler would handle the exception instead. Note that this feature implementation relies on some reflection, and while it's relatively efficient, it's not as efficient as a more functional approach. For that reason this should not be used as a main flow control mechanism for performance critical applications.

### Testing
Snitch supports a fluent and concise integration testing DSL. In accordance with the rest of the library, it is designed with simplicity, intuitiveness and readability in mind. The expressiveness and simplicity is aimed at encouraging a TDD approach. Here is what simple tests would look like, including an example of the base class and application object:
```kotlin
class HealthTest : BaseTest() {
    @Test
    fun `foo does bar`() {
        GET("/foo/bar")
            .expectCode(200)
            .expectBody("""{"status": "ok"}""")
    }
    
    @Test
    fun `post`() {
        POST("/foo/bar")
            .withBody(myRequestBody)
            .expectCode(200)
            .expectBody("""{"status": "ok"}""")
    }
}

@TestInstance(Testinstance.Lifecycle.PER_CLASS)
abstract class BaseTest : SnitchTest({ Application.setup(it) }) {
    @BeforeAll
    fun beforeAll() = super.before()

    @AfterAll
    fun afterAll() = super.after()
}

object Application {
    fun setup(port: Int): RoutedService =
        snitch(GsonJsonParser, snitchConfig(Service(port = port)))
            .onRoutes(rootRouter)
            .handleExceptions()
}
```
please refer to the `example` module in the repository source code for more in-depth examples involving real-world use cases complete with database setup and access, dependency injection and more.

### Intellij integration
Snitch has the best in class IntelliJ integration plugin and it ships by default with the IDE: Jetbrain's Kotlin plugin. that's all that's needed to unleash the full power of snitch and have autocompletion, syntax higlighting and so on. because snitch aims at being plain kotlin only, without reflection or annotation processing or code generation, the kotlin compiler is fully capable of understanding each aspect of the library and its uses. Snitch usage errors are more often than not resolved at compile time. One of the leading design principles of Snitch is that the user of the library should always be able to use the IDE to navigate to middleware definitions, follow the nesting of routes upsream and downstream, and so on. A user should never be in the position of not knowing what some code does. They might not necessarily understand every aspect of how the internals work, but they should at the very least be able to see the internals, and explore them with their IDE. The pure kotlin approach makes this easy.

### Showcase

#### DSL extension usecase: API versioning

It is often the case that your API will need versioning for backwards compatibility with deployed clients. There are several approaches to versioning. A common and annoying problem is handling relatively minor version differences on only a subset of endpoints. Setting up a whole separate path hierarchy may be an overkill in such cases. E.g you want to have these routes:

```
GET /v1/hey/there/foo
GET /v2/hey/there/foo
GET /v1/hey/all/bar
```

This is how easy it is to extend Snitch's DSL to support this type of versioning:

```kotlin
val baseVersion = "v1"

baseVersion / {
    "hey" / {
        "there" / {
            GET("foo") isHandledBy { "this is foo v1".ok }
            GET("foo").v2 isHandledBy { "this is foo v2".ok }
        }
        "all" / {
            GET("bar") isHandledBy { "this is bar v1".ok }
        }
    }
}

// demo only, use a more robust path editing logic for production
val <T : Any> Endpoint<T>.v2 get() = copy(path = path.replace("/$baseVersion/", "/v2/"))
```

And that's it. Endpoints are data classes and can be customized like any other data class in Kotlin.  

This style is also supported, if you prefer:
```kotlin
GET("foo") v 2 isHandledBy { "this is foo v2".ok }
```
This uses an extension function instead of an extension property.
```
// demo only, use a more robust path editing logic for production
infix fun <T: Any> Endpoint<T>.v(version: Int) = copy(
    path = path.replace("/$baseVersion/", "/v$version/")
)
```

### Coroutine support
Snitch is asynchronous by default, and as such it works well with coroutines. You can use your suspend functions just like normal code, just use a `coHandling` or `isCoHandledBy`. 

```kotlin
val getUsers by coHandling {
    usersRepository().getUsersAsync().ok
}

GET("users") isHandledBy getUsers
GET("posts") isCoHandledBy { postsRepository().getPostsAsync().ok }
```

Coroutine support are not included by default, so you need to add this to your gradle build file:
```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-coroutines:1.0.0")
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = freeCompilerArgs + "-Xcontext-receivers"
    }
}
```
Depending on usage patterns we might include coroutines as part of the main API and thus remove the need for the `coHandling` and `isCoHandledBy` functions and extra gradle code.

### FAQ
#### How does Snitch handle concurrency?
Snitch is a thin layer on top of the underlying HTTP server. By default, that's Undertow, so Snitch will handle concurrency in the samw way Undertow does.
#### Just how "light" and "fast" is Snitch?
Snitch is a small library with very little overhead on top of the HTTP server. By default that's Undertow, and multiple benchmarks have put Undertow consistently in the top 3 servers in the JVM for years. Undertow is also one of the lightest embedded HTTP servers. In short, Snitch is in practice as fast and as lightweight as Undertow is.
#### How does the automatic OpenApi 3 documentation generation work?
Snitch uses information from the type system to know everything there is to know about an endpoint and its inputs and outputs. 
#### Why is Snitch typesafe?
Snitch enforces explicit declarations on any inputs and outputs for each endpoint, and these declarations include type information. This way when the inputs are used inside the handlers, they are already verified and transformed, and any unexpected inputs automatically and consistently dealt with.
#### How does Snitch handle HTTP sessions and cookies? 
It doesn't and it won't. Snitch is designed for highly scalable stateless applications. Session management, caching and any other stateful solution, can and should be implemented at the infrastructure layer.
#### Does Snitch support X database integration?
Yes it does as long as X has a Java api. The middleware system's flexibility makes it easy to add support for X. No Snitch does not ship with X support by default because your needs are most likely than not unique and you'd rather have an easy way of doing it your way than a default that won't suit you.
#### How does Snitch handle scalability? 
Snitch is a low overhead, fast execution framework. It is stateless by default, and it's designed for deployment in clusters. Snitch once containerized and deployed in Kubernetes, ECS or analogous clusters will scale to fit any requirement. Most likely your limiting factor will be your database system.
#### How does Snitch handle security, particularly in terms of input validation?
Snitch offers both Validators, Guards and Middleware as powerful tools to implement granular and effective security. Used in combination, these features will greatly enhance the security of your endpoints. Refer to the documentation to learn how to use these features. Do keep in mind security is a multi-layer issue, so do not rely exclusively on application layer security for your critical use cases.
#### How does Snitch compare to other Kotlin web frameworks like Ktor or Spring Boot in terms of performance and ease of use?
Snitch was developed keeping a variety of other frameworks in mind, shamelessly taking inspiration from them. As such it is aimed at improving the development experience over those frameworks too. In the case of Spring, we believe that framework is overly complicated for most use cases. The "convention over configuration" approach most often than not shifts the burden from the explicit, to the implicit, greatly aggravating cognitive load. KTor is somewhat better in that regard, but we believe it does not go far enough and does not exploit Kotlin's full potential, despite its pedigree. Snitch is aimed at being the most powerful simple tool you can use while retaining excellent readability qualities and a minimal API.

---

## From: DatabaseIntegration.md

# Database Integration Tutorial

This tutorial walks you through setting up a simple Snitch application with database integration using the Exposed modules. You'll learn how to connect to a database, define tables, implement CRUD operations, and handle transactions.

## Prerequisites

- Basic knowledge of Kotlin and Snitch
- Gradle or Maven build system
- JDK 11 or higher

## Setup

Add the required dependencies to your `build.gradle.kts`:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-core:$snitchVersion")
    implementation("io.github.memoizr:snitch-exposed:$snitchVersion")
    
    // Choose one (or both) of these database modules
    implementation("io.github.memoizr:snitch-exposed-h2:$snitchVersion")      // For development/testing
    implementation("io.github.memoizr:snitch-exposed-postgres:$snitchVersion") // For production
}
```

## Step 1: Configure Database Connection

Let's start by setting up a database connection. We'll use H2 for development:

```kotlin
import snitch.exposed.h2.h2ConnectionConfig
import snitch.exposed.ExposedModule
import org.jetbrains.exposed.sql.transactions.transaction
import org.jetbrains.exposed.sql.SchemaUtils

// Create an in-memory H2 database
val config = h2ConnectionConfig()
ExposedModule.connection(config)

// Initialize schema
transaction {
    // We'll define tables in the next step
}
```

For a production PostgreSQL setup, you would use:

```kotlin
import snitch.exposed.postgres.postgresConnectionConfig

val prodConfig = postgresConnectionConfig(
    host = "localhost",
    database = "myapp",
    user = "dbuser",
    password = "dbpassword"
)
ExposedModule.connection(prodConfig)
```

## Step 2: Define Domain Models and Tables

Now, let's define our domain models and database tables:

```kotlin
import org.jetbrains.exposed.sql.Table
import org.jetbrains.exposed.sql.javatime.datetime
import java.time.LocalDateTime

// Domain models
data class Task(
    val title: String,
    val description: String,
    val completed: Boolean = false,
    val dueDate: LocalDateTime? = null
)

data class TaskWithId(
    val id: Int,
    val title: String,
    val description: String,
    val completed: Boolean = false,
    val dueDate: LocalDateTime? = null
)

// Database table
object Tasks : Table("tasks") {
    val id = integer("id").autoIncrement()
    val title = varchar("title", 255)
    val description = text("description")
    val completed = bool("completed").default(false)
    val dueDate = datetime("due_date").nullable()
    
    override val primaryKey = PrimaryKey(id)
}

// Initialize the schema
transaction {
    SchemaUtils.create(Tasks)
}
```

## Step 3: Implement CRUD Operations

Let's implement basic CRUD operations for our tasks:

```kotlin
import snitch.exposed.*
import org.jetbrains.exposed.sql.transactions.transaction
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq

class TaskRepository {
    // Create a new task
    fun createTask(task: Task): Int = transaction {
        Tasks.insert(task)[Tasks.id]
    }
    
    // Get all tasks
    fun getAllTasks(): List<TaskWithId> = transaction {
        Tasks.findAll<TaskWithId>()
    }
    
    // Get a task by ID
    fun getTaskById(id: Int): TaskWithId? = transaction {
        Tasks.findOneOrNull<TaskWithId> { Tasks.id eq id }
    }
    
    // Update a task
    fun updateTask(task: TaskWithId): Boolean = transaction {
        val updated = Tasks.updateWhere(task) { Tasks.id eq task.id }
        updated > 0
    }
    
    // Delete a task
    fun deleteTask(id: Int): Boolean = transaction {
        val deleted = Tasks.deleteWhere { Tasks.id eq id }
        deleted > 0
    }
    
    // Get completed tasks
    fun getCompletedTasks(): List<TaskWithId> = transaction {
        Tasks.findAll<TaskWithId> { Tasks.completed eq true }
    }
}
```

## Step 4: Integrate with Snitch Routes

Now let's create endpoints to interact with our tasks:

```kotlin
import snitch.router.routes
import snitch.parameters.path
import snitch.validation.ofInt
import snitch.exposed.withTransaction

val taskRepository = TaskRepository()
val id by path(ofInt)

val taskRoutes = routes {
    // Wrap all routes in a transaction
    withTransaction {
        // Get all tasks
        GET("tasks") isHandledBy {
            taskRepository.getAllTasks().ok
        }
        
        // Get a specific task
        GET("tasks" / id) isHandledBy {
            val taskId = request[id]
            val task = taskRepository.getTaskById(taskId)
            task?.ok ?: "Task not found".notFound()
        }
        
        // Create a new task
        POST("tasks") with body<Task>() isHandledBy {
            val task = body
            val newTaskId = taskRepository.createTask(task)
            val createdTask = taskRepository.getTaskById(newTaskId)
            createdTask!!.created
        }
        
        // Update a task
        PUT("tasks" / id) with body<Task>() isHandledBy {
            val taskId = request[id]
            val updatedTask = TaskWithId(
                id = taskId,
                title = body.title,
                description = body.description,
                completed = body.completed,
                dueDate = body.dueDate
            )
            
            val success = taskRepository.updateTask(updatedTask)
            if (success) {
                val task = taskRepository.getTaskById(taskId)
                task!!.ok
            } else {
                "Task not found".notFound()
            }
        }
        
        // Delete a task
        DELETE("tasks" / id) isHandledBy {
            val taskId = request[id]
            val deleted = taskRepository.deleteTask(taskId)
            if (deleted) {
                "Task deleted".ok
            } else {
                "Task not found".notFound()
            }
        }
        
        // Get completed tasks
        GET("tasks/completed") isHandledBy {
            taskRepository.getCompletedTasks().ok
        }
    }
}
```

## Step 5: Start the Application

Finally, let's set up the main application class:

```kotlin
import snitch.undertow.UndertowSnitchService
import snitch.parsers.GsonJsonParser
import snitch.config.SnitchConfig

fun main() {
    // Set up the database
    val config = h2ConnectionConfig()
    ExposedModule.connection(config)
    
    // Initialize schema
    transaction {
        SchemaUtils.create(Tasks)
    }
    
    // Create and start the server
    val service = UndertowSnitchService(
        GsonJsonParser,
        SnitchConfig(
            SnitchConfig.Service(
                port = 8080
            )
        )
    )
    
    service.onRoutes(taskRoutes).start()
    println("Server started on http://localhost:8080")
}
```

## Step 6: Test Your Application

You can now run your application and test the endpoints:

1. Create a task:
```bash
curl -X POST http://localhost:8080/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Snitch Exposed","description":"Complete the database tutorial","completed":false}'
```

2. Get all tasks:
```bash
curl http://localhost:8080/tasks
```

3. Get a specific task:
```bash
curl http://localhost:8080/tasks/1
```

4. Update a task:
```bash
curl -X PUT http://localhost:8080/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Snitch Exposed","description":"Completed the database tutorial","completed":true}'
```

5. Delete a task:
```bash
curl -X DELETE http://localhost:8080/tasks/1
```

## Advanced Features

Let's explore some advanced features of Snitch Exposed.

### Working with Value Classes

```kotlin
// Define a value class for stronger typing
@JvmInline
value class TaskId(val value: Int)

// Domain model using the value class
data class TaskWithValueId(
    val id: TaskId,
    val title: String,
    val description: String,
    val completed: Boolean = false,
    val dueDate: LocalDateTime? = null
)

// Using the value class in our repository
fun getTaskById(id: Int): TaskWithValueId? = transaction {
    Tasks.findOneOrNull<TaskWithValueId> { Tasks.id eq id }
}

// The mapping between Int and TaskId happens automatically
```

### Custom Type Mapping

```kotlin
// Let's say we want to store task status as a string in the database
// but use an enum in our domain model
enum class TaskStatus { TODO, IN_PROGRESS, DONE }

// Define custom mapping
AutoMapper.customMapping<String, TaskStatus>(
    from = { str -> TaskStatus.valueOf(str) },
    to = { status -> status.name }
)

// Now we can use TaskStatus directly in our domain model
data class TaskWithStatus(
    val id: Int,
    val title: String,
    val description: String,
    val status: TaskStatus
)

// And have it automatically mapped to/from String in the database
object TasksWithStatus : Table("tasks_with_status") {
    val id = integer("id").autoIncrement()
    val title = varchar("title", 255)
    val description = text("description")
    val status = varchar("status", 20)
    
    override val primaryKey = PrimaryKey(id)
}
```

### Batch Operations

For better performance when working with multiple entities:

```kotlin
fun createTasks(tasks: List<Task>): List<Int> = transaction {
    Tasks.batchInsert(tasks) { task ->
        this[Tasks.title] = task.title
        this[Tasks.description] = task.description
        this[Tasks.completed] = task.completed
        this[Tasks.dueDate] = task.dueDate
    }.map { it[Tasks.id] }
}
```

### Working with Relationships

Let's add a related entity to our tasks:

```kotlin
// Domain models
data class Tag(val name: String)
data class TagWithId(val id: Int, val name: String)
data class TaskWithTags(
    val id: Int,
    val title: String,
    val description: String,
    val completed: Boolean,
    val dueDate: LocalDateTime?,
    val tags: List<TagWithId>
)

// Database tables
object Tags : Table("tags") {
    val id = integer("id").autoIncrement()
    val name = varchar("name", 100).uniqueIndex()
    
    override val primaryKey = PrimaryKey(id)
}

object TaskTags : Table("task_tags") {
    val taskId = integer("task_id") references Tasks.id
    val tagId = integer("tag_id") references Tags.id
    
    override val primaryKey = PrimaryKey(taskId, tagId)
}

// Repository methods for handling relationships
fun getTaskWithTags(taskId: Int): TaskWithTags? = transaction {
    val task = Tasks.findOneOrNull<TaskWithId> { Tasks.id eq taskId } ?: return@transaction null
    
    val tags = (TaskTags innerJoin Tags)
        .select { TaskTags.taskId eq taskId }
        .map { TagWithId(it[Tags.id], it[Tags.name]) }
    
    TaskWithTags(
        id = task.id,
        title = task.title,
        description = task.description,
        completed = task.completed,
        dueDate = task.dueDate,
        tags = tags
    )
}

fun addTagToTask(taskId: Int, tagId: Int) = transaction {
    TaskTags.insert {
        it[TaskTags.taskId] = taskId
        it[TaskTags.tagId] = tagId
    }
}
```

## Best Practices

1. **Separate concerns**: Place database-related code in repositories, keeping your routes clean.

2. **Use transactions appropriately**: Wrap related operations in transactions for data consistency.

3. **Error handling**: Implement proper exception handling:

```kotlin
withTransaction {
    POST("tasks") with body<Task>() isHandledBy {
        try {
            val task = body
            val id = taskRepository.createTask(task)
            TaskResponse(id, task.title).created
        } catch (e: Exception) {
            logger.error("Error creating task", e)
            "Failed to create task: ${e.message}".serverError()
        }
    }
}
```

4. **Testing**: Use H2 in-memory databases for testing:

```kotlin
@BeforeEach
fun setup() {
    // Create a fresh in-memory database for each test
    val config = h2ConnectionConfig(name = "test_${UUID.randomUUID()}")
    ExposedModule.connection(config)
    
    transaction {
        SchemaUtils.create(Tasks, Tags, TaskTags)
    }
}
```

5. **Managing connections**:
   - For development and testing, H2 in-memory is convenient
   - For production, use PostgreSQL with connection pooling
   - Always handle database connection lifecycle properly

## Conclusion

You now have a fully functional Snitch application with database integration. The Exposed modules provide a type-safe way to work with databases while eliminating much of the boilerplate typically required for database operations.

For more advanced uses, refer to:
- [Database Integration Guide](../resources/Database-Integration.md)
- [Exposed documentation](https://github.com/JetBrains/Exposed/wiki)
- [Example projects in the Snitch repository](https://github.com/memoizr/snitch/tree/master/example)

---

## From: HandlingParameters.md

# Handling Parameters in Snitch

This tutorial covers how to define, access, and validate different types of parameters in Snitch applications. Parameters are a crucial part of building APIs as they allow your endpoints to receive and process various kinds of input data.

## Parameter Types

Snitch supports several types of parameters:

1. **Path Parameters**: Variables embedded in the URL path
2. **Query Parameters**: Key-value pairs in the URL query string
3. **Header Parameters**: HTTP request headers
4. **Body Parameters**: Data in the request body (typically JSON)

Let's explore how to use each type of parameter in your Snitch applications.

## Defining Parameters

Parameters in Snitch are defined using property delegates, making them type-safe and easy to use. 

### Path Parameters

Path parameters are defined using the `path()` delegate and are embedded directly in the URL path:

```kotlin
// Define a path parameter
val userId by path(ofInt, description = "User ID")

// Use it in a route
GET("users" / userId) isHandledBy { 
    // Handler code
}
```

The `ofInt` parameter is a validator that ensures the parameter can be parsed as an integer.

### Query Parameters

Query parameters are defined using the `query()` delegate:

```kotlin
// Define a query parameter
val page by query(ofInt, description = "Page number")
val limit by optionalQuery(ofInt, default = 10, description = "Items per page")

// Use it in a route
GET("users") withQuery page isHandledBy {
    // Handler code
}
```

### Header Parameters

Header parameters are defined using the `header()` delegate:

```kotlin
// Define a header parameter
val authorization by header(description = "Authorization token")

// Use it in a route
GET("secured") withHeader authorization isHandledBy {
    // Handler code
}
```

### Body Parameters

Body parameters are defined directly in the route definition:

```kotlin
// Define a route with a body parameter
POST("users") with body<CreateUserRequest>() isHandledBy {
    // Handler code
}
```

## Accessing Parameters in Handlers

Once parameters are defined, you can access them in your handlers using the request object.

### Path Parameters

Access path parameters using indexed syntax:

```kotlin
val userId by path(ofInt)

val getUser by handling {
    val id = request[userId]
    userService.getUser(id)?.ok ?: "User not found".notFound()
}
```

### Query Parameters

Query parameters are accessed the same way:

```kotlin
val page by query(ofInt)
val limit by optionalQuery(ofInt, default = 10)

val listUsers by handling {
    val pageNum = request[page]
    val pageSize = request[limit]
    userService.getUsers(pageNum, pageSize).ok
}
```

### Header Parameters

Headers are accessed using the same syntax:

```kotlin
val authorization by header()

val securedEndpoint by handling {
    val authHeader = request[authorization]
    if (isValidToken(authHeader)) {
        "Authenticated".ok
    } else {
        "Unauthorized".unauthorized()
    }
}
```

### Body Parameters

Body parameters are accessed using the `body` property:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    val name = body.name
    val email = body.email
    userService.createUser(name, email)
    "User created".created
}
```

## Optional vs Required Parameters

By default, parameters defined with `path()`, `query()`, and `header()` are required. If a required parameter is missing or invalid, Snitch automatically returns a 400 Bad Request response.

For optional parameters, use the `optionalPath()`, `optionalQuery()`, and `optionalHeader()` delegates:

```kotlin
// Required parameter
val userId by path(ofInt)

// Optional parameter with default value
val page by optionalQuery(ofInt, default = 1)

// Optional parameter without default (will be null if missing)
val filter by optionalQuery()
```

When accessing optional parameters without defaults, check for null values:

```kotlin
val listUsers by handling {
    val filterValue = request[filter]
    val users = if (filterValue != null) {
        userService.getUsersWithFilter(filterValue)
    } else {
        userService.getAllUsers()
    }
    users.ok
}
```

## Parameter Validation

Snitch provides built-in validators for common parameter types:

- `ofInt`: Validates that the parameter is an integer
- `ofLong`: Validates that the parameter is a long integer
- `ofDouble`: Validates that the parameter is a double
- `ofBoolean`: Validates that the parameter is a boolean
- `ofNonNegativeInt`: Validates that the parameter is a non-negative integer
- `ofEmail`: Validates that the parameter is a valid email address
- `matches(regex)`: Validates that the parameter matches a regular expression

You can also create custom validators:

```kotlin
// Custom validator for UUIDs
val ofUUID = validator { input ->
    try {
        UUID.fromString(input)
        input
    } catch (e: IllegalArgumentException) {
        throw InvalidParameterException("Invalid UUID format")
    }
}

// Use the custom validator
val orderId by path(ofUUID, description = "Order ID in UUID format")
```

## Real-World Example

Here's a more complete example showing different parameter types in action:

```kotlin
// Parameter definitions
val userId by path(ofInt, description = "User ID")
val page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")
val limit by optionalQuery(ofNonNegativeInt, default = 10, description = "Items per page")
val authorization by header(description = "Bearer token")

// Route definitions
val routes = routes {
    // Get user by ID
    GET("users" / userId) isHandledBy {
        val id = request[userId]
        userService.getUser(id)?.ok ?: "User not found".notFound()
    }
    
    // List users with pagination
    GET("users") withQuery page withQuery limit isHandledBy {
        val pageNum = request[page]
        val pageSize = request[limit]
        userService.getUsers(pageNum, pageSize).ok
    }
    
    // Create user with request body
    POST("users") with body<CreateUserRequest>() isHandledBy {
        val newUser = userService.createUser(body.name, body.email)
        newUser.created
    }
    
    // Secured endpoint with authorization header
    GET("secured") withHeader authorization isHandledBy {
        val token = request[authorization]
        if (isValidToken(token)) {
            "Authenticated".ok
        } else {
            "Unauthorized".unauthorized()
        }
    }
}
```

## Advanced Parameter Handling

### Organizing Parameters

For better organization, you can group related parameters in objects:

```kotlin
object Paths {
    val userId by path(ofInt)
    val postId by path(ofInt)
}

object Queries {
    val page by optionalQuery(ofNonNegativeInt, default = 1)
    val limit by optionalQuery(ofNonNegativeInt, default = 10)
}

object Headers {
    val authorization by header()
}

// Using organized parameters
GET("users" / Paths.userId / "posts" / Paths.postId) isHandledBy {
    val userId = request[Paths.userId]
    val postId = request[Paths.postId]
    // ...
}
```

### Parameter Conditions

You can add conditions to parameters that must be satisfied:

```kotlin
// Define a condition for token validation
val validToken = condition<String> { token ->
    jwtService.validateToken(token)
}

// Apply the condition to a parameter
val accessToken by header(
    condition = validToken,
    name = "X-Access-Token",
    description = "Valid access token"
)
```

### Custom Parameter Processing

For complex parameter processing, you can use the `parsing` handler:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // Validate and transform the request body
    val sanitizedName = sanitizeInput(body.name)
    val normalizedEmail = normalizeEmail(body.email)
    
    // Use the processed parameters
    userService.createUser(sanitizedName, normalizedEmail)
    "User created".created
}
```

## Best Practices

1. **Use Descriptive Names**: Choose parameter names that clearly indicate their purpose.

2. **Add Descriptions**: Include descriptions for all parameters to improve API documentation.

3. **Validate Inputs**: Use appropriate validators to ensure parameters meet your requirements.

4. **Handle Errors Gracefully**: Provide meaningful error messages when parameter validation fails.

5. **Group Related Parameters**: Organize parameters into logical groups for better code organization.

6. **Use Appropriate Parameter Types**: Choose the right parameter type (path, query, header, body) based on your API design.

7. **Make Parameters Optional When Appropriate**: Don't require parameters that aren't strictly necessary.

8. **Set Sensible Defaults**: Provide meaningful default values for optional parameters.

## Conclusion

Snitch's parameter handling system provides a type-safe, declarative way to define and validate request parameters. By using the right parameter types and validation rules, you can create robust APIs that gracefully handle various input scenarios.

For more information on parameter handling, refer to the [Snitch API reference](/api/parameters) and check out the example project for real-world usage patterns.

---

## From: PropertyBasedTesting.md

# Property-Based Testing with Kofix

This tutorial introduces property-based testing in Snitch applications using the Kofix library. You'll learn how to use Kofix to generate test data, write more robust tests, and reduce test boilerplate.

## What is Property-Based Testing?

Property-based testing is an approach where instead of writing tests with specific input values, you define properties that should hold true for all possible inputs. The testing framework then generates random inputs to verify these properties.

This approach has several advantages:
- Discovers edge cases you might not think of
- Reduces test maintenance as requirements change
- Provides better test coverage with less code
- Helps identify subtle bugs that appear only with specific inputs

## Getting Started with Kofix

### Installation

First, add the Kofix dependency to your project:

```kotlin
dependencies {
    testImplementation("io.github.memoizr:snitch-kofix:1.0.0")
}
```

### Creating Your First Property-Based Test

Let's start with a simple example - testing a user registration service:

```kotlin
class UserServiceTest {
    // Create random test data using property delegation
    val user by aRandom<User>()
    val email by aRandom<Email>()
    
    @Test
    fun `registered users can be retrieved by email`() {
        // Act
        userService.register(user)
        
        // Assert
        val retrievedUser = userService.findByEmail(user.email)
        assertEquals(user.id, retrievedUser?.id)
        assertEquals(user.name, retrievedUser?.name)
    }
}
```

In this example, Kofix automatically generates random `User` objects with all required properties filled with sensible random values.

## Core Concepts

### Random Object Generation

Kofix can generate random instances of any class:

```kotlin
// Simple types
val randomString by aRandom<String>()
val randomInt by aRandom<Int>()
val randomInstant by aRandom<Instant>()

// Domain objects
val user by aRandom<User>()
val product by aRandom<Product>()

// Even complex generic types
val listOfMaps by aRandom<List<Map<String, User>>>()
```

### Customizing Generated Objects

Often you need to customize the generated objects for specific test scenarios:

```kotlin
// Customize individual instances
val activeUser by aRandom<User> { 
    copy(status = UserStatus.ACTIVE, verifiedEmail = true) 
}

// Customize with dependencies between objects
val order by aRandom<Order>()
val orderItem by aRandom<OrderItem> {
    copy(orderId = order.id)
}
```

### Collections of Random Objects

For testing with collections:

```kotlin
// Random lists with default size (1-10 elements)
val users by aRandomListOf<User>() 

// Fixed size
val fiveProducts by aRandomListOf<Product>(size = 5)

// Size range
val orders by aRandomListOf<Order>(minSize = 2, maxSize = 10)

// Customized lists
val activeUsers by aRandomListOf<User> {
    map { it.copy(status = UserStatus.ACTIVE) }
}
```

## Integration with Snitch Tests

Kofix is particularly powerful when combined with Snitch's testing framework. Let's see how to use it in API tests:

```kotlin
class UserApiTest : SnitchTest({ Application.setup(it) }) {
    // Test data
    val user by aRandom<User>()
    val createUserRequest by aRandom<CreateUserRequest>()
    val updateUserRequest by aRandom<UpdateUserRequest>()
    
    // JWT tokens for authentication
    lateinit var userToken: String
    
    @BeforeEach
    fun setup() {
        // Use the random user to create a real user in the system
        userService.createUser(user)
        userToken = jwtService.createToken(user.id)
    }
    
    @Test
    fun `authenticated users can update their profile`() {
        // Send a PUT request with random data
        PUT("/users/${user.id}")
            .withHeaders(mapOf("Authorization" to "Bearer $userToken"))
            .withBody(updateUserRequest)
            .expectCode(200)
        
        // Verify the update was applied
        GET("/users/${user.id}")
            .withHeaders(mapOf("Authorization" to "Bearer $userToken"))
            .expectCode(200)
            .expectJsonPath("$.name", updateUserRequest.name)
            .expectJsonPath("$.email", updateUserRequest.email)
    }
}
```

Here's a more complete example based on the `PostsRoutesTest` from the Snitch example project:

```kotlin
class PostsRoutesTest : BaseTest() {
    // Random data for our tests
    val createPostRequest by aRandom<CreatePostRequest>()
    val updatePostRequest by aRandom<UpdatePostRequest>()

    // Different users with different roles
    val otherUser by aRandom<User>()
    val user by aRandom<User>()
    val admin by aRandom<User> { copy(role = Role.ADMIN) }
    
    // Posts owned by different users
    val post by aRandom<Post> { 
        copy(creator = UserView(user.id, user.name), createdAt = now()) 
    }
    val postByOtherUser by aRandom<Post> { 
        copy(creator = UserView(otherUser.id, otherUser.name), createdAt = now()) 
    }

    // Authentication tokens
    lateinit var userToken: String
    lateinit var adminToken: String

    @BeforeEach
    fun setup() {
        // Setup test environment with our random users
        userToken = user.create().let { jwt().newToken(JWTClaims(user.id, Role.USER)) }
        adminToken = admin.create().let { jwt().newToken(JWTClaims(admin.id, Role.ADMIN)) }
        otherUser.create()
    }

    @Test
    fun `a logged in user can create a post then view it`() {
        // Create a post with random data
        POST("/users/${user.id.value}/posts")
            .withHeaders(mapOf("X-Access-Token" to userToken))
            .withBody(createPostRequest)
            .expectCode(201)

        // Verify we can view the created post
        GET("/users/${user.id.value}/posts")
            .withHeaders(mapOf("X-Access-Token" to userToken))
            .expectCode(200)
            .expectJsonPath("$.posts[0].title", createPostRequest.title)
            .expectJsonPath("$.posts[0].content", createPostRequest.content)
    }
    
    @Test
    fun `a user cannot post on another user's behalf`() {
        POST("/users/${otherUser.id.value}/posts")
            .withHeaders(mapOf("X-Access-Token" to userToken))
            .withBody(createPostRequest)
            .expectCode(403)
    }
}
```

## Advanced Features

### Global Type Customization

For consistent data generation across tests, customize types globally:

```kotlin
// In your BaseTest class
init {
    // Custom email format
    customize<Email> { Email("${randomString()}@example.com") }
    
    // Current timestamp for all tests
    customize<Instant> { clock.now() }
    
    // UUIDs for IDs
    customize<UserId> { UserId(UUID.randomUUID().toString()) }
}
```

The example project does this in `BaseTest.kt`:

```kotlin
abstract class BaseTest : SnitchTest({ Application.setup(it) }) {
    init {
        connection()
        customize<Email> { Email("${randomString()}@${randomString()}.com") }
    }
    
    fun randomString(n: Int = 1, m: Int = 5): String {
        val length = Random.nextInt(n, m + 1)
        val chars = ('a'..'z') + ('A'..'Z') + ('0'..'9')
        return List(length) { chars.random() }.joinToString("")
    }
    
    // ...
}
```

### Seed Control for Reproducible Tests

Control randomness with seeds for reproducible tests:

```kotlin
// Fixed seed for deterministic tests
@BeforeEach
fun setupSeed() {
    Seed.seed = 12345L // Same random values every time
}

// Test mode for consistent random values within a test
@BeforeEach
fun setupTestMode() {
    Seed.testing = true // Different between test runs but consistent within a test
}
```

### Testing with Interfaces and Abstract Classes

Kofix can even generate implementations of interfaces and abstract classes:

```kotlin
// Generates a mock implementation of the interface
val repository by aRandom<UserRepository>()

@Test
fun `test with mock repository`() {
    // The mock implementation will return random data
    val users = repository.findAllUsers()
    assertTrue(users.isNotEmpty())
}
```

## Best Practices

### 1. Combine Property-Based and Example-Based Testing

Use property-based testing for broad verification and example-based testing for specific cases:

```kotlin
@Test
fun `email validation rejects invalid formats`() {
    // Property-based: generate many random invalid emails
    repeat(100) {
        val invalidEmail = "${a<String>()}${a<String>()}"
        assertFalse(emailValidator.isValid(invalidEmail))
    }
    
    // Example-based: specific cases that must work
    assertTrue(emailValidator.isValid("user@example.com"))
    assertFalse(emailValidator.isValid("user@"))
}
```

### 2. Use Custom Generators for Domain Constraints

Create custom generators for domain-specific constraints:

```kotlin
// In your BaseTest class
init {
    // Valid product codes must follow a pattern
    customize<ProductCode> { 
        val category = listOf("HW", "SW", "SRV").random()
        val number = (1000..9999).random()
        ProductCode("$category-$number") 
    }
}
```

### 3. Structure Test Data for Readability

Structure your test data declarations for better readability:

```kotlin
class OrderTest {
    // Group related test data together
    object TestUsers {
        val customer by aRandom<User>()
        val admin by aRandom<User> { copy(role = Role.ADMIN) }
    }
    
    object TestProducts {
        val inStock by aRandom<Product> { copy(stockQuantity = 100) }
        val outOfStock by aRandom<Product> { copy(stockQuantity = 0) }
    }
    
    // Use the structured data in tests
    @Test
    fun `customers cannot order out-of-stock products`() {
        val result = orderService.placeOrder(
            TestUsers.customer, 
            TestProducts.outOfStock, 
            quantity = 1
        )
        
        assertEquals(OrderResult.OUT_OF_STOCK, result)
    }
}
```

### 4. Test Boundary Cases Explicitly

Even with property-based testing, explicitly test boundary cases:

```kotlin
@Test
fun `boundary cases are handled correctly`() {
    // Zero quantity
    val zeroQuantityOrder by aRandom<Order> { copy(quantity = 0) }
    assertFalse(orderValidator.isValid(zeroQuantityOrder))
    
    // Maximum quantity
    val maxQuantityOrder by aRandom<Order> { copy(quantity = MAX_QUANTITY) }
    assertTrue(orderValidator.isValid(maxQuantityOrder))
    
    // Quantity just above maximum
    val tooLargeOrder by aRandom<Order> { copy(quantity = MAX_QUANTITY + 1) }
    assertFalse(orderValidator.isValid(tooLargeOrder))
}
```

## Common Pitfalls and Solutions

### Slow Tests Due to Large Object Graphs

**Problem**: Tests are slow because Kofix generates large object graphs.

**Solution**: Limit collection sizes and customize complex objects:

```kotlin
// Limit collection sizes
val smallList by aRandomListOf<ComplexObject>(maxSize = 3)

// Simplify complex objects
customize<ComplexObject> {
    // Create a simplified version with only essential properties
    ComplexObject(
        id = a<Id>(),
        name = a<String>(),
        // Use empty collections instead of generating them
        references = emptyList()
    )
}
```

### Non-Deterministic Test Failures

**Problem**: Tests sometimes fail due to randomness.

**Solution**: Use seed control and properly constrain your generators:

```kotlin
@BeforeEach
fun setupSeed() {
    // When a test fails, log the seed value and use it here to reproduce
    Seed.seed = System.getProperty("test.seed")?.toLongOrNull() 
        ?: Random.nextLong().also { println("Test seed: $it") }
}
```

### Unnecessary Object Creation

**Problem**: Creating too many objects when only a few properties are needed.

**Solution**: Use domain-specific generators or customize at use:

```kotlin
// Instead of a full user with all properties
val simpleUser by aRandom<User> {
    // Keep only what you need for the test
    copy(
        email = Email("test@example.com"),
        password = null,
        profile = null,
        settings = emptyMap(),
        // Clear other complex properties
        address = null
    )
}
```

## Conclusion

Property-based testing with Kofix helps you write more robust tests with less code. By generating random but valid test data, you can discover edge cases and ensure your code works correctly across a wide range of inputs.

Kofix integrates seamlessly with Snitch's testing framework, making it easy to test your API endpoints with realistic, randomly generated data. This approach is particularly valuable for testing business logic, validation rules, and API endpoints.

---

## From: QuickStart.md

# Snitch Quick Start Guide

This guide will help you quickly set up a basic web service using Snitch.

## Installation

Add Snitch to your project dependencies:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

## Hello World Example

Create a simple "Hello World" service:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.snitch
import snitch.dsl.routes
import snitch.dsl.response.ok

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("hello") isHandledBy { "world".ok }
        }
        .start()
        .serveDocumenation()
}
```

This creates a service that:
- Responds with "world" when you make a GET request to `/hello`
- Automatically generates API documentation available at `/docs`

## Creating a RESTful API

Let's create a more realistic example with multiple endpoints:

```kotlin
import snitch.gson.GsonJsonParser
import snitch.dsl.*
import snitch.dsl.response.*

// Define our data classes
data class User(val id: String, val name: String, val email: String)
data class CreateUserRequest(val name: String, val email: String)

// In-memory storage for this example
val users = mutableMapOf<String, User>()

fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            "users" / {
                // GET /users - List all users
                GET() isHandledBy { 
                    users.values.toList().ok 
                }
                
                // POST /users - Create a new user
                POST() with body<CreateUserRequest>() isHandledBy { 
                    val id = java.util.UUID.randomUUID().toString()
                    val user = User(id, body.name, body.email)
                    users[id] = user
                    user.created
                }
                
                // GET /users/{userId} - Get a specific user
                userId / {
                    GET() isHandledBy {
                        val id = request[userId]
                        users[id]?.ok ?: "User not found".notFound()
                    }
                    
                    // DELETE /users/{userId} - Delete a user
                    DELETE() isHandledBy {
                        val id = request[userId]
                        if (users.containsKey(id)) {
                            users.remove(id)
                            "User deleted".ok
                        } else {
                            "User not found".notFound()
                        }
                    }
                }
            }
        }
        .start()
        .serveDocumenation()
}

// Define a path parameter
val userId by path()
```

## Parameter Validation

Let's enhance our API with parameter validation:

```kotlin
// Define validated parameters
val limit by query(ofNonNegativeInt(max = 30, default = 10))
val offset by query(ofNonNegativeInt(default = 0))
val email by query(ofEmail)

// Define our own custom validator
val ofEmail = stringValidator("valid email") { 
    it.contains("@") && it.contains(".") 
}

// Use in routes
"users" / {
    // GET /users?limit=10&offset=0
    GET() with listOf(limit, offset) isHandledBy {
        users.values
            .toList()
            .drop(request[offset])
            .take(request[limit])
            .ok
    }
    
    // GET /users/search?email=user@example.com
    "search" / {
        GET() with email isHandledBy {
            val searchEmail = request[email]
            users.values
                .filter { it.email == searchEmail }
                .toList()
                .ok
        }
    }
}
```

## Adding Middleware

Implement a simple logging middleware:

```kotlin
// Simple logging middleware that doesn't require parameters
val Router.log get() = decorateWith {
    println("➡️ ${request.method} ${request.path} - Request started")
    val response = next()
    println("⬅️ ${request.method} ${request.path} - Response: ${response.statusCode}")
    response
}

// Apply middleware to routes
routes {
    log {
        "users" / {
            // All user routes will be logged
            GET() isHandledBy { users.values.toList().ok }
            // ...
        }
    }
}
```

## Authentication

Implement a basic authentication system:

```kotlin
// Define the header parameter for authentication
val accessToken by header(
    condition = validAccessToken,
    name = "Authorization",
    description = "Bearer token for authentication"
)

// Validator for access token
val validAccessToken = stringValidator { token ->
    if (token.startsWith("Bearer ")) {
        val actualToken = token.substring(7)
        if (isValidToken(actualToken)) {
            Authentication.Authenticated(JWTClaims(getUserId(actualToken), getRole(actualToken)))
        } else {
            Authentication.InvalidToken
        }
    } else {
        Authentication.MissingToken
    }
}

// Authentication result model
sealed interface Authentication {
    data class Authenticated(val claims: JWTClaims) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object MissingToken : Unauthenticated
}

// Data class for JWT claims
data class JWTClaims(val userId: UserId, val role: Role)
data class UserId(val value: String)
enum class Role { USER, ADMIN }

// Authentication middleware with proper parameter declaration
val Router.authenticated get() = decorateWith(accessToken) {
    when (val auth = request[accessToken]) {
        is Authentication.Authenticated -> {
            next() // Proceed to the handler
        }
        is Authentication.Unauthenticated -> "Authentication required".unauthorized()
    }
}

// Extension properties to access authentication data
val RequestWrapper.principal: UserId get() = 
    (request[accessToken] as Authentication.Authenticated).claims.userId
val RequestWrapper.role: Role get() = 
    (request[accessToken] as Authentication.Authenticated).claims.role

// Apply to protected routes
routes {
    "public" / {
        // Public endpoints...
    }
    
    "api" / {
        authenticated {
            // Protected endpoints...
            "profile" / {
                GET() isHandledBy { 
                    getUserProfile(request.principal).ok 
                }
            }
            
            // Example of using principal in a handler
            "posts" / {
                GET() isHandledBy { 
                    getPostsByUser(request.principal).ok 
                }
                
                POST() with body<CreatePostRequest>() isHandledBy {
                    createPost(request.principal, body.title, body.content).created
                }
            }
        }
    }
}
```

## Using Conditions

Implement access control with conditions:

```kotlin
// Define conditions
val isAdmin = condition("isAdmin") {
    if (request.role == Role.ADMIN) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("Admin access required".forbidden())
    }
}

// Condition to check if the user is the owner of a resource
fun isOwner(resourceIdParam: Parameter<String, *>) = condition("isOwner") {
    val resourceId = request[resourceIdParam]
    val resource = getResourceById(resourceId)
    
    if (resource?.ownerId == request.principal.value) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("You don't have permission to access this resource".forbidden())
    }
}

// Apply conditions to endpoints
routes {
    authenticated {
        // Admin-only endpoint
        "admin" / {
            GET("dashboard") onlyIf isAdmin isHandledBy { 
                getAdminDashboard().ok 
            }
        }
        
        // User can only access their own posts
        "posts" / postId / {
            GET() onlyIf isOwner(postId) isHandledBy { getPost() }
            PUT() onlyIf isOwner(postId) with body<UpdatePostRequest>() isHandledBy { updatePost() }
            DELETE() onlyIf isOwner(postId) isHandledBy { deletePost() }
        }
    }
}
```

## Handler Functions

Snitch provides a clean way to define handler functions that can access the request context:

```kotlin
// Define a path parameter
val postId by path()

// Handler for getting a post
private val getPost by handling {
    postsRepository().getPost(PostId(request[postId]))
        ?.toResponse?.ok
        ?: "Post not found".notFound()
}

// Handler for deleting a post
private val deletePost by handling {
    postsRepository().deletePost(request.principal, PostId(request[postId]))
        .noContent
}

// Handler for getting all posts for the current user
private val getPosts by handling {
    postsRepository().getPosts(request.principal)
        .toResponse.ok
}

// Handler with request body parsing
private val createPost by parsing<CreatePostRequest>() handling {
    postsRepository().putPost(
        CreatePostAction(
            request.principal,
            PostTitle(body.title),
            PostContent(body.content),
        )
    ).mapSuccess {
        SuccessfulCreation(value).created
    }.mapFailure {
        FailedCreation().badRequest()
    }
}

// Usage in routes
routes {
    authenticated {
        "posts" / {
            GET() isHandledBy getPosts
            POST() with body<CreatePostRequest>() isHandledBy createPost
            
            postId / {
                GET() isHandledBy getPost
                DELETE() isHandledBy deletePost
            }
        }
    }
}
```

## Testing Your API

Test your endpoints with the built-in testing DSL:

```kotlin
class UserApiTest : SnitchTest({ port -> setupApp(port) }) {
    
    @Test
    fun `get all users returns 200`() {
        GET("/users")
            .expectCode(200)
            .expectBodyContains("[]") // Initially empty
    }
    
    @Test
    fun `create user returns 201`() {
        POST("/users")
            .withBody("""{"name":"John","email":"john@example.com"}""")
            .expectCode(201)
            .expectBodyContains("John")
    }
}
```

## Next Steps

Now that you have a basic understanding of Snitch, explore:

1. **Documentation Generation**: Learn how to enhance your API documentation
2. **Error Handling**: Implement global exception handlers
3. **Custom Validators**: Create complex validation rules
4. **Coroutines**: Use Kotlin coroutines for asynchronous operations

For more details, check out:
- [Snitch Documentation](../Docs.md)
- [In Depth Guides](../in%20depth/)

---

## From: README.md

# Snitch Tutorials
Welcome to the Snitch tutorials! This section contains step-by-step guides to help you master different aspects of Snitch.

## Available Tutorials

- [Quick Start Guide](QuickStart.md) - Get up and running with Snitch quickly
- [Using Shank](UsingShank.md) - Learn how to use Shank for dependency injection
- [Shank Patterns](ShankPatterns.md) - Advanced patterns for using Shank effectively
- [Shank in Action](ShankInAction.md) - Build a real-world application with Shank and Snitch


---

## From: ShankInAction.md

# Shank in Action: Building a Real-World Application

This tutorial demonstrates how to use Shank, Snitch's powerful dependency injection library, to build a maintainable and testable real-world application. We'll create a blog platform with user authentication, post management, and comments.

## What is Shank?

[Shank](https://github.com/memoizr/shank) is a lightweight, high-performance dependency injection library for Kotlin that integrates seamlessly with Snitch. It provides:

- **Industry-leading performance**: Unmatched startup and runtime performance
- **Zero reflection**: No runtime overhead or class scanning
- **Strict type safety**: Will never throw runtime exceptions related to types
- **Polymorphism support**: Interface-based dependency injection
- **Testing support**: Easy factory overriding for testing

## Project Setup

Let's start by setting up our project structure:

```kotlin
// build.gradle.kts
plugins {
    kotlin("jvm") version "1.9.0"
    application
}

dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("org.jetbrains.exposed:exposed-core:0.41.1")
    implementation("org.jetbrains.exposed:exposed-dao:0.41.1")
    implementation("org.jetbrains.exposed:exposed-jdbc:0.41.1")
    implementation("org.postgresql:postgresql:42.6.0")
    implementation("de.mkammerer:argon2-jvm:2.11")
    
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")
    testImplementation("io.mockk:mockk:1.13.5")
}
```

## Domain Model

First, let's define our domain models:

```kotlin
// src/main/kotlin/blog/domain/models.kt
package blog.domain

import java.time.Instant
import java.util.UUID

data class User(
    val id: UUID,
    val username: String,
    val email: String,
    val createdAt: Instant
)

data class Post(
    val id: UUID,
    val title: String,
    val content: String,
    val authorId: UUID,
    val createdAt: Instant,
    val updatedAt: Instant
)

data class Comment(
    val id: UUID,
    val postId: UUID,
    val authorId: UUID,
    val content: String,
    val createdAt: Instant
)
```

## Setting Up Shank Modules

Now, let's organize our application using Shank modules. This is where Shank's elegance and convenience really shine:

```kotlin
// src/main/kotlin/blog/infrastructure/ApplicationModule.kt
package blog.infrastructure

import blog.domain.Clock
import blog.domain.SystemClock
import snitch.shank.ShankModule
import snitch.shank.new
import snitch.shank.single
import java.time.Instant

object ApplicationModule : ShankModule {
    // Core application dependencies
    val clock = single<Clock> { -> SystemClock() }
    
    // Creates a new timestamp each time it's called
    val now = new { -> Instant.now(clock().utc()) }
    
    // Logger is a singleton
    val logger = single { -> LoggerFactory.getLogger("blog-app") }
}
```

Notice how we're using `single` for dependencies that should have only one instance, and `new` for dependencies that should be created fresh each time they're requested. This is one of Shank's conveniences - clear, explicit scoping.

Let's add our database module:

```kotlin
// src/main/kotlin/blog/infrastructure/DatabaseModule.kt
package blog.infrastructure

import org.jetbrains.exposed.sql.Database
import snitch.shank.ShankModule
import snitch.shank.single

object DatabaseModule : ShankModule {
    // Database connection is a singleton
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/blog",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    // Database wrapper is a singleton
    val database = single { -> PostgresDatabase(connection()) }
}
```

And our repositories:

```kotlin
// src/main/kotlin/blog/infrastructure/RepositoryModule.kt
package blog.infrastructure

import blog.domain.repositories.*
import blog.infrastructure.repositories.*
import snitch.shank.ShankModule
import snitch.shank.single

object RepositoryModule : ShankModule {
    // Bind implementations to interfaces
    val userRepository = single<UserRepository> { -> 
        PostgresUserRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
    
    val postRepository = single<PostRepository> { -> 
        PostgresPostRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
    
    val commentRepository = single<CommentRepository> { -> 
        PostgresCommentRepository(
            DatabaseModule.database(),
            ApplicationModule.now()
        ) 
    }
}
```

Finally, let's add our security module:

```kotlin
// src/main/kotlin/blog/infrastructure/SecurityModule.kt
package blog.infrastructure

import de.mkammerer.argon2.Argon2Factory
import snitch.shank.ShankModule
import snitch.shank.single
import java.security.KeyPairGenerator
import java.security.interfaces.RSAPrivateCrtKey

object SecurityModule : ShankModule {
    // Generate a key pair for JWT signing
    val keyPair = single { ->
        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")
        keyPairGenerator.initialize(2048)
        keyPairGenerator.genKeyPair()
    }

    // Extract keys from the key pair
    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }
    val publicKey = single { -> keyPair().public }
    
    // Password hashing
    val argon = single { -> Argon2Factory.create() }
    val passwordHasher = single<PasswordHasher> { -> Argon2PasswordHasher(argon()) }
    
    // JWT management
    val jwtManager = single { -> JWTManager(privateKey(), publicKey()) }
}
```

## The Power of Shank: Service Layer

Now, let's create our service layer. This is where Shank's convenience becomes evident - we can easily compose our services using dependencies from different modules:

```kotlin
// src/main/kotlin/blog/application/ServiceModule.kt
package blog.application

import blog.application.services.*
import blog.infrastructure.ApplicationModule
import blog.infrastructure.RepositoryModule
import blog.infrastructure.SecurityModule
import snitch.shank.ShankModule
import snitch.shank.single

object ServiceModule : ShankModule {
    // User service with dependencies from multiple modules
    val userService = single<UserService> { -> 
        UserServiceImpl(
            RepositoryModule.userRepository(),
            SecurityModule.passwordHasher(),
            SecurityModule.jwtManager(),
            ApplicationModule.now()
        ) 
    }
    
    // Post service
    val postService = single<PostService> { -> 
        PostServiceImpl(
            RepositoryModule.postRepository(),
            RepositoryModule.userRepository(),
            ApplicationModule.now()
        ) 
    }
    
    // Comment service
    val commentService = single<CommentService> { -> 
        CommentServiceImpl(
            RepositoryModule.commentRepository(),
            RepositoryModule.postRepository(),
            ApplicationModule.now()
        ) 
    }
}
```

## API Layer with Snitch and Shank

Now, let's create our API layer using Snitch and Shank together:

```kotlin
// src/main/kotlin/blog/api/Router.kt
package blog.api

import blog.application.ServiceModule
import blog.domain.exceptions.NotFoundException
import blog.domain.exceptions.UnauthorizedException
import snitch.dsl.*
import snitch.dsl.response.*
import snitch.parsers.GsonJsonParser
import snitch.router.decorateWith
import snitch.service.RoutedService
import snitch.undertow.snitch

// Request/response models
data class LoginRequest(val username: String, val password: String)
data class LoginResponse(val token: String)

data class CreatePostRequest(val title: String, val content: String)
data class PostResponse(val id: String, val title: String, val content: String, val author: String)

// Path parameters
val userId by path()
val postId by path()
val commentId by path()

// Header parameters for authentication
val accessToken by header(
    condition = validAccessToken,
    name = "Authorization",
    description = "Bearer token for authentication"
)

// Validator for access token
val validAccessToken = stringValidator { token ->
    if (token.startsWith("Bearer ")) {
        try {
            // Use jwtManager from SecurityModule to validate the token
            val jwtManager = SecurityModule.jwtManager()
            val userId = jwtManager.validateToken(token.substring(7))
            Authentication.Authenticated(userId)
        } catch (e: Exception) {
            Authentication.InvalidToken
        }
    } else {
        Authentication.MissingToken
    }
}

// Authentication result model
sealed interface Authentication {
    data class Authenticated(val userId: String) : Authentication
    interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object MissingToken : Unauthenticated
}

// Authentication middleware using Shank with proper parameter declaration
val authenticated = decorateWith(accessToken) {
    when (val auth = request[accessToken]) {
        is Authentication.Authenticated -> {
            // Set user ID in request attributes for use in handlers
            request.attributes["userId"] = auth.userId
            next()
        }
        is Authentication.Unauthenticated -> "Authentication required".unauthorized()
    }
}

// Main router
val router = routes {
    "api" / {
        "auth" / {
            // Login endpoint
            POST("login") with body<LoginRequest>() isHandledBy {
                val userService = ServiceModule.userService()
                try {
                    val token = userService.login(body.username, body.password)
                    LoginResponse(token).ok
                } catch (e: UnauthorizedException) {
                    "Invalid credentials".unauthorized()
                }
            }
        }
        
        "posts" / {
            // Get all posts
            GET() isHandledBy {
                val postService = ServiceModule.postService()
                postService.getAllPosts().ok
            }
            
            // Get post by ID
            postId / {
                GET() isHandledBy {
                    val postService = ServiceModule.postService()
                    try {
                        val id = request[postId]
                        postService.getPostById(id).ok
                    } catch (e: NotFoundException) {
                        "Post not found".notFound()
                    }
                }
            }
            
            // Protected routes
            authenticated {
                // Create post
                POST() with body<CreatePostRequest>() isHandledBy {
                    val postService = ServiceModule.postService()
                    val userId = request.attributes["userId"] as String
                    val post = postService.createPost(userId, body.title, body.content)
                    post.created
                }
                
                // Update post
                postId / {
                    PUT() with body<CreatePostRequest>() isHandledBy {
                        val postService = ServiceModule.postService()
                        val userId = request.attributes["userId"] as String
                        val id = request[postId]
                        try {
                            val post = postService.updatePost(id, userId, body.title, body.content)
                            post.ok
                        } catch (e: NotFoundException) {
                            "Post not found".notFound()
                        } catch (e: UnauthorizedException) {
                            "Not authorized to update this post".forbidden()
                        }
                    }
                    
                    // Delete post
                    DELETE() isHandledBy {
                        val postService = ServiceModule.postService()
                        val userId = request.attributes["userId"] as String
                        val id = request[postId]
                        try {
                            postService.deletePost(id, userId)
                            "Post deleted".ok
                        } catch (e: NotFoundException) {
                            "Post not found".notFound()
                        } catch (e: UnauthorizedException) {
                            "Not authorized to delete this post".forbidden()
                        }
                    }
                }
            }
        }
    }
}
```

## Application Entry Point

Finally, let's create our application entry point:

```kotlin
// src/main/kotlin/blog/Application.kt
package blog

import blog.api.router
import blog.infrastructure.DatabaseModule
import snitch.config.SnitchConfig
import snitch.parsers.GsonJsonParser
import snitch.undertow.snitch

fun main() {
    // Initialize database
    val database = DatabaseModule.database()
    database.createSchema()
    
    // Start the service
    snitch(GsonJsonParser, SnitchConfig(port = 3000))
        .onRoutes(router)
        .handleExceptions()
        .start()
        .serveDocumenation()
}
```

## Testing with Shank

One of Shank's most convenient features is its support for testing. Let's see how to test our service layer:

```kotlin
// src/test/kotlin/blog/application/services/UserServiceTest.kt
package blog.application.services

import blog.domain.User
import blog.domain.repositories.UserRepository
import blog.infrastructure.ApplicationModule
import blog.infrastructure.RepositoryModule
import blog.infrastructure.SecurityModule
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.time.Instant
import java.util.UUID
import kotlin.test.assertEquals

class UserServiceTest {
    private val mockUserRepository = mockk<UserRepository>()
    private val mockPasswordHasher = mockk<PasswordHasher>()
    private val mockJwtManager = mockk<JwtManager>()
    
    @BeforeEach
    fun setup() {
        // Override real implementations with mocks
        RepositoryModule.userRepository.overrideFactory { -> mockUserRepository }
        SecurityModule.passwordHasher.overrideFactory { -> mockPasswordHasher }
        SecurityModule.jwtManager.overrideFactory { -> mockJwtManager }
        
        // Set up a fixed timestamp for testing
        val fixedInstant = Instant.parse("2023-01-01T00:00:00Z")
        ApplicationModule.now.overrideFactory { -> fixedInstant }
    }
    
    @AfterEach
    fun tearDown() {
        // Restore original implementations
        RepositoryModule.userRepository.restore()
        SecurityModule.passwordHasher.restore()
        SecurityModule.jwtManager.restore()
        ApplicationModule.now.restore()
    }
    
    @Test
    fun `login should return token when credentials are valid`() {
        // Arrange
        val username = "testuser"
        val password = "password123"
        val hashedPassword = "hashed_password"
        val userId = UUID.randomUUID()
        val token = "jwt_token"
        
        val user = User(
            id = userId,
            username = username,
            email = "test@example.com",
            createdAt = Instant.now()
        )
        
        every { mockUserRepository.findByUsername(username) } returns user
        every { mockPasswordHasher.verify(hashedPassword, password) } returns true
        every { mockJwtManager.createToken(userId.toString()) } returns token
        
        // Act
        val userService = ServiceModule.userService()
        val result = userService.login(username, password)
        
        // Assert
        assertEquals(token, result)
        verify { mockUserRepository.findByUsername(username) }
        verify { mockPasswordHasher.verify(hashedPassword, password) }
        verify { mockJwtManager.createToken(userId.toString()) }
    }
}
```

## Why Shank is Convenient

As you've seen throughout this tutorial, Shank offers several conveniences that make it an excellent choice for dependency injection in Snitch applications:

1. **Explicit Dependencies**: Dependencies are clearly defined and easy to trace, making your code more maintainable.

2. **No Magic**: Unlike other DI frameworks, Shank doesn't use reflection or annotations, making it faster and more predictable.

3. **Type Safety**: Shank leverages Kotlin's type system to ensure type safety at compile time.

4. **Testability**: Shank's ability to override dependencies makes testing straightforward and reliable.

5. **Performance**: Shank's lightweight design ensures minimal overhead, making it ideal for high-performance applications.

6. **Modularity**: Shank encourages organizing your code into cohesive modules, improving code organization.

7. **Flexibility**: Shank supports various dependency scopes (singleton, factory, scoped), giving you control over object lifecycles.

## Conclusion

In this tutorial, we've built a complete blog application using Snitch and Shank. We've seen how Shank's convenient dependency injection system makes it easy to:

- Organize code into logical modules
- Manage dependencies between different parts of the application
- Test components in isolation
- Create maintainable and flexible code

Shank's simplicity and power make it an excellent choice for dependency injection in Kotlin applications, especially when combined with Snitch's elegant routing and request handling.

## Next Steps

To further explore Shank and Snitch:

1. Check out the [Shank Patterns](./ShankPatterns.md) guide for advanced usage patterns
2. Explore the [Using Shank](./UsingShank.md) guide for more details on Shank's features
3. Look at the example project in the repository for a complete working example 

---

## From: ShankPatterns.md

# Advanced Shank Design Patterns

This document explores powerful design patterns and techniques for using Shank effectively in your applications. While Shank is intuitive and straightforward by design, these patterns can help you tackle more complex scenarios with elegance and maintainability.

## Table of Contents

1. [Module Organization Strategies](#module-organization-strategies)
2. [Dependency Layering](#dependency-layering)
3. [Testing Patterns](#testing-patterns)
4. [Domain-Driven Design with Shank](#domain-driven-design-with-shank)
5. [Feature Toggling](#feature-toggling)
6. [Lifecycle Management](#lifecycle-management)
7. [Configuration Injection](#configuration-injection)
8. [Conditional Dependencies](#conditional-dependencies)

## Module Organization Strategies

### Domain Module Pattern

Organize your modules by domain context rather than technical layers:

```kotlin
// Instead of "RepositoryModule", "ServiceModule", etc.
object UserDomainModule : ShankModule {
    // Domain-specific repositories
    val userRepository = single<UserRepository> { -> UserRepositoryImpl() }
    
    // Domain-specific services
    val userService = single<UserService> { -> UserServiceImpl(userRepository()) }
    
    // Domain-specific validation
    val userValidator = single { -> UserValidator() }
}

object PaymentDomainModule : ShankModule {
    val paymentRepository = single<PaymentRepository> { -> PaymentRepositoryImpl() }
    val paymentService = single<PaymentService> { -> PaymentServiceImpl(paymentRepository()) }
    val paymentProcessor = single { -> PaymentProcessor() }
}
```

This approach aligns better with domain-driven design principles and improves cohesion, making each module more focused and self-contained.

### Feature Module Pattern

For larger applications, organize modules by features that cut across domain boundaries:

```kotlin
object AuthenticationModule : ShankModule {
    val passwordEncoder = single { -> BCryptPasswordEncoder() }
    val tokenService = single { -> JwtTokenService() }
    val authenticationService = single { -> 
        AuthenticationServiceImpl(
            UserDomainModule.userRepository(),
            passwordEncoder(),
            tokenService()
        )
    }
}

object CheckoutModule : ShankModule {
    val checkoutService = single { -> 
        CheckoutServiceImpl(
            UserDomainModule.userService(),
            PaymentDomainModule.paymentService(),
            ShippingDomainModule.shippingService()
        ) 
    }
}
```

This pattern maximizes code organization around user-facing features, making it clear which dependencies belong to which features.

## Dependency Layering

Shank allows you to create clear architectural boundaries while maintaining explicit dependency relationships:

```kotlin
// Infrastructure Layer
object InfrastructureModule : ShankModule {
    val database = single { -> PostgresDatabase(connectionString()) }
    val httpClient = single { -> OkHttpClient() }
    val cache = single { -> RedisCache(redisConfig()) }
}

// Repository Layer
object RepositoryModule : ShankModule {
    val userRepository = single<UserRepository> { -> 
        UserRepositoryImpl(InfrastructureModule.database())
    }
}

// Service Layer
object ServiceModule : ShankModule {
    val userService = single<UserService> { -> 
        UserServiceImpl(RepositoryModule.userRepository())
    }
}

// Application Layer
object ApplicationModule : ShankModule {
    val userController = single { -> 
        UserController(ServiceModule.userService())
    }
}
```

This approach enforces the dependency rule (dependencies only point inward) while maintaining Shank's explicit dependency tracing.

## Testing Patterns

### Test Double Pattern

Create specialized modules for testing that override production dependencies:

```kotlin
// Production module
object PaymentModule : ShankModule {
    val paymentGateway = single<PaymentGateway> { -> StripePaymentGateway() }
    val paymentService = single { -> PaymentServiceImpl(paymentGateway()) }
}

// Test module
object TestPaymentModule : ShankModule {
    val mockPaymentGateway = single<PaymentGateway> { -> MockPaymentGateway() }
    
    fun setupForTesting() {
        // Override the real implementation with our mock
        PaymentModule.paymentGateway.overrideFactory { -> mockPaymentGateway() }
    }
    
    fun tearDown() {
        // Restore the original implementation
        PaymentModule.paymentGateway.restore()
    }
}
```

Then in your tests:

```kotlin
class PaymentServiceTest {
    @BeforeEach
    fun setup() {
        TestPaymentModule.setupForTesting()
    }
    
    @AfterEach
    fun tearDown() {
        TestPaymentModule.tearDown()
    }
    
    @Test
    fun `test payment processing`() {
        // This will use the mock gateway
        val paymentService = PaymentModule.paymentService()
        
        // Configure the mock
        val mockGateway = TestPaymentModule.mockPaymentGateway()
        mockGateway.setupToReturnSuccessfulPayment()
        
        // Execute the test
        val result = paymentService.processPayment(100.0, "USD")
        
        // Verify the result
        assertEquals(PaymentStatus.SUCCESS, result.status)
    }
}
```

This approach provides fine-grained control over which dependencies are mocked in tests while preserving the rest of the dependency tree.

### Component Testing Pattern

For integration/component testing, create specialized test configurations:

```kotlin
object TestDatabaseModule : ShankModule {
    val inMemoryDatabase = single { -> H2Database() }
    
    fun setupTestEnvironment() {
        // Override production database with in-memory version
        InfrastructureModule.database.overrideFactory { -> inMemoryDatabase() }
    }
}

object IntegrationTestModule : ShankModule {
    val testHelper = single { -> IntegrationTestHelper() }
    
    fun prepareIntegrationTest() {
        TestDatabaseModule.setupTestEnvironment()
        // Additional test setup...
    }
}
```

## Domain-Driven Design with Shank

Shank works beautifully with Domain-Driven Design (DDD) principles:

```kotlin
// Domain layer - contains pure domain logic
object DomainModule : ShankModule {
    val userFactory = single { -> UserFactory() }
    val paymentPolicy = single { -> BusinessPaymentPolicy() }
}

// Application layer - orchestrates use cases
object ApplicationModule : ShankModule {
    val createUserUseCase = single { -> 
        CreateUserUseCase(
            DomainModule.userFactory(),
            RepositoryModule.userRepository()
        )
    }
    
    val processPaymentUseCase = single { -> 
        ProcessPaymentUseCase(
            DomainModule.paymentPolicy(),
            RepositoryModule.paymentRepository()
        )
    }
}

// Infrastructure layer - provides implementations
object InfrastructureModule : ShankModule {
    val userRepositoryImpl = single<UserRepository> { -> 
        PostgresUserRepository(DatabaseModule.database())
    }
}
```

This structure helps maintain a clean domain model while keeping infrastructure concerns separate. The domain module doesn't depend on any external modules, preserving the domain's purity.

## Feature Toggling

Implement feature toggling with Shank:

```kotlin
object FeatureToggleModule : ShankModule {
    val featureManager = single { -> FeatureManager() }
    
    // Define toggleable implementations
    val paymentProcessor = single<PaymentProcessor> { ->
        val featureManager = featureManager()
        if (featureManager.isEnabled("new-payment-processor")) {
            NewPaymentProcessor()
        } else {
            LegacyPaymentProcessor()
        }
    }
    
    // Conditionally provide implementations
    val betaFeatures = single { -> 
        val featureManager = featureManager()
        if (featureManager.isEnabled("beta-features")) {
            BetaFeaturesImpl() 
        } else {
            EmptyBetaFeatures()
        }
    }
}
```

This pattern allows you to toggle features at runtime while maintaining Shank's type safety and explicit dependency structure.

## Lifecycle Management

For dependencies that need initialization or cleanup:

```kotlin
object ResourceModule : ShankModule {
    val databaseClient = single { -> 
        DatabaseClient().also { client ->
            // Register shutdown hook
            Runtime.getRuntime().addShutdownHook(Thread {
                client.close()
            })
        }
    }
    
    // Auto-closeable resources
    val httpClient = single { -> 
        OkHttpClient().also { client ->
            registerForCleanup(client)
        }
    }
    
    // Track resources that need to be closed
    private val managedResources = mutableListOf<AutoCloseable>()
    
    private fun registerForCleanup(resource: AutoCloseable) {
        managedResources.add(resource)
    }
    
    fun closeAll() {
        managedResources.forEach { it.close() }
        managedResources.clear()
    }
}
```

To use in your application:

```kotlin
fun main() {
    try {
        // Use your application...
        val app = startApplication()
        app.waitForShutdown()
    } finally {
        ResourceModule.closeAll()
    }
}
```

## Configuration Injection

Manage configuration values through Shank modules:

```kotlin
object ConfigModule : ShankModule {
    val config = single { -> 
        ConfigFactory.load() 
    }
    
    val databaseConfig = single { -> 
        val config = config()
        DatabaseConfig(
            url = config.getString("db.url"),
            username = config.getString("db.username"),
            password = config.getString("db.password")
        )
    }
    
    val apiConfig = single { -> 
        val config = config()
        ApiConfig(
            baseUrl = config.getString("api.baseUrl"),
            timeout = config.getDuration("api.timeout")
        )
    }
}

// Usage in other modules
object DatabaseModule : ShankModule {
    val database = single { -> 
        val config = ConfigModule.databaseConfig()
        Database.connect(
            url = config.url,
            username = config.username,
            password = config.password
        )
    }
}
```

This pattern centralizes configuration while maintaining type safety.

## Conditional Dependencies

Provide different implementations based on environment or other conditions:

```kotlin
object NotificationModule : ShankModule {
    val emailSender = single<EmailSender> { ->
        when (Environment.current) {
            Environment.PRODUCTION -> SmtpEmailSender(ConfigModule.emailConfig())
            Environment.STAGING -> SmtpEmailSender(ConfigModule.emailConfig())
            Environment.DEVELOPMENT -> ConsoleEmailSender()
            Environment.TEST -> NoOpEmailSender()
        }
    }
    
    val pushNotificationService = single<PushNotificationService> { ->
        if (Environment.isProduction()) {
            FirebasePushService(ConfigModule.firebaseConfig())
        } else {
            LoggingPushService()
        }
    }
}
```

This approach provides environment-specific implementations while maintaining the same dependency interface.

## Summary

These patterns demonstrate Shank's flexibility and power in handling complex dependency scenarios while maintaining its core advantages of explicitness, type safety, and performance. By applying these patterns, you can build well-structured, maintainable applications that scale with your needs.

Shank's design philosophy emphasizes clarity and explicitness, making it not just a technical tool but a design aid that helps you think more clearly about your application's structure and dependencies.

---

## From: UsingShank.md

# Using Shank with Snitch

[Shank](https://github.com/memoizr/shank) is a lightweight dependency injection (DI) library for Kotlin that integrates seamlessly with Snitch. This guide covers how to use Shank effectively in your Snitch applications.

## Introduction to Shank

Shank provides best-in-class performance among all dependency injection frameworks on the JVM, with a simple, strictly type-safe approach that eliminates common pitfalls. Its remarkable features include:

- **Industry-leading performance**: Unmatched startup and runtime performance
- **Zero reflection**: No runtime overhead or class scanning
- **Cycle detection**: Built-in circular dependency detection using only the Kotlin compiler
- **Strict type safety**: Will never throw runtime exceptions related to types
- **Runtime resolution**: All dependencies are resolved at runtime, supporting hot reloading
- **Polymorphism support**: Interface-based dependency injection
- **Scoped dependencies**: Context-aware dependency scoping
- **Parameterized injection**: Dependencies can be scoped to injection parameters
- **Testing support**: Easy factory overriding for testing
- **Lightweight**: Only 300kb, with virtually no startup overhead
- **Lazy initialization**: Modules are objects initialized only when needed
- **Infinite extensibility**: Supports any custom dependency resolution strategy

## Adding Shank to Your Project

The Shank library is included as a transitive dependency when you include Snitch, so no additional dependency is needed:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

## Core Concepts

### ShankModule

The primary building block in Shank is the `ShankModule` interface. You create modules by implementing this interface:

```kotlin
object ApplicationModule : ShankModule {
    // Dependencies will be defined here
}
```

### Dependency Scopes

Shank offers three main scopes for dependencies:

1. **Singleton** (`single`) - A single instance for the entire application's lifecycle
2. **Factory** (`new`) - Creates a new instance each time
3. **Scoped** (`scoped`) - Instances are scoped to a specific context

## Defining Dependencies

### Singleton Dependencies

Use `single` for dependencies that should have a single instance throughout the application's lifecycle:

```kotlin
object ApplicationModule : ShankModule {
    // Clock is provided as a singleton
    val clock = single { -> Clock.systemUTC() }
    
    // Logger is a singleton with a typed interface
    val logger = single<Logger> { -> LoggerImpl() }
}
```

### Factory Dependencies (new instance each time)

Use `new` for dependencies that should be recreated each time they're requested:

```kotlin
object ApplicationModule : ShankModule {
    // Returns a new Instant every time it's called
    val now = new { -> Instant.now(clock()) }
}
```

### Scoped Dependencies

Use `scoped` for dependencies that are tied to a specific context or lifecycle:

```kotlin
object SessionModule : ShankModule {
    // User context scoped to a session
    val userContext = scoped { sessionId: String -> UserContext(sessionId) }
}
```

## Dependency Injection with Shank in Snitch

### Creating Modules

In a Snitch application, you typically organize dependencies by creating modules for different parts of your application:

```kotlin
// Database-related dependencies
object DBModule : ShankModule {
    val connection = single { ->
        Database.connect(
            "jdbc:postgresql://localhost:5432/postgres",
            driver = "org.postgresql.Driver",
            user = "postgres",
            password = "postgres"
        )
    }
    
    val database = single { -> PostgresDatabase(connection()) }
}

// Repositories
object RepositoriesModule : ShankModule {
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }
}

// Security-related dependencies
object SecurityModule : ShankModule {
    val keyPair = single { ->
        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")
        keyPairGenerator.initialize(2048)
        keyPairGenerator.genKeyPair()
    }
    
    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }
    val publicKey = single { -> keyPair().public }
    val hasher = single<IPasswordHasher> { -> PasswordHasher(argon()) }
    val argon = single { -> Argon2Factory.create() }
    val jwt = single { -> JWTManager() }
}
```

### Using Dependencies in Handlers

Once you've defined your dependencies, you can use them in your Snitch handlers:

```kotlin
// User repository is injected
val usersRepository = RepositoriesModule.usersRepository()

val createUser by parsing<CreateUserRequest>() handling {
    // jwt manager is injected
    val jwt = SecurityModule.jwt()
    
    // passwordHasher is injected
    val hasher = SecurityModule.hasher()
    
    // Hash the password
    val hashedPassword = hasher.hash(body.password)
    
    // Save the user
    val user = usersRepository.createUser(body.username, hashedPassword)
    
    // Generate a token
    val token = jwt.createToken(user.id)
    
    // Return the response
    CreateUserResponse(user.id, token).created
}
```

## Advanced Shank Features

### Parameterized Dependencies

Shank supports dependencies with parameters:

```kotlin
object CacheModule : ShankModule {
    val cache = single { region: String -> Cache(region) }
}

// Usage
val userCache = CacheModule.cache("users")
val postCache = CacheModule.cache("posts")
```

### Type-bound Dependencies

You can bind an implementation to an interface:

```kotlin
object RepositoriesModule : ShankModule {
    // Bind PostgresUsersRepository to UsersRepository interface
    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }
}

// Usage
val repo: UsersRepository = RepositoriesModule.usersRepository()
```

### Testing with Shank

Shank makes testing easier by allowing you to override dependencies:

```kotlin
@BeforeEach
fun setup() {
    // Override real implementation with mock
    RepositoriesModule.usersRepository.overrideFactory { -> mockUsersRepository }
}

@AfterEach
fun tearDown() {
    // Restore original implementation
    RepositoriesModule.usersRepository.restore()
    
    // Or reset all overrides
    resetShank()
}
```

## Integrating with Snitch Middleware

You can create middleware that injects dependencies:

```kotlin
val Router.withTransaction get() = decorateWith {
    val database = DBModule.postgresDatabase()
    database.transaction {
        next()
    }
}

// Usage
routes {
    withTransaction {
        POST("users") with body<CreateUserRequest>() isHandledBy createUser
    }
}
```

## Best Practices

1. **Organize by Module**: Group related dependencies in modules
2. **Interface-based Design**: Bind implementations to interfaces
3. **Single Responsibility**: Keep modules focused on a specific area
4. **Lazy Initialization**: Dependencies are only created when needed
5. **Testing**: Use overrides for test mocks

## Complete Example

Here's a complete example of using Shank with Snitch:

```kotlin
import snitch.dsl.*
import snitch.gson.GsonJsonParser
import snitch.shank.ShankModule
import snitch.shank.single

// Define modules
object AppModule : ShankModule {
    val logger = single { -> Logger() }
}

object UserModule : ShankModule {
    val userRepository = single { -> UserRepositoryImpl() }
    val userService = single { -> UserService(userRepository()) }
}

// Define handlers using dependencies
val getUserById by handling {
    val userService = UserModule.userService()
    val logger = AppModule.logger()
    
    logger.info("Getting user with ID: ${request[userId]}")
    
    val user = userService.getUser(request[userId])
    user?.ok ?: "User not found".notFound()
}

// Define parameters
val userId by path()

// Configure routes
fun main() {
    snitch(GsonJsonParser)
        .onRoutes {
            GET("users" / userId) isHandledBy getUserById
        }
        .start()
        .serveDocumenation()
}
```

## Performance Advantages

Shank's performance advantages come from several key design decisions:

1. **Zero reflection**: Unlike Spring or Guice which rely on runtime reflection, Shank uses pure Kotlin function references and type inference
2. **No proxy generation**: Dependencies are direct instances, not proxies, eliminating overhead
3. **No annotation processing**: No compile-time code generation or annotation scanning
4. **Lazy evaluation**: Dependencies are only instantiated when needed
5. **Minimal dependency graph traversal**: Optimized dependency resolution algorithm

These advantages result in:
- Faster application startup times
- Lower memory consumption
- Reduced CPU overhead
- Smaller deployment artifacts

## Summary

Shank provides the highest-performing, most type-safe dependency injection solution available for Kotlin applications, with unmatched integration with Snitch. By organizing dependencies into modules and leveraging Shank's powerful yet simple API, you can create maintainable, testable applications with minimal boilerplate and maximum performance.

---

## From: Anatomy-of-Endpoints.md

# Endpoint DSL

Endpoints are the fundamental building blocks of your API in Snitch. This guide explores the internal structure of the Endpoint DSL, explaining how endpoints are defined, configured, and composed to create expressive, type-safe APIs.

## The Endpoint Data Class

At the core of Snitch's routing system is the `Endpoint` data class:

```kotlin
data class Endpoint<T: Any>(
    val method: Method,
    val path: String,
    val parameters: List<Parameter<*, *>> = emptyList(),
    val conditions: List<Condition> = emptyList(),
    val decorations: List<Decoration> = emptyList(),
    val beforeActions: List<RequestWrapper.() -> Response?> = emptyList(),
    val afterActions: List<RequestWrapper.() -> Unit> = emptyList(),
    val handler: (RequestWrapper.() -> T)? = null
)
```

Let's examine each component:

1. **Type Parameter**:
   - `T`: The return type of the handler function, which determines the response type

2. **Properties**:
   - `method`: The HTTP method (GET, POST, etc.)
   - `path`: The URL path, potentially including parameter placeholders
   - `parameters`: List of parameters (path, query, header, body) this endpoint uses
   - `conditions`: List of conditions that must be satisfied for the endpoint to execute
   - `decorations`: List of decorations that modify the endpoint's behavior
   - `beforeActions`: Actions executed before the handler runs
   - `afterActions`: Actions executed after the handler completes
   - `handler`: The function that processes the request and produces a response

The data class design is crucial for Snitch's flexibility and composability. Since endpoints are immutable data objects, they can be transformed and combined in powerful ways without side effects.

## Creating Endpoints

Endpoints are typically created through the HTTP method functions and then configured with additional features.

### HTTP Method Functions

Snitch provides functions for each HTTP method:

```kotlin
fun GET(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.GET, path = ensureLeadingSlash(path))

fun POST(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.POST, path = ensureLeadingSlash(path))

fun PUT(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.PUT, path = ensureLeadingSlash(path))

fun DELETE(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.DELETE, path = ensureLeadingSlash(path))

fun PATCH(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.PATCH, path = ensureLeadingSlash(path))

fun OPTIONS(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.OPTIONS, path = ensureLeadingSlash(path))

fun HEAD(path: String = ""): Endpoint<Any> = 
    Endpoint(method = Method.HEAD, path = ensureLeadingSlash(path))
```

Each function creates an `Endpoint` with the specified HTTP method and path, returning a fresh `Endpoint` instance ready for further configuration.

**Usage Example**:

```kotlin
GET("users")       // Creates a GET endpoint for /users
POST("users")      // Creates a POST endpoint for /users
PUT("users/123")   // Creates a PUT endpoint for /users/123
```

### Path Construction

Paths can be constructed in several ways:

1. **String literals**:
   ```kotlin
   GET("users/profile")
   ```

2. **Path parameters**:
   ```kotlin
   val userId by path()
   GET("users" / userId)
   ```

3. **Path composition with the `/` operator**:
   ```kotlin
   GET("users" / userId / "posts" / postId)
   ```

The `/` operator is an extension function on `String` that concatenates path segments:

```kotlin
operator fun String.div(other: String): String = 
    "$this/$other".replace("//", "/")

operator fun String.div(param: Parameter<*, *>): String = 
    "$this/{${param.name}}".replace("//", "/")
```

This elegant approach allows paths to be constructed in a readable, composable way.

### Route Nesting

Snitch supports route nesting through a DSL that allows hierarchical organization:

```kotlin
routes {
    "api" / {
        "v1" / {
            "users" / {
                GET() isHandledBy getUsersHandler
                POST() with body<CreateUserRequest>() isHandledBy createUserHandler
                
                userId / {
                    GET() isHandledBy getUserHandler
                    PUT() with body<UpdateUserRequest>() isHandledBy updateUserHandler
                    DELETE() isHandledBy deleteUserHandler
                }
            }
        }
    }
}
```

Behind the scenes, this is implemented using a hierarchical context that tracks the current path prefix:

```kotlin
class RouterContext(private val pathPrefix: String = "") {
    fun String.div(block: RouterContext.() -> Unit) {
        val newContext = RouterContext("$pathPrefix/$this".replace("//", "/"))
        newContext.block()
    }
    
    fun GET(path: String = ""): Endpoint<Any> = 
        Endpoint(Method.GET, "$pathPrefix/$path".replace("//", "/"))
    
    // Other HTTP method functions...
}
```

This approach allows you to organize routes according to your API's logical structure.

## Configuring Endpoints

Once an endpoint is created, it can be configured with various features. These configurations are applied through extension functions that return new `Endpoint` instances with the desired modifications.

### Parameters

Parameters are added using the `with` function and its variants:

```kotlin
fun <T: Any> Endpoint<T>.with(vararg params: Parameter<*, *>): Endpoint<T> =
    copy(parameters = parameters + params)

fun <T: Any> Endpoint<T>.withQueries(vararg params: Parameter<*, *>): Endpoint<T> =
    with(*params)

fun <T: Any> Endpoint<T>.withHeaders(vararg params: Parameter<*, *>): Endpoint<T> =
    with(*params)
```

**Usage Example**:

```kotlin
val limit by query(ofIntRange(1, 100), default = 20)
val offset by query(ofNonNegativeInt, default = 0)
val apiKey by header(ofNonEmptyString)

GET("users")
    .withQueries(limit, offset)
    .withHeaders(apiKey)
```

Internally, these functions simply add the parameters to the endpoint's parameter list, making them available for validation and access in the handler.

### Conditions

Conditions are added using the `onlyIf` function:

```kotlin
infix fun <T: Any> Endpoint<T>.onlyIf(condition: Condition): Endpoint<T> =
    copy(conditions = conditions + condition)
```

**Usage Example**:

```kotlin
val hasAdminRole = condition("hasAdminRole") { /* implementation */ }

GET("admin/dashboard") onlyIf hasAdminRole
```

The `onlyIf` function appends the condition to the endpoint's conditions list. During request processing, all conditions are evaluated before the handler executes.

### Decorations

Decorations are added using the `decorated` function:

```kotlin
infix fun <T: Any> Endpoint<T>.decorated(with: Decoration): Endpoint<T> =
    copy(decorations = decorations + with)
```

**Usage Example**:

```kotlin
val withLogging = decoration { /* implementation */ }

GET("users") decorated withLogging
```

Decorations provide a way to wrap handler execution with custom logic, similar to middleware in other frameworks.

### Before and After Actions

Before and after actions allow executing code before and after the handler:

```kotlin
fun <T: Any> Endpoint<T>.doBefore(action: RequestWrapper.() -> Response?): Endpoint<T> =
    copy(beforeActions = beforeActions + action)

fun <T: Any> Endpoint<T>.doAfter(action: RequestWrapper.() -> Unit): Endpoint<T> =
    copy(afterActions = afterActions + action)
```

**Usage Example**:

```kotlin
GET("users")
    .doBefore { 
        logger.info("Accessing users endpoint")
        // Optionally return a Response to short-circuit
        null 
    }
    .doAfter { 
        logger.info("Completed users endpoint request")
    }
```

These functions append actions to the respective lists in the endpoint. During request processing, before actions run in reverse declaration order (last declared, first executed), while after actions run in declaration order.

## Endpoint Handlers

While we won't delve deeply into handlers here, it's worth understanding how they connect to endpoints:

```kotlin
infix fun <T: Any> Endpoint<T>.isHandledBy(handler: RequestWrapper.() -> T): Endpoint<T> =
    copy(handler = handler)
```

The `isHandledBy` function associates a handler with an endpoint. The handler is a function that:
1. Receives a `RequestWrapper` as its receiver
2. Returns a value of type `T`, which determines the response type

This type-safe design ensures that handlers return appropriate values that can be converted to HTTP responses.

## The Router Interface

The `Router` interface defines a collection of endpoints:

```kotlin
interface Router {
    val endpoints: List<Endpoint<*>>
}
```

Routers can be composed and nested, allowing for modular API organization:

```kotlin
fun routes(block: RouterBuilder.() -> Unit): Router {
    val builder = RouterBuilder()
    builder.block()
    return builder.build()
}
```

The `RouterBuilder` class accumulates endpoints during DSL execution:

```kotlin
class RouterBuilder {
    private val mutableEndpoints = mutableListOf<Endpoint<*>>()
    
    fun <T: Any> endpoint(endpoint: Endpoint<T>) {
        mutableEndpoints.add(endpoint)
    }
    
    fun build(): Router = object : Router {
        override val endpoints = mutableEndpoints.toList()
    }
}
```

This builder-based approach allows for a clean DSL while maintaining immutability of the resulting routers.

## Extension and Customization

One of Snitch's most powerful features is its extensibility. Since endpoints are data classes and the DSL is built from extension functions, you can easily add new capabilities.

### Extending Endpoint with New Capabilities

You can add new features to endpoints by defining extension functions:

```kotlin
fun <T: Any> Endpoint<T>.withTimeout(milliseconds: Long): Endpoint<T> =
    decorated(TimeoutDecoration(milliseconds))

// Usage
GET("slow-operation") withTimeout 5000
```

This approach allows you to create domain-specific extensions tailored to your application's needs.

### Creating DSL Extensions

You can even extend the DSL with new constructs:

```kotlin
infix fun <T: Any> Endpoint<T>.v(version: Int): Endpoint<T> =
    copy(path = path.replace("/v1/", "/v$version/"))

// Usage
GET("v1/users") v 2 isHandledBy getUsersV2Handler
```

This creates an expressive way to define versioned endpoints. Because endpoints are data classes, transformations like this are straightforward and composable.

## Type Safety Aspects

Snitch's Endpoint DSL is designed with type safety as a primary consideration:

1. **Parameter Type Safety**:
   ```kotlin
   val userId by path(ofLong)
   
   // In the handler:
   val id: Long = request[userId] // Type-safe access
   ```

2. **Handler Return Types**:
   ```kotlin
   GET("users") isHandledBy {
       // Must return a value compatible with the endpoint type
       listOf("user1", "user2").ok
   }
   ```

3. **Condition Composition**:
   ```kotlin
   GET("resource") onlyIf (isAuthenticated and (isResourceOwner or hasAdminRole))
   ```
   The boolean operators (`and`, `or`, `not`) are type-checked at compile time.

4. **Method Chaining**:
   ```kotlin
   GET("users")
       .withQueries(limit, offset)
       .onlyIf(isAuthenticated)
       .doBefore { /* ... */ }
       .isHandledBy { /* ... */ }
   ```
   Each method returns the appropriate endpoint type, ensuring the chain remains type-safe.

This comprehensive type safety catches many potential errors at compile time, dramatically reducing runtime issues.

## Under the Hood: Request Processing

When a request arrives, Snitch processes it through several stages:

1. **Route Matching**: Snitch finds the endpoint that matches the HTTP method and path
2. **Parameter Extraction and Validation**: Parameters are extracted from the request and validated
3. **Condition Evaluation**: All conditions are evaluated; if any fail, the request is rejected
4. **Decoration Setup**: Decorations are arranged to wrap the handler execution
5. **Before Actions**: Before actions are executed in reverse order
6. **Handler Execution**: The handler processes the request
7. **After Actions**: After actions are executed in declaration order

This pipeline is reflected in the `Endpoint` data class structure, with each component corresponding to a stage in request processing.

## Best Practices

Based on the internal workings of endpoints, here are some best practices:

1. **Organize by Resource**: Structure your routes around resources and sub-resources
   ```kotlin
   "users" / {
       GET() // List users
       POST() // Create user
       
       userId / {
           GET() // Get user
           PUT() // Update user
           DELETE() // Delete user
           
           "posts" / {
               // User's posts resources
           }
       }
   }
   ```

2. **Keep Endpoints Focused**: Each endpoint should handle a single responsibility

3. **Extract Shared Logic**: Use decorations and conditions to extract cross-cutting concerns
   ```kotlin
   val authenticated = decorateWith { /* authentication logic */ }
   
   authenticated {
       // All routes here require authentication
   }
   ```

4. **Leverage Type-Safe Parameters**: Define all parameters with appropriate validators
   ```kotlin
   val limit by query(ofIntRange(1, 100), default = 20)
   
   // Better than:
   val limit by query() // String that needs manual validation
   ```

5. **Use Extension Methods for Common Patterns**: Create extension functions for frequent use cases
   ```kotlin
   fun <T: Any> Endpoint<T>.withCache(durationSeconds: Int): Endpoint<T> =
       decorated(CacheDecoration(durationSeconds))
   ```

6. **Modularize Routers**: Break large APIs into smaller, composable routers
   ```kotlin
   val userRoutes = routes { /* user endpoints */ }
   val postRoutes = routes { /* post endpoints */ }
   
   val apiRoutes = routes {
       "api" / {
           "users" / userRoutes
           "posts" / postRoutes
       }
   }
   ```

7. **Follow RESTful Conventions**: Use appropriate HTTP methods for different operations
   ```kotlin
   GET(resourceId)   // Read a resource
   POST()            // Create a resource
   PUT(resourceId)   // Update a resource
   DELETE(resourceId) // Delete a resource
   ```

## Conclusion

The Endpoint DSL in Snitch provides a powerful, type-safe way to define and configure API endpoints. By understanding its internal structure and capabilities, you can create expressive, maintainable APIs that leverage Kotlin's type system for robust error checking.

The data class foundation, combined with extension functions and builders, creates a DSL that is both flexible and type-safe, allowing for easy customization while catching errors at compile time.

This design exemplifies how thoughtful API design can leverage language features to create expressive yet safe interfaces for complex functionality.

---

## From: Anatomy-of-Handlers.md

# Handler DSL

Handlers are the core of your API's business logic in Snitch. They process incoming requests, execute application code, and produce responses. This guide explores the inner workings of Snitch's Handler DSL, explaining how handlers are defined, composed, and integrated with the rest of the framework.

## Handler Fundamentals

At its core, a handler in Snitch is simply a function that:
1. Takes a `RequestWrapper` as its receiver (via Kotlin's function literal with receiver syntax)
2. Returns a value that can be converted to an HTTP response

The basic signature looks like this:

```kotlin
typealias Handler<T> = RequestWrapper.() -> T
```

This simple design allows handlers to:
- Access request data through the `RequestWrapper` receiver
- Return any type that can be serialized to a response
- Leverage Kotlin's powerful type system

Let's explore how this works in practice.

## The RequestWrapper

The `RequestWrapper` is the handler's interface to the incoming request. It provides access to:

```kotlin
interface RequestWrapper {
    val method: Method
    val path: String
    val queryParams: Map<String, Collection<String>>
    val headerParams: Map<String, Collection<String>>
    val pathParams: Map<String, String>
    val parser: Parser
    val attributes: MutableMap<String, Any>
    
    operator fun <T> get(parameter: Parameter<*, T>): T
    
    // Additional utility methods...
}
```

The key components are:

1. **Request metadata**: Method, path, and raw parameter maps
2. **Parser**: For converting strings to/from structured data
3. **Attributes**: A mutable map for storing request-scoped data
4. **Parameter access**: Type-safe access to validated parameters via the `get` operator

The `get` operator is particularly important, as it provides type-safe access to parameters:

```kotlin
val userId = request[userId] // Returns the validated parameter value with correct type
```

Under the hood, this operator:
1. Looks up the parameter's value(s) from the appropriate source (path, query, header, body)
2. Validates the value(s) using the parameter's validator
3. Transforms the value(s) to the target type
4. Returns the strongly-typed result

If validation fails, the framework automatically returns an appropriate error response.

## Response Creation

Snitch provides a rich DSL for creating HTTP responses. The core mechanism is extension properties and functions on any type, which create subclasses of the sealed `HttpResponse` class.

### The HttpResponse Hierarchy

`HttpResponse` is a sealed class with three implementations:

```kotlin
sealed class HttpResponse<T, out S : StatusCodes> {
    abstract val statusCode: StatusCodes
    abstract val headers: Map<String, String>
    abstract val value: context(Parser) () -> Any?
    abstract fun header(header: Pair<String, String>): HttpResponse<T, S>
    
    // Provides a way to transform responses based on their type
    fun map(
        failure: ErrorHttpResponse<T, *, S>.() -> HttpResponse<Any, *> = { this as HttpResponse<Any, *> },
        success: SuccessfulHttpResponse<T, S>.() -> HttpResponse<Any, *>,
    ): HttpResponse<Any, *> = when (this) {
        is SuccessfulHttpResponse -> this.success()
        is ErrorHttpResponse<T, *, S> -> this.failure()
        is RawHttpResponse -> throw UnsupportedOperationException()
    }
}
```

The three implementations are:

1. **SuccessfulHttpResponse**: For 2xx status codes, with typed body content
   ```kotlin
   data class SuccessfulHttpResponse<T, out S : StatusCodes>(
       override val statusCode: S,
       val body: T,
       val _format: Format = Format.Json,
       override val value: context(Parser) () -> Any? = { /* serialization logic */ },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

2. **ErrorHttpResponse**: For error status codes (4xx, 5xx), with typed error details
   ```kotlin
   data class ErrorHttpResponse<T, E, out S : StatusCodes>(
       override val statusCode: StatusCodes,
       val details: E,
       override val value: context(Parser) () -> Any? = { details?.serialized },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

3. **RawHttpResponse**: For sending raw content with minimal processing
   ```kotlin
   data class RawHttpResponse<T, out S : StatusCodes>(
       override val statusCode: S,
       val body: Any,
       val _format: Format = Format.Json,
       override val value: context(Parser) () -> Any? = { body },
       override val headers: Map<String, String> = emptyMap(),
   ) : HttpResponse<T, S>()
   ```

### Response Extensions

The `CommonResponses` interface provides extension properties and functions to create responses with minimal syntax:

```kotlin
// Success responses
val <T> T.ok get() = SuccessfulHttpResponse(StatusCodes.OK, this)
val <T> T.created get() = SuccessfulHttpResponse(StatusCodes.CREATED, this)
val <T> T.accepted get() = SuccessfulHttpResponse(StatusCodes.ACCEPTED, this)
val <T> T.noContent get() = SuccessfulHttpResponse(StatusCodes.NO_CONTENT, this)

// Error responses
fun <T, E, S: StatusCodes> E.badRequest() = ErrorHttpResponse<T, _, S>(StatusCodes.BAD_REQUEST, this)
fun <T, E, S: StatusCodes> E.unauthorized() = ErrorHttpResponse<T, _,S>(StatusCodes.UNAUTHORIZED, this)
fun <T, E, S: StatusCodes> E.forbidden() = ErrorHttpResponse<T, _, S>(StatusCodes.FORBIDDEN, this)
fun <T, E, S: StatusCodes> E.notFound() = ErrorHttpResponse<T, _, S>(StatusCodes.NOT_FOUND, this)
fun <T, E, S: StatusCodes> E.serverError() = ErrorHttpResponse<T, _, S>(StatusCodes.INTERNAL_SERVER_ERROR, this)

// Format control
fun <T, S : StatusCodes> HttpResponse<T, S>.format(newFormat: Format) = /* ... */
val <T, S : StatusCodes> HttpResponse<T, S>.plainText get() = /* ... */
```

This allows handlers to return responses in a concise, readable way:

```kotlin
val getUser by handling {
    val user = userRepository.findById(request[userId])
    if (user != null) user.ok
    else "User not found".notFound()
}
```

### Status Codes

Status codes are modeled as singleton objects within the `StatusCodes` abstract class:

```kotlin
abstract class StatusCodes(val code: Int = 200) {
    object OK : StatusCodes(200)
    object CREATED : StatusCodes(201)
    object ACCEPTED : StatusCodes(202)
    object NO_CONTENT : StatusCodes(204)
    
    object BAD_REQUEST : StatusCodes(400)
    object UNAUTHORIZED : StatusCodes(401)
    object FORBIDDEN : StatusCodes(403)
    object NOT_FOUND : StatusCodes(404)
    object TOO_MANY_REQUESTS : StatusCodes(429)
    
    object INTERNAL_SERVER_ERROR : StatusCodes(500)
    object SERVICE_UNAVAILABLE : StatusCodes(503)
    // Plus many other standard HTTP status codes
}
```

When the response is rendered, the framework:
1. Sets the HTTP status code to `statusCode.code`
2. Serializes the body or details based on the response type and format
3. Adds any custom headers defined in the response

This design provides several advantages:
- Type safety through generics
- Clear distinction between success and error responses
- Flexible content format handling (JSON, plain text, etc.)
- Support for response transformation with the `map` function

## Handler Definition Approaches

Snitch offers several ways to define handlers, each with its own use cases.

### Inline Handlers

The simplest approach is defining handlers inline with routes:

```kotlin
GET("users" / userId) isHandledBy {
    userRepository.findById(request[userId])
        ?.ok
        ?: "User not found".notFound()
}
```

This works well for simple endpoints with minimal logic.

### Named Handlers

For more complex endpoints, you can define named handlers:

```kotlin
val getUser by handling {
    val id = request[userId]
    val user = userRepository.findById(id)
    if (user != null) user.ok
    else "User not found".notFound()
}

// In routes
GET("users" / userId) isHandledBy getUser
```

The `handling` function is defined as:

```kotlin
fun <T: Any> handling(handler: Handler<T>): HandlerReference<T> =
    HandlerReference(handler)

class HandlerReference<T: Any>(val handler: Handler<T>)
```

This allows handlers to be:
- Reused across multiple routes
- Tested independently
- Named for better code organization

### Reusable Handlers

For handlers that need access to request body data, there's a specialized approach:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // body is the parsed CreateUserRequest
    val result = userService.createUser(body.name, body.email)
    CreatedUser(result.id, result.name).created
}
```

The `parsing` function is:

```kotlin
inline fun <reified B: Any> parsing(): BodyHandlerBuilder<B> =
    BodyHandlerBuilder(B::class)

class BodyHandlerBuilder<B: Any>(private val bodyClass: KClass<B>) {
    infix fun handling(handler: BodyHandler<B, *>): BodyHandlerReference<B, *> =
        BodyHandlerReference(handler, bodyClass)
}

typealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T
```

This pattern provides:
- Type-safe access to the request body
- Automatic body parsing and validation
- Clear separation of body handling from other request processing

## Type-Safe Parameter Access

One of Snitch's core strengths is type-safe parameter access. When you define a parameter:

```kotlin
val userId by path(ofLong)
```

You can access it with the correct type in handlers:

```kotlin
val getUser by handling {
    val id: Long = request[userId] // Type is Long, not String
    // ...
}
```

Behind the scenes, this works through the interaction of:
1. The `Parameter` class that captures the validator
2. The `get` operator on `RequestWrapper` that applies the validator
3. Kotlin's type inference that understands the return type

Let's explore how parameters are implemented:

```kotlin
class Parameter<From, To>(
    val name: String,
    val description: String,
    val validator: Validator<From, To>,
    val source: ParameterSource,
    val required: Boolean = true,
    val default: To? = null,
    // Additional metadata...
)
```

When you access a parameter, the framework:
1. Extracts the raw value from the request based on `source`
2. Validates and transforms it using `validator`
3. Falls back to `default` if the parameter is missing and not `required`

This ensures that by the time your handler code executes, all parameters are valid and properly typed.

## Body Handling

Request bodies require special treatment due to their potentially complex structure:

```kotlin
data class CreateUserRequest(val name: String, val email: String)

val userBody by body<CreateUserRequest>()

POST("users") with userBody isHandledBy {
    val request: CreateUserRequest = request[userBody]
    // Use typed request body
}
```

The `body` function creates a special parameter that:
1. Extracts the raw request body from the HTTP request
2. Uses the configured JSON parser to deserialize it to the target type
3. Makes it available via `request[bodyParam]`

For handlers that need frequent body access, the `parsing` pattern simplifies this:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // Direct access to body without request[bodyParam]
    val user = userService.createUser(body.name, body.email)
    // ...
}
```

Under the hood, `parsing` creates a specialized `BodyRequestWrapper` that exposes the parsed body:

```kotlin
interface BodyRequestWrapper<B> : RequestWrapper {
    val body: B
}
```

This provides a cleaner API for body-centric handlers.

## Error Handling in Handlers

Handlers can approach error handling in several ways:

### 1. Return explicit error responses:

```kotlin
val getUser by handling {
    try {
        val user = userService.findById(request[userId])
        if (user != null) user.ok
        else "User not found".notFound()
    } catch (e: DatabaseException) {
        "Database error: ${e.message}".serverError()
    }
}
```

### 2. Throw exceptions that are handled globally:

```kotlin
// In application setup
snitch(parser)
    .onRoutes(routes)
    .handleException(ResourceNotFoundException::class) { ex ->
        ErrorResponse(ex.message ?: "Resource not found").notFound()
    }
    .handleException(DatabaseException::class) { ex ->
        ErrorResponse("Internal error").serverError()
    }
    .start()

// In handler - let exceptions propagate
val getUser by handling {
    userService.findById(request[userId])?.ok
        ?: throw ResourceNotFoundException("User not found")
}
```

The exception handling is implemented by wrapping handler execution:

```kotlin
try {
    handler.invoke(requestWrapper)
} catch (e: Exception) {
    // Find appropriate exception handler
    exceptionHandlers[e::class]?.invoke(e) ?: throw e
}
```

This allows for centralized error handling while keeping handlers focused on the happy path.

## Asynchronous Handlers

Snitch supports asynchronous handlers through coroutines:

```kotlin
val getUser by coHandling {
    // Suspend function call
    val user = userRepository.findByIdAsync(request[userId])
    user?.ok ?: "User not found".notFound()
}
```

The `coHandling` function is defined as:

```kotlin
fun <T: Any> coHandling(handler: suspend Handler<T>): CoHandlerReference<T> =
    CoHandlerReference(handler)
```

This leverages Kotlin's coroutine support to allow non-blocking execution while maintaining the same expressive handler syntax.

## The Handler Execution Pipeline

When a request is processed, handlers go through a specific execution pipeline:

1. **Parameter Validation**: All required parameters are validated
2. **Condition Evaluation**: All conditions are checked
3. **Before Actions**: Before actions execute in reverse order
4. **Decoration Setup**: Decorations wrap the handler
5. **Handler Execution**: The handler processes the request
6. **After Actions**: After actions execute in declaration order

This pipeline ensures that by the time your handler executes:
- All parameters are validated and available
- All conditions are satisfied
- Any pre-processing logic has run

The handler's result then flows through:
1. Any transformation logic in decorations
2. Serialization based on content negotiation
3. Response status code and header application

This structured flow keeps handlers focused on business logic while the framework handles HTTP concerns.

## Testing Handlers

Snitch's design makes handler testing straightforward:

```kotlin
@Test
fun `getUser returns user when found`() {
    // Setup mock repository
    val mockRepo = mockk<UserRepository>()
    every { mockRepo.findById(1) } returns User(1, "Test User")
    
    // Create test request wrapper
    val request = TestRequestWrapper().apply {
        // Set up parameter for testing
        setParameter(userId, 1L)
    }
    
    // Execute handler directly
    val handler = UserHandlers(mockRepo).getUser.handler
    val response = handler.invoke(request)
    
    // Verify response
    assertThat(response.statusCode).isEqualTo(StatusCode.OK)
    assertThat(response.value).isInstanceOf(User::class.java)
    assertThat((response.value as User).name).isEqualTo("Test User")
}
```

For more comprehensive testing, Snitch also provides a testing DSL:

```kotlin
@Test
fun `getUser endpoint returns user when found`() {
    // Setup mock repository
    val mockRepo = mockk<UserRepository>()
    every { mockRepo.findById(1) } returns User(1, "Test User")
    
    // Test the endpoint
    testApp {
        // Register routes with mock dependencies
        registerRoutes(userRoutes(mockRepo))
        
        // Execute request
        GET("/users/1")
            .expectCode(200)
            .expectJson {
                it.path("id").asInt() shouldBe 1
                it.path("name").asText() shouldBe "Test User"
            }
    }
}
```

This approach allows for both unit testing of individual handlers and integration testing of entire endpoints.

## Handler Implementation Details

Let's look at some of the key implementation details behind handlers:

### Handler Function Types

Snitch uses several function types for different handler scenarios:

```kotlin
// Basic handler
typealias Handler<T> = RequestWrapper.() -> T

// Body handler
typealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T

// Coroutine handler
typealias CoHandler<T> = suspend Handler<T>
```

### Handler References

Handler references wrap handler functions to make them usable with the DSL:

```kotlin
class HandlerReference<T: Any>(val handler: Handler<T>)

class BodyHandlerReference<B: Any, T: Any>(
    val handler: BodyHandler<B, T>,
    val bodyClass: KClass<B>
)

class CoHandlerReference<T: Any>(val handler: suspend Handler<T>)
```

### Handler Execution

The endpoint processor executes handlers through a series of steps:

```kotlin
// Simplified flow
fun executeHandler(endpoint: Endpoint<*>, request: Request): Response {
    // Create request wrapper
    val wrapper = RequestWrapperImpl(request, parser)
    
    // Validate parameters
    validateParameters(endpoint.parameters, wrapper)
    
    // Check conditions
    evaluateConditions(endpoint.conditions, wrapper)
    
    // Execute before actions
    for (action in endpoint.beforeActions.reversed()) {
        val earlyResponse = action(wrapper)
        if (earlyResponse != null) return earlyResponse
    }
    
    // Execute handler with decorations
    val result = applyDecorations(endpoint.decorations, endpoint.handler!!)(wrapper)
    
    // Convert result to response
    val response = when (result) {
        is Response -> result
        else -> Response(result, OK)
    }
    
    // Execute after actions
    for (action in endpoint.afterActions) {
        action(wrapper)
    }
    
    return response
}
```

This structured approach ensures consistent request handling while giving handlers access to all the information they need.

## Best Practices

Based on the inner workings of handlers, here are some best practices:

### 1. Keep Handlers Focused

Handlers should focus on their primary responsibility:

```kotlin
// Good: Focused on user retrieval
val getUser by handling {
    userRepository.findById(request[userId])
        ?.ok
        ?: "User not found".notFound()
}

// Avoid: Mixing concerns
val getUser by handling {
    // Authentication logic
    if (!isAuthenticated()) return "Unauthorized".unauthorized()
    
    // Logging
    logger.info("Getting user ${request[userId]}")
    
    // Business logic
    val user = userRepository.findById(request[userId])
    
    // Response creation
    if (user != null) user.ok
    else "User not found".notFound()
}
```

Use conditions, decorations, and actions for cross-cutting concerns.

### 2. Leverage Type Safety

Take advantage of Snitch's type safety features:

```kotlin
// Define parameters with specific types
val userId by path(ofLong)
val userRole by query(ofEnum<UserRole>())

// Use typed parameters in handlers
val getUser by handling {
    val id: Long = request[userId]
    val role: UserRole = request[userRole]
    // No need for manual parsing or validation
}
```

### 3. Use Named Handlers for Complex Logic

```kotlin
// Named handler for better organization
val createUser by parsing<CreateUserRequest>() handling {
    // Validation
    if (!isValidEmail(body.email)) {
        return ValidationError("Invalid email").badRequest()
    }
    
    // Business logic
    try {
        val id = userService.createUser(body.name, body.email)
        CreatedUser(id).created
    } catch (e: DuplicateUserException) {
        ValidationError("User already exists").badRequest()
    }
}
```

### 4. Structure Error Handling Appropriately

For application-specific exceptions, use global handlers:

```kotlin
snitch(parser)
    .handleException(ResourceNotFoundException::class) { ex ->
        ErrorResponse(ex.message ?: "Resource not found").notFound()
    }

// Then throw from handlers
val getUser by handling {
    userRepository.findById(request[userId]) 
        ?: throw ResourceNotFoundException("User not found")
}
```

For business logic validation, return explicit responses:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    if (!isValidEmail(body.email)) {
        return ValidationError("Invalid email").badRequest()
    }
    // Proceed with valid input
}
```

### 5. Use Coroutines for I/O-Bound Operations

```kotlin
val getUser by coHandling {
    // Non-blocking database call
    val user = userRepository.findByIdAsync(request[userId])
    user?.ok ?: "User not found".notFound()
}
```

### 6. Group Related Handlers

```kotlin
class UserHandlers(private val userRepository: UserRepository) {
    val getUser by handling {
        // Implementation
    }
    
    val createUser by parsing<CreateUserRequest>() handling {
        // Implementation
    }
    
    val updateUser by parsing<UpdateUserRequest>() handling {
        // Implementation
    }
    
    val deleteUser by handling {
        // Implementation
    }
}

// In routes
val userHandlers = UserHandlers(userRepository)

"users" / {
    GET(userId) isHandledBy userHandlers.getUser
    POST() with userBody isHandledBy userHandlers.createUser
    PUT(userId) with userBody isHandledBy userHandlers.updateUser
    DELETE(userId) isHandledBy userHandlers.deleteUser
}
```

This approach:
- Groups related functionality
- Makes dependency injection straightforward
- Improves code organization

## Conclusion

Snitch's Handler DSL provides a powerful, type-safe way to implement API business logic. By understanding its internal workings, you can leverage its full potential to create expressive, maintainable handlers.

The combination of type-safe parameter access, flexible response creation, and structured execution pipeline allows you to focus on your business logic while the framework handles HTTP concerns.

Whether you're writing simple endpoints or complex business processes, Snitch's Handler DSL offers the tools to express your intent clearly and safely.

---

## From: Anatomy-of-Validators.md

# Validator DSL

Validators are a cornerstone of Snitch's design, ensuring that HTTP inputs are properly validated and transformed into domain types. This guide explores the internal workings of the validator DSL, explaining each component and how they fit together.

## The Validator Interface

At the heart of the validation system is the `Validator` interface:

```kotlin
interface Validator<T, R> {
    val regex: Regex
    val description: String
    val parse: Parser.(Collection<String>) -> R
    fun optional(): Validator<T?, R?> = this as Validator<T?, R?>
}
```

Let's break down each component:

1. **Type Parameters**:
   - `T`: The input type that the validator accepts (typically `String`)
   - `R`: The output type that the validator produces (your domain type)

2. **Properties**:
   - `regex`: A regular expression used for initial string validation
   - `description`: A human-readable description used for documentation
   - `parse`: A function that takes a collection of strings and transforms them into the output type
   
3. **Methods**:
   - `optional()`: Converts a required validator to an optional one

The interface is intentionally minimal, focusing on the essential components of validation: pattern matching, transformation, and documentation.

## Creating Validators

Snitch provides several factory functions for creating validators with different behaviors:

### The `validator` Function

The most general factory function:

```kotlin
inline fun <From, To> validator(
    descriptions: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    crossinline mapper: Parser.(String) -> To
) = object : Validator<From, To> {
    override val description = descriptions
    override val regex = regex
    override val parse: Parser.(Collection<String>) -> To = { mapper(it.single()) }
}
```

This function creates a validator that:
- Has a custom description
- Uses a specified regex (or a default that matches any non-empty string)
- Applies a mapping function to transform the input

The `crossinline` modifier ensures that the mapper function can be used inside a lambda that will be inlined.

**Typical Usage**:

```kotlin
val ofUUID = validator<String, UUID>(
    "valid UUID",
    """^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$""".toRegex(RegexOption.IGNORE_CASE)
) {
    try {
        UUID.fromString(it)
    } catch (e: IllegalArgumentException) {
        throw IllegalArgumentException("Invalid UUID format")
    }
}
```

### The `stringValidator` Function

A specialized version for string inputs:

```kotlin
inline fun <To> stringValidator(
    description: String = "",
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    crossinline mapper: Parser.(String) -> To,
) = validator<String, To>(description, regex, mapper)
```

This is a convenience function that defaults the input type to `String`, which is the most common case.

**Typical Usage**:

```kotlin
val ofEmail = stringValidator(
    "email address",
    """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
) { it }
```

### The `validatorMulti` Function

For handling collections of values:

```kotlin
fun <From, To> validatorMulti(
    descriptions: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
) = object : Validator<From, To> {
    override val description = descriptions
    override val regex = regex
    override val parse: Parser.(Collection<String>) -> To = mapper
}
```

This function allows working with multiple input values, such as repeated query parameters.

**Typical Usage**:

```kotlin
val ofStringSet = validatorMulti<String, Set<String>>(
    "set of strings"
) { strings ->
    strings.flatMap { it.split(",") }.toSet()
}
```

### The `stringValidatorMulti` Function

A specialized version for string inputs that return collections:

```kotlin
fun <To> stringValidatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To,
) = validatorMulti<String, To>(description, regex, mapper)
```

This combines the convenience of `stringValidator` with the collection handling of `validatorMulti`.

**Typical Usage**:

```kotlin
val ofTags = stringValidatorMulti<List<String>>(
    "comma-separated tags"
) { params ->
    params.flatMap { it.split(",") }
        .map { it.trim() }
        .filter { it.isNotEmpty() }
}
```

## How Validators Work

Now that we understand the interface and creation functions, let's explore how validators operate at runtime.

### Regex Validation

The first step in validation is pattern matching using the `regex` property:

```kotlin
// Inside parameter handler code
if (!validator.regex.matches(value)) {
    throw ValidationException("Value doesn't match pattern for ${validator.description}")
}
```

This provides a fast first-pass validation before more complex logic is applied. For example, checking that an email string has a basic email-like structure before attempting further validation.

### Transformation Logic

After regex validation passes, the `parse` function is called with the collection of parameter values:

```kotlin
// Inside parameter handler code
try {
    return validator.parse(parser, values)
} catch (e: Exception) {
    throw ValidationException("Failed to parse ${validator.description}: ${e.message}")
}
```

The parse function is responsible for:
1. Handling single vs. multiple values
2. Converting strings to the target type
3. Performing business-specific validation
4. Throwing exceptions for invalid inputs

The transformation typically has access to the `Parser` instance, which provides useful utilities for working with common formats like JSON.

### Error Handling

Validators report errors by throwing exceptions, which Snitch catches and converts to appropriate HTTP responses (typically 400 Bad Request).

This happens at several levels:
1. **Regex mismatch**: Throws a `ValidationException`
2. **Empty collection**: Throws a `NoSuchElementException` from the `single()` call
3. **Custom validation**: Validator-specific exceptions from the mapper function

Snitch provides automatic handling for all of these, generating clear error messages for API consumers.

## The Parser's Role

You may have noticed that the validator functions all pass a `Parser` instance to the mapper function. The `Parser` is an interface for converting between strings and structured data:

```kotlin
interface Parser {
    fun <T> fromJson(json: String): T
    fun <T> toJson(value: T): String
    fun <T : Enum<T>> String.parse(enumClass: Class<T>): T
}
```

This allows validators to leverage the application's JSON parser for complex transformations, particularly for request bodies.

**Example using the Parser**:

```kotlin
val ofUser = stringValidator<User>("user") {
    parser.fromJson<User>(it)
}
```

This is particularly powerful for body validators, allowing seamless conversion between JSON strings and domain objects.

## Custom Validators

While the factory functions cover most use cases, you can also implement the `Validator` interface directly for complete control:

```kotlin
object UserIdValidator : Validator<String, UserId> {
    override val description = "Valid user ID"
    override val regex = """^[a-zA-Z0-9]{8,12}$""".toRegex()
    override val parse: Parser.(Collection<String>) -> UserId = { collection ->
        val value = collection.first()
        // Custom validation logic
        if (!userRepository.exists(value)) {
            throw IllegalArgumentException("User ID does not exist")
        }
        UserId(value)
    }
}
```

This approach is useful when:
- You need complex validation logic
- You want to encapsulate validation in a self-contained object
- You need to inject dependencies (like repositories) into the validator

## Validator Internals

Let's explore what happens when a validator is used with a parameter:

```kotlin
val userId by path(ofUUID)
```

Here's the sequence of events:

1. The `path` function creates a `Parameter` object, storing the validator
2. When a request arrives, Snitch extracts the raw path parameter value
3. The validator's regex is checked against the value
4. If the regex matches, the parse function is called
5. The parse function converts the string to a UUID
6. The result is cached and made available via `request[userId]`

If any step fails, the request processing is halted, and an error response is returned to the client.

## Best Practices

Based on the internal workings of validators, here are some best practices:

1. **Use specific regex patterns**: The more specific your regex, the faster you can reject invalid inputs
   
2. **Keep transformation functions pure**: Avoid side effects in mapper functions for easier testing and reasoning

3. **Provide clear error messages**: When throwing exceptions, include specific details about why validation failed

4. **Define domain-specific validators**: Create validators for your domain types to encapsulate validation logic

5. **Compose validators**: Build complex validators by combining simpler ones

6. **Avoid heavy computation in validators**: Validators run on every request, so keep them efficient

7. **Use the optional() method**: For truly optional parameters, apply `optional()` to your validator instead of handling nullability in mapper functions

## Putting It All Together

Let's see a complete example of a custom validator used in an endpoint:

```kotlin
// Domain type
data class UserId(val value: String)

// Custom validator
val ofUserId = validator<String, UserId>(
    "valid user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    if (it.length < 8 || it.length > 12) {
        throw IllegalArgumentException("User ID must be 8-12 characters long")
    }
    
    if (!it.matches("""^[a-zA-Z0-9]*$""".toRegex())) {
        throw IllegalArgumentException("User ID must contain only letters and numbers")
    }
    
    UserId(it)
}

// Parameter definition
val userId by path(ofUserId)

// Route with validated parameter
GET("users" / userId) isHandledBy {
    // UserId is already validated and transformed
    val id: UserId = request[userId]
    userRepository.findById(id).ok
}
```

This approach ensures:
1. Early validation at the HTTP layer
2. Type-safe access to domain types
3. Clean separation of validation and business logic
4. Clear error messages for API consumers

## Conclusion

The validator DSL in Snitch provides a powerful, type-safe way to transform raw HTTP inputs into domain types. By understanding its internal workings, you can create more robust, maintainable APIs with clear error handling and strong type safety.

Remember that validators aren't just about rejecting invalid inputs—they're about bridging the gap between the untyped world of HTTP and the strongly-typed world of your domain model.

---

## From: Database-Integration-With-Exposed.md

# In-Depth: Database Integration with Exposed

This document provides an in-depth exploration of Snitch's integration with the Exposed SQL library, focusing on the technical aspects and internal workings of the implementation.

## Architecture Overview

Snitch's Exposed integration consists of three main modules:

1. **exposed**: Core module with the foundational abstractions and utilities
2. **exposed-h2**: H2 database adapter for testing and development
3. **exposed-postgres**: PostgreSQL adapter for production use

The architecture follows these design principles:

- **Type safety**: Leveraging Kotlin's type system for database operations
- **Automatic mapping**: Using reflection to minimize boilerplate
- **Transaction management**: Integrating with Snitch's routing system
- **Database agnosticism**: Core abstractions work with any supported database

## Core Components

### DatabaseConnectionConfig

The `DatabaseConnectionConfig` class serves as the primary configuration point:

```kotlin
data class DatabaseConnectionConfig(
    val url: String,
    val driver: String,
    val user: String,
    val password: String,
    val setupConnection: ((Database) -> Unit)? = null,
    val databaseConfig: DatabaseConfig? = null,
    val manager: (Database) -> TransactionManager = { db -> TransactionManager.manager.defaultDatabase = db }
)
```

This configuration is used to establish a database connection and configure transaction management.

### ExposedModule

The `ExposedModule` provides dependency injection support via Shank:

```kotlin
object ExposedModule {
    private val connectionProvider = single<DatabaseConnectionConfig, Database> { config ->
        Database.connect(
            url = config.url,
            driver = config.driver,
            user = config.user,
            password = config.password,
            databaseConfig = config.databaseConfig
        ).also {
            config.setupConnection?.invoke(it)
            config.manager(it)
        }
    }

    fun connection(config: DatabaseConnectionConfig): Database = connectionProvider(config)
}
```

This creates a singleton database connection that can be shared throughout your application.

### Transaction Management

The `withTransaction` decorator integrates transactions with route handlers:

```kotlin
fun Routes.withTransaction(builder: TransactionalRoutes.() -> Unit) {
    val routes = TransactionalRoutes().apply(builder)
    routes.endpoints.forEach { addEndpoint(it) }
}

class TransactionalRoutes : Routes() {
    override fun <T : Any> addEndpoint(endpoint: Endpoint<T>) {
        val wrappedHandler = { request: Request<T> ->
            transaction {
                endpoint.handler(request)
            }
        }
        super.addEndpoint(endpoint.copy(handler = wrappedHandler))
    }
}
```

This approach ensures that:
1. Each route handler executes within a transaction
2. Exceptions trigger automatic rollback
3. Successful execution commits the transaction

### Object Mapping

The core of the automatic mapping system resides in the `Mapping.kt` file, which provides:

1. **Type Conversion**: Converting between domain models and database entities
2. **Property Mapping**: Matching properties by name between objects
3. **Value Class Handling**: Supporting Kotlin's value classes
4. **Custom Mapping**: Allowing user-defined conversions

The mapping system uses Kotlin reflection to:
- Inspect property names and types
- Match database columns to model properties
- Perform appropriate type conversions
- Handle nested objects and collections

Key extension functions:

```kotlin
// Convert between similar objects
inline fun <reified R : Any> Any.to(): R

// Map ResultRow to domain model
fun <T : ColumnSet, R : Any> ResultRow.to(from: T, to: KClass<R>): R

// Insert domain model into table
fun <R : Any> Table.insert(value: R, customize: Table.(UpdateBuilder<*>) -> Unit = {}): InsertStatement<Number>

// Find all entities and map to domain model
inline fun <reified R : Any> Table.findAll(e: SqlExpressionBuilder.() -> Op<Boolean> = { Op.TRUE })
```

### Schema Management

The `ExposedDatabase` class provides utilities for schema management:

```kotlin
class ExposedDatabase(
    private val connection: Database,
    private vararg val tables: Table
) {
    fun createSchema() = transaction(connection) {
        SchemaUtils.create(*tables)
    }
    
    fun dropSchema() = transaction(connection) {
        SchemaUtils.drop(*tables)
    }
    
    fun addMissingColumns() = transaction(connection) {
        SchemaUtils.addMissingColumnsStatements(*tables)
    }
}
```

## Database-Specific Implementations

### H2 Integration

The `exposed-h2` module provides a simplified API for H2 database connections:

```kotlin
fun h2ConnectionConfig(
    name: String = "test",
    inMemory: Boolean = true,
    directory: String? = null,
    url: String = buildH2Url(name, inMemory, directory),
    user: String = "sa",
    password: String = ""
): DatabaseConnectionConfig {
    return DatabaseConnectionConfig(
        url = url,
        driver = "org.h2.Driver",
        user = user,
        password = password
    )
}

private fun buildH2Url(name: String, inMemory: Boolean, directory: String?): String {
    return if (inMemory) {
        "jdbc:h2:mem:$name;DB_CLOSE_DELAY=-1;"
    } else {
        "jdbc:h2:${directory ?: "~"}/$name;DB_CLOSE_DELAY=-1;"
    }
}
```

This provides sensible defaults for H2 databases, particularly useful for:
- Unit and integration testing with in-memory databases
- Development environments with quick setup
- Simple applications that don't need a separate database server

### PostgreSQL Integration

The `exposed-postgres` module supports PostgreSQL connections with advanced options:

```kotlin
fun postgresConnectionConfig(
    host: String = "localhost",
    port: Int = 5432,
    database: String,
    user: String,
    password: String,
    properties: Map<String, String> = emptyMap(),
    url: String = buildPostgresUrl(host, port, database, properties),
    dataSource: DataSource? = null
): DatabaseConnectionConfig {
    return if (dataSource != null) {
        DatabaseConnectionConfig(
            url = url,
            driver = "org.postgresql.Driver",
            user = user,
            password = password,
            setupConnection = { db ->
                (db as DatabaseImpl).config.apply {
                    this.dataSource = dataSource
                }
            }
        )
    } else {
        DatabaseConnectionConfig(
            url = url,
            driver = "org.postgresql.Driver",
            user = user,
            password = password
        )
    }
}
```

This supports:
- Standard PostgreSQL connections
- Connection pooling via HikariCP or other DataSource implementations
- Advanced connection properties for tuning performance and security

## Technical Deep Dive

### Automatic Mapping Implementation

The core mapping functionality uses Kotlin reflection to inspect classes and convert between them:

```kotlin
fun <R : Any> Any.to(target: KClass<R>): R {
    if (this::class == target) return this as R
    if (target.isValue) return mapValueClass(target, this) as R

    val members = this::class.members.toList().map { it.name to it }.toMap()
    val constructor = target.constructors.first()
    
    try {
        val args = constructor.parameters.map {
            val sourceValue = members[it.name]?.call(this)?.unwrap()
            val targetClass = it.type.classifier as KClass<*>

            it to if (sourceValue == null) {
                null
            } else {
                // Handle different mapping scenarios...
            }
        }
        
        val instance = constructor.callBy(
            args.toMap().filterNot { (!it.key.type.isMarkedNullable && it.value == null) }
        )
        return instance
    } catch (e: Exception) {
        println("Error mapping $this to ${target}")
        throw e
    }
}
```

This complex system handles various mapping scenarios:
1. Direct mapping of identical types
2. Value class mapping
3. Collection mapping (List/Set)
4. Custom mapping via the AutoMapper
5. Recursive mapping of nested objects

### Transaction Implementation

The transaction integration leverages Exposed's transaction API:

```kotlin
inline fun <T> transaction(
    statement: Transaction.() -> T
): T {
    return org.jetbrains.exposed.sql.transactions.transaction {
        try {
            statement()
        } catch (e: Exception) {
            rollback()
            throw e
        }
    }
}
```

When combined with Snitch's routing:

```kotlin
class TransactionalRoutes : Routes() {
    override fun <T : Any> addEndpoint(endpoint: Endpoint<T>) {
        val wrappedHandler = { request: Request<T> ->
            transaction {
                endpoint.handler(request)
            }
        }
        super.addEndpoint(endpoint.copy(handler = wrappedHandler))
    }
}
```

This ensures that:
1. Every request handler executes within a transaction
2. Exceptions trigger transaction rollback
3. Successful execution commits the transaction
4. The transaction spans the entire request handling process

### Value Class Support

Value classes receive special handling to maintain type safety:

```kotlin
private fun mapValueClass(targetClass: KClass<*>, sourceValue: Any) = try {
    val first = targetClass.constructors.first()
    val kClass = first.parameters.first().type.classifier as KClass<*>
    if (kClass != sourceValue::class) {
        (
            mapping[sourceValue::class]?.from?.invoke(sourceValue)
                ?: mapping[kClass]?.to?.invoke(sourceValue)
            )
            ?.wrap(targetClass)
    } else {
        first.call(sourceValue)
    }
} catch (e: Exception) {
    println("Error instantiating value $sourceValue to $targetClass")
    throw e
}

fun Any.unwrap() = if (this::class.isValue) this::class.members.first().call(this) else this
fun Any.wrap(target: KClass<*>) = if (target.isValue) target.constructors.first().call(this) else this
```

This allows transparent conversion between primitive types and their value class wrappers.

### Custom Type Mapping System

The `AutoMapper` provides a registry for custom type conversions:

```kotlin
object AutoMapper {
    val mapping = mutableMapOf<KClass<*>, Mapper<Any, Any>>()

    inline fun <reified FROM, TO> customMapping(noinline from: (FROM) -> TO, noinline to: (TO) -> FROM) {
        mapping[FROM::class] = Mapper(from, to) as Mapper<Any, Any>
    }
}

data class Mapper<FROM, TO>(val from: (FROM) -> TO, val to: (TO) -> FROM)
```

This registry is consulted during the mapping process to apply custom conversions when needed.

## Performance Considerations

### Connection Pooling

For production use, connection pooling is essential:

```kotlin
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource

fun createConnectionPool(
    url: String,
    user: String,
    password: String,
    maxPoolSize: Int = 10
): DataSource {
    val config = HikariConfig().apply {
        jdbcUrl = url
        username = user
        this.password = password
        maximumPoolSize = maxPoolSize
        isAutoCommit = false
        transactionIsolation = "TRANSACTION_REPEATABLE_READ"
    }
    return HikariDataSource(config)
}

// Use with PostgreSQL
val dataSource = createConnectionPool(
    url = "jdbc:postgresql://localhost:5432/myapp",
    user = "dbuser",
    password = "password"
)

val config = postgresConnectionConfig(
    url = "jdbc:postgresql://localhost:5432/myapp",
    user = "dbuser",
    password = "password",
    dataSource = dataSource
)
```

### Batch Operations

For bulk operations, batch processing is significantly more efficient:

```kotlin
// Individual inserts - slow for large datasets
userList.forEach { user ->
    Users.insert(user)
}

// Batch insert - much faster
Users.batchInsert(userList) { user ->
    this[Users.name] = user.name
    this[Users.email] = user.email
}
```

### Query Optimization

Strategic querying can dramatically improve performance:

```kotlin
// Inefficient: Loads all users then filters in memory
val users = transaction {
    Users.findAll<User>()
}.filter { it.age > 30 }

// Efficient: Filters at the database level
val users = transaction {
    Users.findAll<User> { Users.age greater 30 }
}

// Inefficient: N+1 query problem
val usersWithPosts = transaction {
    Users.findAll<User>().map { user ->
        val posts = Posts.findAll<Post> { Posts.userId eq user.id } // One query per user!
        UserWithPosts(user, posts)
    }
}

// More efficient: Join in a single query
val usersWithPosts = transaction {
    (Users innerJoin Posts)
        .select { Posts.userId eq Users.id }
        .groupBy { it[Users.id] }
        .map { (userId, rows) ->
            val user = Users.findOne<User> { Users.id eq userId }
            val posts = rows.map { Posts.to<Post>(it) }
            UserWithPosts(user, posts)
        }
}
```

## Integration with Testing

The Exposed modules are designed to integrate seamlessly with testing:

```kotlin
class UserRepositoryTest {
    private lateinit var repository: UserRepository
    
    @BeforeEach
    fun setup() {
        // Create a unique in-memory database for test isolation
        val config = h2ConnectionConfig(name = "test_${UUID.randomUUID()}")
        ExposedModule.connection(config)
        
        transaction {
            SchemaUtils.create(Users)
        }
        
        repository = UserRepository()
    }
    
    @Test
    fun `create user stores data correctly`() {
        // Arrange
        val user = User("Test User", "test@example.com")
        
        // Act
        val id = repository.createUser(user)
        
        // Assert
        val retrievedUser = repository.getUserById(id)
        assertEquals("Test User", retrievedUser?.name)
        assertEquals("test@example.com", retrievedUser?.email)
    }
    
    @AfterEach
    fun tearDown() {
        transaction {
            SchemaUtils.drop(Users)
        }
    }
}
```

This approach provides:
- Test isolation with unique databases
- Fast test execution with in-memory storage
- Realistic database behavior for integration tests

## Advanced Usage

### Custom Column Types

Exposed supports custom column types for complex data:

```kotlin
// Define a column type for storing JSONs
class JsonColumnType<T : Any>(
    private val klass: KClass<T>,
    private val objectMapper: ObjectMapper
) : ColumnType() {
    override fun sqlType(): String = "TEXT"
    
    override fun valueFromDB(value: Any): T = when(value) {
        is String -> objectMapper.readValue(value, klass.java)
        else -> error("Unexpected value: $value of ${value::class.qualifiedName}")
    }
    
    override fun notNullValueToDB(value: Any): String = objectMapper.writeValueAsString(value)
}

// Use it in a table
object Users : Table("users") {
    val id = integer("id").autoIncrement()
    val name = varchar("name", 255)
    val preferences = registerColumn<UserPreferences>("preferences", JsonColumnType(UserPreferences::class, objectMapper))
    
    override val primaryKey = PrimaryKey(id)
}
```

### Database Migration Strategies

For evolving schemas, you can use the Exposed utilities:

```kotlin
class DatabaseMigration(
    private val connection: Database,
    private vararg val tables: Table
) {
    fun migrateSchema() = transaction(connection) {
        // Get statements to add missing columns
        val statements = SchemaUtils.addMissingColumnsStatements(*tables)
        
        // Execute each statement
        statements.forEach { statement ->
            exec(statement)
        }
        
        // Check for any table structure changes
        for (table in tables) {
            val existingIndices = exec("SHOW INDEX FROM ${table.tableName}") { rs ->
                val indices = mutableListOf<String>()
                while (rs.next()) {
                    indices.add(rs.getString("Column_name"))
                }
                indices
            } ?: emptyList()
            
            // Create any missing indices
            table.indices.forEach { index ->
                val columns = index.columns.joinToString(", ") { it.name }
                if (!existingIndices.contains(columns)) {
                    val indexType = if (index.unique) "UNIQUE" else ""
                    exec("CREATE $indexType INDEX idx_${table.tableName}_${index.name} ON ${table.tableName}($columns)")
                }
            }
        }
    }
}
```

### Repository Pattern Implementation

A clean repository implementation with Snitch Exposed:

```kotlin
interface UserRepository {
    fun findById(id: Int): User?
    fun findAll(): List<User>
    fun create(user: User): Int
    fun update(user: User): Boolean
    fun delete(id: Int): Boolean
}

class ExposedUserRepository : UserRepository {
    override fun findById(id: Int): User? = transaction {
        Users.findOneOrNull<UserEntity> { Users.id eq id }
            ?.let { mapToDomain(it) }
    }
    
    override fun findAll(): List<User> = transaction {
        Users.findAll<UserEntity>()
            .map { mapToDomain(it) }
    }
    
    override fun create(user: User): Int = transaction {
        val entity = mapToEntity(user)
        Users.insert(entity)[Users.id]
    }
    
    override fun update(user: User): Boolean = transaction {
        val entity = mapToEntity(user)
        val updated = Users.updateWhere(entity) { Users.id eq entity.id }
        updated > 0
    }
    
    override fun delete(id: Int): Boolean = transaction {
        val deleted = Users.deleteWhere { Users.id eq id }
        deleted > 0
    }
    
    private fun mapToDomain(entity: UserEntity): User = User(
        id = entity.id,
        name = entity.name,
        email = entity.email,
        isActive = entity.status == "ACTIVE"
    )
    
    private fun mapToEntity(domain: User): UserEntity = UserEntity(
        id = domain.id,
        name = domain.name,
        email = domain.email,
        status = if (domain.isActive) "ACTIVE" else "INACTIVE"
    )
}
```

## Conclusion

Snitch's Exposed integration provides a powerful, flexible foundation for database operations in your applications. The combination of type safety, automatic mapping, and seamless transaction management creates a developer-friendly experience while maintaining the performance and flexibility needed for production applications.

By understanding the internal workings of this integration, you can leverage its full capabilities and customize it to fit your specific requirements.

## References

- [Exposed GitHub Repository](https://github.com/JetBrains/Exposed)
- [Exposed Wiki](https://github.com/JetBrains/Exposed/wiki)
- [H2 Database Documentation](https://h2database.com/html/main.html)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [HikariCP Connection Pool](https://github.com/brettwooldridge/HikariCP)

---

## From: Mastering-Snitch-BeforeAfter.md

# Before and After Actions

The Before and After action mechanism in Snitch provides a powerful way to run code around your route handlers. It allows you to execute logic before a request is processed and after a response is generated, which is useful for cross-cutting concerns such as logging, authentication, authorization, and performance monitoring.

## Understanding Before and After Actions

Before and After actions are similar to middleware in other frameworks. They allow you to:

1. **Before Actions**: Execute code before the route handler is called
2. **After Actions**: Execute code after the route handler has completed and a response is generated

These actions have full access to the request context, including path, query, and header parameters, and can also modify the response returned by the handler.

## Route-Level Actions

Route-level actions are applied to individual routes, allowing for fine-grained control over which routes need specific pre- or post-processing.

### Defining Before Actions

```kotlin
GET("users" / userId)
    .doBefore { 
        // Code to run before the handler
        logger.info("Accessing user: ${request[userId]}")
    }
    .isHandledBy {
        // Handler code
        userRepository.getUser(request[userId]).ok
    }
```

### Defining After Actions

```kotlin
GET("users" / userId)
    .doAfter { 
        // Code to run after the handler has generated a response
        logger.info("User access completed with status: ${response.statusCode}")
    }
    .isHandledBy {
        // Handler code
        userRepository.getUser(request[userId]).ok
    }
```

### Combining Before and After Actions

You can chain multiple before and after actions on a single route:

```kotlin
GET("users" / userId)
    .doBefore { logger.info("Request started") }
    .doBefore { metrics.incrementRequestCount() }
    .doAfter { metrics.recordResponseTime() }
    .doAfter { logger.info("Request completed") }
    .isHandledBy {
        userRepository.getUser(request[userId]).ok
    }
```

## Global Actions

Global actions let you apply the same logic to multiple routes or across your entire application, reducing code duplication.

### Applying to Multiple Routes

```kotlin
applyToAll_({
    GET("users" / userId) isHandledBy getUserHandler
    POST("users") with body<CreateUserRequest>() isHandledBy createUserHandler
    PUT("users" / userId) with body<UpdateUserRequest>() isHandledBy updateUserHandler
}) {
    doBefore { 
        logger.info("${request.method} ${request.path} started")
    }
    doAfter { 
        logger.info("${request.method} ${request.path} completed with status ${response.statusCode}")
    }
}
```

## Execution Order

Understanding the execution order of before and after actions is crucial for building correct, predictable behavior.

### Order for Before Actions

1. **Before actions execute in reverse declaration order** (last declared, first executed)
2. **Global before actions execute before route-level before actions**

For example:

```kotlin
applyToAll_({
    GET("foo")
        .doBefore { /* Route before 1 */ }
        .doBefore { /* Route before 2 */ }
        .isHandledBy { /* Handler */ }
}) {
    doBefore { /* Global before 1 */ }
    doBefore { /* Global before 2 */ }
}
```

Execution order:
1. Global before 2
2. Global before 1
3. Route before 2
4. Route before 1
5. Handler

### Order for After Actions

1. **After actions execute in declaration order** (first declared, first executed)
2. **Route-level after actions execute before global after actions**

For example:

```kotlin
applyToAll_({
    GET("foo")
        .doAfter { /* Route after 1 */ }
        .doAfter { /* Route after 2 */ }
        .isHandledBy { /* Handler */ }
}) {
    doAfter { /* Global after 1 */ }
    doAfter { /* Global after 2 */ }
}
```

Execution order:
1. Handler
2. Route after 1
3. Route after 2
4. Global after 1
5. Global after 2

### Complete Execution Flow

The complete execution flow for a request is:

1. Global before actions (in reverse declaration order)
2. Route-level before actions (in reverse declaration order)
3. Route handler
4. Route-level after actions (in declaration order)
5. Global after actions (in declaration order)

## Error Handling

The behavior of before and after actions differs slightly when errors occur:

### Exceptions in Before Actions

When an exception occurs in a before action:

1. The exception is caught and processed by any registered exception handlers
2. The route handler is **not** executed
3. After actions are **not** executed automatically (as of the current implementation)

```kotlin
GET("foo")
    .doBefore { 
        throw RuntimeException("Error in before action")
    }
    .doAfter { 
        // Currently not executed when before action throws an exception
    }
    .isHandledBy {
        // Not executed when before action throws an exception
    }
```

### Exceptions in Handlers

When an exception occurs in a route handler:

1. The exception is caught and processed by any registered exception handlers
2. After actions are **not** executed automatically (as of the current implementation)

```kotlin
// Register exception handler
handleException(RuntimeException::class) {
    logger.error("Exception caught: ${it.message}")
    "Error occurred".serverError()
}

GET("foo")
    .doBefore { /* Executes normally */ }
    .doAfter { 
        // Currently not executed when handler throws an exception
    }
    .isHandledBy {
        throw RuntimeException("Error in handler")
    }
```

> **Note**: According to the test file, there's a TODO comment indicating that after actions don't currently run in case of exceptions in before actions or handlers, but this behavior may be implemented in future versions.

## Common Use Cases

Before and after actions are ideal for many cross-cutting concerns:

### Logging

```kotlin
val Router.withLogging get() = transformEndpoints {
    doBefore { 
        logger.info("Request started: ${request.method} ${request.path}")
        request.attributes["startTime"] = System.currentTimeMillis()
    }
    doAfter {
        val startTime = request.attributes["startTime"] as Long
        val duration = System.currentTimeMillis() - startTime
        logger.info("Request completed: ${request.method} ${request.path} - ${response.statusCode} (${duration}ms)")
    }
}

// Usage
withLogging {
    GET("users") isHandledBy { /* handler */ }
    POST("users") isHandledBy { /* handler */ }
}
```

### Authentication

```kotlin
val accessToken by header(validJwtValidator)

val Router.authenticated get() = transformEndpoints {
    with(queries(accessToken)).doBefore {
        val token = request[accessToken]
        if (token is Authentication.Unauthenticated) {
            return@doBefore "Unauthorized".unauthorized()
        }
    }
}

// Usage
authenticated {
    GET("profile") isHandledBy getUserProfile
    PUT("settings") isHandledBy updateUserSettings
}
```

### Request Metrics

```kotlin
val Router.withMetrics get() = transformEndpoints {
    doBefore {
        metrics.incrementRequestCount(request.path)
        request.attributes["startTime"] = System.nanoTime()
    }
    doAfter {
        val duration = System.nanoTime() - (request.attributes["startTime"] as Long)
        metrics.recordResponseTime(request.path, duration)
        metrics.recordStatusCode(request.path, response.statusCode.code)
    }
}
```

### Database Transactions

```kotlin
val Router.withTransaction get() = transformEndpoints {
    doBefore {
        transaction.begin()
    }
    doAfter {
        if (response.isSuccessful()) {
            transaction.commit()
        } else {
            transaction.rollback()
        }
    }
}

// Usage
withTransaction {
    POST("orders") isHandledBy createOrder
    PUT("orders" / orderId) isHandledBy updateOrder
}
```

## Best Practices

### 1. Keep Before and After Actions Focused

Each before and after action should have a single responsibility. Instead of having one big action that does multiple things, chain smaller, focused actions:

```kotlin
// Good
GET("users")
    .doBefore { validateRequest() }
    .doBefore { authenticate() }
    .doBefore { authorize() }
    .doAfter { logResponse() }
    .doAfter { collectMetrics() }
    .isHandledBy { /* handler */ }

// Avoid
GET("users")
    .doBefore { 
        validateRequest()
        authenticate()
        authorize()
    }
    .doAfter { 
        logResponse()
        collectMetrics()
    }
    .isHandledBy { /* handler */ }
```

### 2. Use Global Actions for Cross-Cutting Concerns

When actions need to be applied across multiple routes or your entire application, use global actions to reduce duplication:

```kotlin
// Error logging applied to all routes
applyToAll_({
    // All your routes
}) {
    doAfter { 
        if (response.statusCode.isError()) {
            logger.error("Error response: ${response.statusCode} - ${response.body}")
        }
    }
}
```

### 3. Be Careful with Response Modification

After actions have the ability to modify the response. Use this power with care:

```kotlin
GET("users")
    .doAfter { 
        // Only modify the response when needed
        if (response.statusCode.isSuccess() && response is JsonResponse) {
            // Add additional info to JSON response
            response.addAttribute("serverTime", System.currentTimeMillis())
        }
    }
    .isHandledBy { /* handler */ }
```

### 4. Handle Errors Explicitly

Be explicit about error handling in your before and after actions:

```kotlin
GET("users")
    .doBefore { 
        try {
            // Risky operation
        } catch (e: Exception) {
            logger.error("Error in before action", e)
            return@doBefore "An error occurred".serverError()
        }
    }
    .isHandledBy { /* handler */ }
```

### 5. Be Mindful of Execution Order

Remember that before actions execute in reverse order and after actions execute in declaration order:

```kotlin
GET("users")
    // Executes third
    .doBefore { logger.info("Authorization check") }
    // Executes second
    .doBefore { logger.info("Authentication check") }
    // Executes first
    .doBefore { logger.info("Request validation") }
    
    // Executes first after handler
    .doAfter { logger.info("Log response") }
    // Executes second after handler
    .doAfter { logger.info("Collect metrics") }
    
    .isHandledBy { /* handler */ }
```

## Conclusion

The Before and After action mechanism in Snitch provides a powerful way to organize cross-cutting concerns in your HTTP application. By understanding how these actions are executed and how they interact with exception handling, you can build clean, maintainable, and robust applications.

Remember that actions should be focused, reusable, and predictable. Use global actions for common functionality and route-level actions for specific requirements. Be aware of the current limitations in error handling, and always consider the execution order when designing your action chains.

---

## From: Mastering-Snitch-Conditions.md

# Conditions

Conditions are one of Snitch's most powerful features, allowing you to implement sophisticated access control and request validation with minimal code. This tutorial will guide you through everything you need to know about conditions, from basic usage to advanced patterns.

## Understanding Conditions

In Snitch, a condition is a predicate that evaluates a request and determines whether it should proceed or be rejected. Conditions are represented by the `Condition` interface, which has three key components:

1. **Description**: A human-readable description of what the condition checks
2. **Transform function**: A function that can modify an endpoint (usually for documentation purposes)
3. **Check function**: The actual logic that evaluates the request

When a condition is applied to an endpoint using `onlyIf`, it becomes part of the request processing pipeline. If the condition evaluates to `Successful`, the request proceeds; if it evaluates to `Failed`, the request is rejected with the specified error response.

## Basic Condition Usage

The simplest way to use conditions is with the `onlyIf` method on an endpoint:

```kotlin
GET("resource" / resourceId) onlyIf isResourceOwner isHandledBy { getResource() }
```

This ensures that the endpoint will only be accessible if the `isResourceOwner` condition evaluates to `Successful`.

## Creating Custom Conditions

You can create custom conditions using the `condition` factory function:

```kotlin
val hasAdminRole = condition("hasAdminRole") {
    val role = (request[accessToken] as? Authentication.Authenticated)?.claims?.role
    
    when (role) {
        Role.ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Admin role required".forbidden())
    }
}
```

The first parameter is the description, which will be used in documentation and error messages. The lambda receives a `RequestWrapper` and should return a `ConditionResult`.

### Parameterized Conditions

You can create reusable condition factories that accept parameters:

```kotlin
fun hasMinimumAge(minAge: Int) = condition("hasMinimumAge($minAge)") {
    val userAge = userRepository.getAge(request[userId])
    
    if (userAge >= minAge) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("User must be at least $minAge years old".forbidden())
    }
}

// Usage
GET("adult-content") onlyIf hasMinimumAge(18) isHandledBy { getAdultContent() }
```

## Logical Operators

Snitch conditions support three logical operators:

### AND (`and`)

The `and` operator creates a condition that succeeds only if both conditions succeed:

```kotlin
val canAccessResource = isAuthenticated and hasPermission
```

When evaluating an `and` condition, if the first condition fails, the second one is not evaluated (short-circuit evaluation).

### OR (`or`)

The `or` operator creates a condition that succeeds if either condition succeeds:

```kotlin
val canModifyResource = isResourceOwner or hasAdminRole
```

When evaluating an `or` condition, if the first condition succeeds, the second one is not evaluated.

### NOT (`not` or `!`)

The `not` operator inverts a condition:

```kotlin
val isNotLocked = !isResourceLocked
```

You can combine these operators to create complex access rules:

```kotlin
val canEditDocument = isAuthenticated and (isDocumentOwner or hasEditorRole) and !isDocumentLocked
```

## Applying Conditions to Route Hierarchies

You can apply conditions to entire route hierarchies using the `onlyIf` block:

```kotlin
onlyIf(isAuthenticated) {
    GET("profile") isHandledBy { getProfile() }
    
    onlyIf(hasAdminRole) {
        GET("admin/dashboard") isHandledBy { getDashboard() }
        GET("admin/users") isHandledBy { getUsers() }
    }
}
```

In this example, all routes require authentication, and the admin routes additionally require the admin role.

## Short-Circuit Evaluation

Snitch's condition operators use short-circuit evaluation for efficiency:

- For `and`, if the first condition fails, the second is not evaluated
- For `or`, if the first condition succeeds, the second is not evaluated

This is particularly useful when you have conditions with side effects or expensive operations:

```kotlin
// The database query will only run if the user is authenticated
val canAccessResource = isAuthenticated and hasPermissionInDatabase
```

You can test this behavior:

```kotlin
@Test
fun `short-circuits condition evaluation`() {
    var secondConditionEvaluated = false
    
    val trackingCondition = condition("tracking") {
        secondConditionEvaluated = true
        ConditionResult.Successful
    }
    
    given {
        GET("short-circuit")
            .onlyIf(alwaysFalse and trackingCondition)
            .isHandledBy { "".ok }
    } then {
        GET("/short-circuit").expectCode(403)
        assert(!secondConditionEvaluated) { "Second condition should not have been evaluated" }
    }
}
```

## Error Handling and Custom Responses

When a condition fails, it returns a `ConditionResult.Failed` with an error response. You can customize this response:

```kotlin
val isResourceOwner = condition("isResourceOwner") {
    if (principal.id == request[resourceId]) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed(
            ErrorResponse(
                code = "FORBIDDEN",
                message = "You don't have permission to access this resource",
                details = mapOf("resourceId" to request[resourceId])
            ).error(StatusCodes.FORBIDDEN)
        )
    }
}
```

This allows you to provide detailed, context-specific error messages to clients.

## Best Practices

### 1. Keep Conditions Focused

Each condition should check one specific thing. This makes them more reusable and easier to understand.

### 2. Use Descriptive Names

Choose condition names that clearly describe what they check:

```kotlin
// Good
val hasAdminRole = condition("hasAdminRole") { ... }

// Not as good
val adminCheck = condition("adminCheck") { ... }
```

### 3. Leverage Composition

Build complex access rules by composing simple conditions:

```kotlin
val canEditDocument = isAuthenticated and isDocumentOwner and !isDocumentLocked
```

### 4. Provide Helpful Error Messages

When a condition fails, the error message should help the client understand why:

```kotlin
ConditionResult.Failed("Resource not found or you don't have permission to access it".forbidden())
```

### 5. Document Conditions

Use the description parameter to document what the condition checks:

```kotlin
val hasPermission = condition("User has permission to access the resource") { ... }
```

This description will appear in the generated API documentation.

## Real-World Examples

### Authentication and Authorization

```kotlin
// Authentication
val isAuthenticated = condition("isAuthenticated") {
    when (request[accessToken]) {
        is Authentication.Authenticated -> ConditionResult.Successful
        else -> ConditionResult.Failed("Authentication required".unauthorized())
    }
}

// Authorization
val hasAdminRole = condition("hasAdminRole") {
    val auth = request[accessToken] as? Authentication.Authenticated
        ?: return@condition ConditionResult.Failed("Authentication required".unauthorized())
    
    when (auth.claims.role) {
        Role.ADMIN -> ConditionResult.Successful
        else -> ConditionResult.Failed("Admin role required".forbidden())
    }
}

// Resource ownership
fun isResourceOwner(resourceIdParam: Parameter<String, *>) = condition("isResourceOwner") {
    val auth = request[accessToken] as? Authentication.Authenticated
        ?: return@condition ConditionResult.Failed("Authentication required".unauthorized())
    
    if (auth.claims.userId == request[resourceIdParam]) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("You don't own this resource".forbidden())
    }
}

// Usage
val routes = routes {
    onlyIf(isAuthenticated) {
        GET("profile") isHandledBy { getProfile() }
        
        "resources" / resourceId / {
            GET() onlyIf isResourceOwner(resourceId) isHandledBy { getResource() }
            PUT() onlyIf (isResourceOwner(resourceId) or hasAdminRole) isHandledBy { updateResource() }
            DELETE() onlyIf (isResourceOwner(resourceId) or hasAdminRole) isHandledBy { deleteResource() }
        }
        
        onlyIf(hasAdminRole) {
            GET("admin/dashboard") isHandledBy { getDashboard() }
            GET("admin/users") isHandledBy { getUsers() }
        }
    }
}
```

### Rate Limiting

```kotlin
fun rateLimit(maxRequests: Int, perTimeWindow: Duration) = condition("rateLimit($maxRequests per $perTimeWindow)") {
    val clientIp = request.remoteAddress
    val requestCount = rateLimiter.getRequestCount(clientIp, perTimeWindow)
    
    if (requestCount <= maxRequests) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed(
            ErrorResponse(
                code = "TOO_MANY_REQUESTS",
                message = "Rate limit exceeded. Try again later.",
                details = mapOf(
                    "maxRequests" to maxRequests,
                    "timeWindow" to perTimeWindow.toString(),
                    "retryAfter" to rateLimiter.getRetryAfter(clientIp)
                )
            ).error(StatusCodes.TOO_MANY_REQUESTS)
        )
    }
}

// Usage
onlyIf(rateLimit(100, Duration.ofMinutes(1))) {
    POST("api/v1/messages") isHandledBy { sendMessage() }
}
```

### Feature Flags

```kotlin
fun featureEnabled(featureName: String) = condition("featureEnabled($featureName)") {
    if (featureFlagService.isEnabled(featureName)) {
        ConditionResult.Successful
    } else {
        ConditionResult.Failed("Feature not available".notFound())
    }
}

// Usage
GET("new-feature") onlyIf featureEnabled("new-feature") isHandledBy { useNewFeature() }
```

By mastering Snitch's condition system, you can implement sophisticated access control and request validation with minimal code, keeping your routes clean and focused on business logic. 

---

## From: Mastering-Snitch-Decorations.md

# Decorations

Decorations are a powerful feature in Snitch that allow you to modify request handling behavior across multiple routes. They provide a clean, composable way to implement cross-cutting concerns like logging, authentication, transaction management, and more. This tutorial will guide you through everything you need to know about decorations, from basic usage to advanced patterns.

## Understanding Decorations

In Snitch, a decoration is a higher-order function that wraps around route handlers to modify their behavior. Decorations can:

1. Execute code before the handler runs
2. Execute code after the handler runs
3. Transform the response from the handler
4. Short-circuit the request and return a response without calling the handler
5. Handle exceptions thrown by the handler

Decorations are implemented using the `decorateWith` function, which creates a decorator that can be applied to routes or route hierarchies.

## Basic Decoration Usage

The simplest way to use decorations is to apply them to a route or route hierarchy:

```kotlin
val logged = decorateWith {
    val method = request.method.name
    val path = request.path
    Logger.info("Begin Request: $method $path")
    next().also {
        Logger.info("End Request: $method $path ${it.statusCode.code}")
    }
}

val routes = routes {
    logged {
        GET("hello").isHandledBy { "Hello, world!".ok }
        POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }
    }
}
```

In this example, all requests to `/hello` and `/users` will be logged before and after handling.

## Creating Custom Decorations

You can create custom decorations using the `decorateWith` function:

```kotlin
val withTransaction = decorateWith { 
    transaction { 
        next() 
    } 
}
```

The lambda passed to `decorateWith` receives a `RequestWrapper` implicitly and should call `next()` to execute the next decoration or handler in the chain. It should return a `Response`.

### Parameterized Decorations

You can create reusable decoration factories that accept parameters:

```kotlin
fun withMetricLabel(label: String) = decorateWith {
    val startTime = System.currentTimeMillis()
    val response = next()
    val endTime = System.currentTimeMillis()
    metrics.record(label, endTime - startTime)
    response
}

// Usage
withMetricLabel("user-service") {
    GET("users").isHandledBy { getUsers() }
}
```

## Decoration Composition

One of the most powerful features of Snitch decorations is their composability. You can combine multiple decorations using the `+` operator:

```kotlin
val combinedDecoration = withTransaction + logged

// Execution order:
// 1. withTransaction (applied first)
// 2. logged (applied second)
// 3. handler
```

When decorations are composed, they are applied from right to left. In the example above, the execution order would be:

1. `withTransaction`
2. `logged`
3. The actual handler

This means that the request flows through the decorations in the order they are composed, and the response flows back in the reverse order.

### Composition Properties

Decoration composition has several important properties:

1. **Associativity**: `(a + b) + c` is equivalent to `a + (b + c)`
2. **Identity**: There exists an identity decoration that, when composed with any decoration, yields the original decoration
3. **Right-to-left evaluation**: In `a + b + c`, decoration `c` is applied first, then `b`, then `a`

These properties make decorations a powerful tool for building complex middleware chains.

## Nesting Decorations

In addition to composition, decorations can also be nested:

```kotlin
logged {
    withTransaction {
        GET("users").isHandledBy { getUsers() }
    }
}
```

When decorations are nested, they are applied from outside to inside. In the example above, the execution order would be:

1. `logged`
2. `withTransaction`
3. The actual handler

This is different from composition, where the order is right to left.

## Decoration Order and Execution Flow

Understanding the execution flow of decorations is crucial for using them effectively. Let's look at a more complex example:

```kotlin
// Composition
(decoration1 + decoration2) {
    // Nesting
    decoration3 {
        GET("hello").isHandledBy { "Hello, world!".ok }
    }
}
```

In this example, the execution order would be:

1. `decoration2` (from composition, right to left)
2. `decoration1` (from composition, right to left)
3. `decoration3` (from nesting, outside to inside)
4. The actual handler

And the response would flow back in the reverse order:

1. The actual handler
2. `decoration3`
3. `decoration1`
4. `decoration2`

This allows you to create sophisticated middleware chains with precise control over the execution order.

## Integration with Conditions

Decorations work seamlessly with Snitch's condition system. You can use the `transformEndpoints` function to create decorations that also add parameters and apply conditions:

```kotlin
val authenticated = transformEndpoints {
    with(listOf(accessToken)).decorated {
        when (request[accessToken]) {
            is Authentication.Authenticated -> next()
            is Authentication.Unauthenticated -> UNAUTHORIZED()
        }
    }
}

// Usage
authenticated {
    GET("profile").isHandledBy { getProfile() }
}
```

This approach is particularly useful for authentication and authorization, where you need to both add parameters (like access tokens) and check conditions before proceeding.

## Common Use Cases

### Logging

```kotlin
val logged = decorateWith {
    val method = request.method.name
    val path = request.path
    Logger.info("Begin Request: $method $path")
    next().also {
        Logger.info("End Request: $method $path ${it.statusCode.code}")
    }
}
```

### Authentication

```kotlin
// Define auth token parameter
val authToken by header("X-Auth-Token")

// Authentication decoration
val authenticated = decorateWith(authToken) {
    when (request[authToken]) {
        "user-token" -> next()
        null -> "Unauthorized".unauthorized()
        else -> "Unauthorized".unauthorized()
    }

}

// Role-based authorization
val requireAdmin = decorateWith(authToken) {
    val token = request[authToken]
    if (token == "admin-token") {
        next()
    } else {
        "Forbidden - Admin access required".forbidden()
    }
}

// Usage
authenticated {
    // Public endpoint - just needs authentication
    GET("profile").isHandledBy { "User profile".ok }

    // Admin endpoint - needs both authentication and admin role
    requireAdmin {
        GET("admin/dashboard").isHandledBy { "Admin dashboard".ok }
    }
}
```

### Transaction Management

```kotlin
val withTransaction = decorateWith { 
    transaction { 
        next() 
    } 
}
```

### Error Handling

```kotlin
val handleErrors = decorateWith {
    try {
        next()
    } catch (e: Exception) {
        logger.error("Error handling request: ${e.message}")
        "Internal server error".serverError()
    }
}
```

### Response Transformation

```kotlin
val addCorsHeaders = decorateWith {
    val response = next()
    response.copy(
        headers = response.headers + mapOf(
            "Access-Control-Allow-Origin" to "*",
            "Access-Control-Allow-Methods" to "GET, POST, PUT, DELETE, OPTIONS",
            "Access-Control-Allow-Headers" to "Content-Type, Authorization"
        )
    )
}
```

## Best Practices

### 1. Keep Decorations Focused

Each decoration should handle one specific concern. This makes them more reusable and easier to understand.

### 2. Use Composition for Complex Behavior

Instead of creating complex decorations, compose simple ones:

```kotlin
// Good
val combinedDecoration = logged + withTransaction

// Not as good
val complexDecoration = decorateWith {
    logger().info("Request started")
    transaction { 
        next() 
    }.also {
        logger().info("Request completed")
    }
}
```

### 3. Be Mindful of Decoration Order

The order of decorations matters. For example, if you want to measure the time including transaction overhead, you would do:

```kotlin
val measureTime + withTransaction
```

But if you want to measure only the time spent in the handler, excluding transaction overhead, you would do:

```kotlin
val withTransaction + measureTime
```

### 4. Always Call `next()` Unless Short-Circuiting

If your decoration doesn't call `next()`, the handler will never be executed. This is useful for short-circuiting (e.g., for authentication), but make sure it's intentional.

### 5. Handle Exceptions Appropriately

If your decoration might throw exceptions, consider wrapping the `next()` call in a try-catch block to ensure proper cleanup.

## Real-World Examples

### Authentication and Authorization

Looking at a real-world example from a production codebase:

```kotlin
// Authentication decoration
val authenticated = transformEndpoints {
    with(listOf(accessToken)).decorated {
        when (request[accessToken]) {
            is Authentication.Authenticated -> next()
            is Authentication.Unauthenticated -> UNAUTHORIZED()
        }
    }
}

// Access to user principal and role
val RequestWrapper.principal: UserId get() = 
    (request[accessToken] as Authentication.Authenticated).claims.userId
val RequestWrapper.role: Role get() = 
    (request[accessToken] as Authentication.Authenticated).claims.role

// Condition for checking principal equality
fun principalEquals(param: Parameter<out Any, *>) = condition("Principal equals ${param.name}") {
    if (principal.value == params(param.name)) Successful
    else Failed(FORBIDDEN())
}

// Usage in routes
val usersController = routes {
    withTransaction {
        POST() with body<CreateUserRequest>() isHandledBy createUser
        
        userId / "posts" / {
            authenticated {
                GET() onlyIf principalEquals(userId) isHandledBy getPosts
                POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost
            }
        }
    }
}
```

This example shows how decorations (`withTransaction`, `authenticated`) can be combined with conditions (`principalEquals`) to create a comprehensive authentication and authorization system.

### Logging with Transaction Management

```kotlin
val routes = routes {
    logged {
        withTransaction {
            GET("users").isHandledBy { getUsers() }
            POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }
        }
    }
}
```

### API Versioning

```kotlin
fun withApiVersion(version: Int) = decorateWith {
    request.attributes["apiVersion"] = version
    next()
}

// Usage
val routes = routes {
    withApiVersion(1) {
        GET("api/users").isHandledBy { getUsersV1() }
    }
    
    withApiVersion(2) {
        GET("api/users").isHandledBy { getUsersV2() }
    }
}
```

### Rate Limiting

```kotlin
fun rateLimit(maxRequests: Int, perTimeWindow: Duration) = decorateWith {
    val clientIp = request.undertow.exchange.sourceAddress.address.hostAddress
    val requestCount = rateLimiter.getRequestCount(clientIp, perTimeWindow)
    
    if (requestCount >= maxRequests) {
        return@decorateWith "Rate limit exceeded. Try again later.".error(TOO_MANY_REQUESTS)
    }
    
    rateLimiter.incrementRequestCount(clientIp)
    next()
}

// Usage
rateLimit(2, Duration.ofMinutes(1)) {
    GET("api/messages").isHandledBy { "Messages".ok }
}
```

### Caching

```kotlin
fun cache(ttl: Duration) = decorateWith {
    val cacheKey = "${request.method.name}-${request.path}"
    val cachedResponse = cacheService.get(cacheKey)

    if (cachedResponse != null) {
        return@decorateWith RawHttpResponse(StatusCodes.OK, cachedResponse)
    }

    val response = next()
    cacheService.put(cacheKey, response.value(parser) as String, ttl)
    response
}

// Usage
cache(Duration.ofMinutes(5)) {
    GET("api/products").isHandledBy { getProducts() }
}
```

By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application. By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application. 


---

## From: Mastering-Snitch-Parameters.md

# Parameters

Parameters are a fundamental part of HTTP communication, allowing clients to send data to your server. Snitch provides an expressive, type-safe approach to handling various types of parameters including path parameters, query parameters, headers, and request bodies.

This tutorial will guide you through the complete parameter system in Snitch, from basic usage to advanced validation and transformation techniques.

## Basic Parameter Types

Snitch supports all common HTTP parameter types:

- **Path parameters**: Values embedded in the URL path (e.g., `/users/{userId}`)
- **Query parameters**: Key-value pairs appended to the URL (e.g., `?page=1&limit=10`)
- **Header parameters**: HTTP headers sent with the request
- **Request body**: Data sent in the request payload

Let's see how each is defined and accessed.

## Path Parameters

Path parameters are defined using the `path()` factory function:

```kotlin
// Define a path parameter
val userId by path()
```

Once defined, you can use it in route definitions:

```kotlin
GET("users" / userId) isHandledBy {
    // Access the parameter value with request[userId]
    val userIdValue = request[userId]
    userRepository.findById(userIdValue).ok
}
```

You can also define paths with validation in one line:

```kotlin
// Define a path parameter with validation
val postId by path(ofNonEmptyString, description = "Post identifier")
```

## Query Parameters

Query parameters are defined using the `query()` factory function:

```kotlin
// Define a required query parameter
val searchTerm by query(description = "Term to search for")

// With validation
val limit by query(ofNonNegativeInt, description = "Maximum number of results")
```

Using query parameters in routes:

```kotlin
GET("search") withQuery searchTerm withQuery limit isHandledBy {
    // Access the parameters
    val term = request[searchTerm] // String
    val maxResults = request[limit] // Int
    
    searchService.search(term, maxResults).ok
}
```

## Header Parameters

Header parameters are defined using the `header()` factory function:

```kotlin
// Define a required header parameter
val contentType by header(description = "Content type of the request")

// With validation
val apiVersion by header(ofNonEmptyString, description = "API version to use")
```

Using header parameters:

```kotlin
POST("data") withHeader contentType withHeader apiVersion isHandledBy {
    // Access the headers
    val type = request[contentType]
    val version = request[apiVersion]
    
    // Use the header values
    dataService.processData(request.body(), type, version).created
}
```

## Request Body

Request bodies are handled differently from other parameters. Instead of defining them separately, you declare them directly in the route definition:

```kotlin
// Define a route with a body parameter
POST("users") with body<CreateUserRequest>() isHandledBy {
    // Access the body with the `body` property
    val newUser = body
    
    userService.createUser(newUser.name, newUser.email).created
}
```

For more complex scenarios, you can use the `parsing` function:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    userService.createUser(body.name, body.email).created
}

// Use the handler
POST("users") with body<CreateUserRequest>() isHandledBy createUser
```

## Parameter Validation and Transformation

Snitch parameters are not just for accessing raw values - they also validate and transform the input data. The framework provides several built-in validators:

```kotlin
// String validation
val name by query(ofNonEmptyString)

// Numeric validation
val age by query(ofPositiveInt)
val price by query(ofNonNegativeDouble)

// Boolean validation
val enabled by query(ofBoolean)

// Date validation
val birthdate by query(ofIsoDate)
```

These validators:
1. Check if the input matches expected format
2. Convert the input to the appropriate type
3. Return 400 Bad Request with descriptive error messages if validation fails

## Optional Parameters

Not all parameters are required. For optional parameters, use the `optionalQuery()` and `optionalHeader()` functions:

```kotlin
// Optional parameter without default (can be null)
val sort by optionalQuery(ofNonEmptyString, description = "Sort direction")

// Optional parameter with default value
val page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")
val limit by optionalQuery(ofNonNegativeInt, default = 20, description = "Results per page")
```

When using optional parameters:

```kotlin
GET("users") withQuery page withQuery limit withQuery sort isHandledBy {
    // Access the parameters (with default values applied)
    val pageNum = request[page]     // Int, defaults to 1 if not provided
    val pageSize = request[limit]   // Int, defaults to 20 if not provided
    val sortDir = request[sort]     // String or null if not provided
    
    userService.getUsers(pageNum, pageSize, sortDir).ok
}
```

## Custom Validators

While built-in validators cover many scenarios, you'll often need custom validation logic, especially when working with domain-specific types.

### Creating Custom Validators

Use `stringValidator` or `validator` to create custom validators:

```kotlin
// Simple custom validator for email format
val ofEmail = stringValidator("valid email address", """^[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,}$""".toRegex()) { it }

// Custom validator with transformation to domain type
val ofUserId = stringValidator("valid UUID") { UserId(UUID.fromString(it)) }
```

Using custom validators:

```kotlin
val email by query(ofEmail, description = "User email address")
val userId by path(ofUserId, description = "User identifier")
```

## Domain Type Conversion

Converting raw parameter values to domain types is a best practice. Snitch makes this seamless:

```kotlin
// Define domain types
data class UserId(val value: UUID)
data class OrderStatus(val value: String) {
    init {
        require(value in listOf("PENDING", "COMPLETED", "CANCELLED")) {
            "Invalid order status: $value"
        }
    }
}

// Create validators for domain types
val ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }
val ofOrderStatus = stringValidator("order status") { OrderStatus(it.uppercase()) }

// Use with parameters
val userId by path(ofUserId)
val status by query(ofOrderStatus)
```

## Parameter Naming

By default, parameter names in requests match their property names in code. You can customize this:

```kotlin
// Custom parameter name
val searchQuery by query(name = "q", description = "Search query")
val userIdentifier by path(name = "user_id", description = "User ID")
```

With these definitions:
- The query parameter will be accessed as `?q=search terms`
- The path parameter will be defined as `/users/{user_id}`

## Advanced Parameter Handling

### Handling Empty Values

Control how empty values are treated:

```kotlin
// Empty values treated as missing
val tag by query(emptyAsMissing = true)

// Invalid values treated as missing (for optional parameters)
val count by optionalQuery(ofNonNegativeInt, invalidAsMissing = true, default = 0)
```

### Parameter Visibility in Documentation

Control whether parameters appear in public API documentation:

```kotlin
// Internal parameter not shown in public docs
val debugMode by optionalQuery(ofBoolean, visibility = Visibility.INTERNAL)
```

### Handling Multiple Values

For parameters that may be provided multiple times:

```kotlin
// Define a repeatable parameter
val tags by query(ofStringSet)  // Will collect all values into a Set<String>

// Custom repeatable validator
val ofUserIds = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }
val userIds by query(ofUserIds)  // Will collect all values into a Collection<UserId>
```

## Best Practices

1. **Use Domain Types**: Convert raw strings to meaningful domain types as early as possible.

2. **Validate Thoroughly**: Define validation rules that catch all potential issues before they reach your business logic.

3. **Provide Descriptive Error Messages**: Set clear validator descriptions so clients receive helpful error messages.

4. **Set Sensible Defaults**: For optional parameters, choose default values that make sense for most use cases.

5. **Document Parameters**: Always include a description for parameters to generate comprehensive API documentation.

6. **Consistent Naming**: Use a consistent naming convention for parameter properties.

7. **Explicitly Register Parameters**: Always declare parameter usage with `withQuery`, `withHeader`, etc., even if the validation is done elsewhere.

```kotlin
// Good practice
GET("users") withQuery page withQuery limit isHandledBy { ... }

// Not recommended (parameters not explicitly registered)
GET("users") isHandledBy {
    // Using parameters without registering them
    val pageValue = request.queryParams("page")
}
```

## Complete Example

Here's a complete example demonstrating different parameter types together:

```kotlin
// Domain types
data class UserId(val value: UUID)
data class PostId(val value: String)

// Validators
val ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }
val ofPostId = stringValidator("valid post ID") { PostId(it) }

// Parameters
val userId by path(ofUserId, description = "User identifier")
val postId by path(ofPostId, description = "Post identifier")
val includeComments by query(ofBoolean, description = "Whether to include comments")
val limit by optionalQuery(ofNonNegativeInt, default = 10, description = "Maximum results")
val apiVersion by header(ofNonEmptyString, description = "API version")

// Routes
val userController = routes {
    GET("users" / userId) withHeader apiVersion isHandledBy getUser
    
    GET("users" / userId / "posts") withQuery limit isHandledBy getUserPosts
    
    GET("posts" / postId) withQuery includeComments isHandledBy getPost
}

// Handlers
val getUser by handling {
    val user = userService.getUser(request[userId])
    user.ok
}

val getUserPosts by handling {
    val posts = postService.getUserPosts(
        userId = request[userId],
        limit = request[limit]
    )
    posts.ok
}

val getPost by handling {
    val post = postService.getPost(
        postId = request[postId],
        includeComments = request[includeComments]
    )
    post.ok
}
```

With Snitch's parameter system, you can build robust, type-safe APIs that validate input data before it reaches your business logic, resulting in cleaner code and better error handling.

---

## From: Mastering-Snitch-Validators.md

# Validators

Validators are a core feature of Snitch that ensure your HTTP inputs are properly validated, transformed, and documented. This guide will walk you through everything you need to know about validators, from basic usage to advanced customization.

## Introduction to Validators

In HTTP applications, inputs from requests (path parameters, query parameters, headers, body) are always strings or collections of strings. However, your business logic typically requires strongly-typed values with guaranteed validity. Validators are the bridge that transforms these raw inputs into safe, typed values.

At their core, validators in Snitch serve three main purposes:

1. **Validation**: Ensuring inputs meet specific criteria
2. **Transformation**: Converting strings to appropriate target types
3. **Documentation**: Providing clear descriptions for API documentation

The `Validator<T, R>` interface is defined with two type parameters:
- `T`: The input type (usually `String`)
- `R`: The output type (the type you want to work with in your code)

And three main components:
- `regex`: A regular expression pattern for basic string validation
- `description`: A human-readable description for documentation
- `parse`: A function that transforms validated input into the output type

## Built-in Validators

Snitch comes with a comprehensive set of built-in validators for common use cases:

### Numeric Validators

```kotlin
// Integer validators
val ofInt: Validator<Int, Int>
val ofNonNegativeInt: Validator<Int, Int>
val ofPositiveInt: Validator<Int, Int>
fun ofIntRange(min: Int, max: Int): Validator<Int, Int>

// Decimal validators
val ofDouble: Validator<Double, Double>
fun ofDoubleRange(min: Double, max: Double): Validator<Double, Double>
```

### String Validators

```kotlin
val ofNonEmptyString: Validator<String, String>
val ofNonEmptySingleLineString: Validator<String, String>
fun ofStringLength(minLength: Int, maxLength: Int): Validator<String, String>
val ofAlphanumeric: Validator<String, String>
fun ofRegexPattern(pattern: String, description: String): Validator<String, String>
```

### Special Format Validators

```kotlin
val ofEmail: Validator<String, String>
val ofUrl: Validator<String, URI>
val ofIpv4: Validator<String, String>
val ofPhoneNumber: Validator<String, String>
val ofJson: Validator<String, String>
```

### Date/Time Validators

```kotlin
val ofDate: Validator<String, LocalDate>
val ofDateTime: Validator<String, LocalDateTime>
fun ofDateFormat(format: String): Validator<String, LocalDate>
```

### Collection Validators

```kotlin
val ofStringSet: Validator<String, Set<String>>
val ofNonEmptyStringSet: Validator<String, Set<String>>
```

### Boolean Validators

```kotlin
val ofBoolean: Validator<Boolean, Boolean>  // Handles true/false, yes/no, 1/0
```

### ID Validators

```kotlin
val ofUuid: Validator<String, UUID>
```

### Enum Validators

```kotlin
inline fun <reified E : Enum<*>> ofEnum(): Validator<String, E>
inline fun <reified E : Enum<*>> ofRepeatableEnum(): Validator<String, Collection<E>>
```

## Using Validators with Parameters

Validators are typically used when defining parameters:

```kotlin
// Path parameters
val userId by path(ofNonNegativeInt)
val username by path(ofAlphanumeric)

// Query parameters
val limit by query(ofIntRange(1, 100))
val sortBy by query(ofEnum<SortField>())
val email by query(ofEmail)

// Header parameters
val apiKey by header(ofUuid)
val contentType by header(ofNonEmptyString)
```

When used in routes, parameters are automatically validated:

```kotlin
GET("users" / userId) withQuery limit isHandledBy {
    // Access validated parameters
    val id: Int = request[userId]      // Already validated and parsed
    val maxItems: Int = request[limit] // Already validated and parsed
    
    usersRepository.getUsers(id, maxItems).ok
}
```

## Creating Custom Validators

While built-in validators cover many common cases, you'll often need custom validators for domain-specific types. Snitch makes this straightforward:

### Basic Custom Validator

```kotlin
// Define a domain type
data class UserId(val value: String)

// Create a validator
val ofUserId = validator<String, UserId>(
    "valid user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    UserId(it)
}

// Use it with a parameter
val userId by path(ofUserId)
```

### Full Custom Validator Implementation

For more complex validation logic:

```kotlin
object UserIdValidator : Validator<String, UserId> {
    override val description = "Valid user ID (8-12 alphanumeric characters)"
    override val regex = """^[a-zA-Z0-9]{8,12}$""".toRegex()
    override val parse: Parser.(Collection<String>) -> UserId = { collection ->
        val value = collection.first()
        if (userRepository.exists(value)) {
            UserId(value)
        } else {
            throw IllegalArgumentException("User ID does not exist")
        }
    }
}

// Use it with a parameter
val userId by path(UserIdValidator)
```

### Factory Functions

Snitch provides several factory functions to create validators:

```kotlin
// For generic validators
fun <From, To> validator(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(String) -> To
): Validator<From, To>

// For string validators
fun <To> stringValidator(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(String) -> To
): Validator<String, To>

// For multi-value validators
fun <From, To> validatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
): Validator<From, To>

// For string collection validators
fun <To> stringValidatorMulti(
    description: String,
    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),
    mapper: Parser.(Collection<String>) -> To
): Validator<String, To>
```

## Advanced Validator Patterns

### Combining Validation and Business Logic

Sometimes validation involves checking against business rules:

```kotlin
val ofActiveUser = validator<String, User>(
    "active user ID",
    """^[a-zA-Z0-9]{8,12}$""".toRegex()
) {
    val user = userRepository.findById(it) 
        ?: throw IllegalArgumentException("User not found")
        
    if (!user.isActive) {
        throw IllegalArgumentException("User is not active")
    }
    
    user
}
```

### Chaining Validations

You can chain validations by creating validators that build on others:

```kotlin
val ofEmail = validator<String, String>(
    "email address",
    """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
) { it }

val ofCorporateEmail = validator<String, String>(
    "corporate email address",
    """^[a-zA-Z0-9._%+-]+@company\.com$""".toRegex()
) { 
    // First validate it's an email
    ofEmail.regex.matchEntire(it) ?: throw IllegalArgumentException("Invalid email format")
    
    // Then check for specific domain
    if (!it.endsWith("@company.com")) {
        throw IllegalArgumentException("Must be a company.com email")
    }
    
    it
}
```

### JWT Validators

Here's an example of a JWT validator:

```kotlin
data class JwtClaims(val userId: String, val roles: List<String>)

sealed interface Authentication {
    data class Authenticated(val claims: JwtClaims) : Authentication
    sealed interface Unauthenticated : Authentication
    object InvalidToken : Unauthenticated
    object ExpiredToken : Unauthenticated
    object MissingToken : Unauthenticated
}

val validAccessToken = stringValidator<Authentication>("valid JWT") { jwt ->
    try {
        val jwtVerifier = JWT.require(Algorithm.HMAC256(secretKey))
            .withIssuer("auth-service")
            .build()
            
        val decodedJWT = jwtVerifier.verify(jwt)
        val userId = decodedJWT.getClaim("userId").asString()
        val roles = decodedJWT.getClaim("roles").asList(String::class.java)
        
        Authentication.Authenticated(JwtClaims(userId, roles))
    } catch (e: TokenExpiredException) {
        Authentication.ExpiredToken
    } catch (e: Exception) {
        Authentication.InvalidToken
    }
}

// Use it with a parameter
val accessToken by header(validAccessToken, name = "Authorization")
```

## Handling Collections and Optional Values

### Multiple Values

For parameters that accept multiple values:

```kotlin
val tags by query(ofStringSet)
val roles by query(ofRepeatableEnum<UserRole>())

// In the handler
val userTags: Set<String> = request[tags]
val userRoles: Collection<UserRole> = request[roles]
```

### Optional Parameters

For optional parameters:

```kotlin
// Nullable parameter
val search by optionalQuery(ofNonEmptyString)

// Parameter with default value
val limit by optionalQuery(ofIntRange(1, 100), default = 20)

// Control empty and invalid handling
val page by optionalQuery(
    ofNonNegativeInt, 
    default = 1, 
    emptyAsMissing = true,  // Treat empty string as missing
    invalidAsMissing = true // Use default if parsing fails
)

// In the handler
val searchTerm: String? = request[search] // Nullable
val maxItems: Int = request[limit]       // Always has value (default if missing)
val pageNumber: Int = request[page]      // Has default if empty or invalid
```

## Best Practices

### 1. Use Domain Types

Instead of primitives, use domain-specific types with validators:

```kotlin
// Bad
val userId by path(ofNonEmptyString)

// Good
data class UserId(val value: String)
val ofUserId = validator<String, UserId>("user ID") { UserId(it) }
val userId by path(ofUserId)
```

### 2. Provide Clear Error Messages

When validation fails, provide clear, actionable error messages:

```kotlin
val ofWeekday = validator<String, DayOfWeek>(
    "weekday name (Monday-Friday)",
    """^[A-Za-z]+$""".toRegex()
) {
    try {
        DayOfWeek.valueOf(it.uppercase())
    } catch (e: IllegalArgumentException) {
        throw IllegalArgumentException("'$it' is not a valid weekday (Monday-Friday)")
    }
}
```

### 3. Keep Validators Reusable

If a validation logic is used in multiple places, define it once and reuse:

```kotlin
// Shared across multiple endpoints/controllers
object Validators {
    val ofEmail = validator<String, String>(
        "email address",
        """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".toRegex()
    ) { it }
    
    val ofZipCode = validator<String, String>(
        "ZIP code",
        """^\d{5}(-\d{4})?$""".toRegex()
    ) { it }
}
```

### 4. Validate at the Edge

Catch invalid inputs at the HTTP layer rather than deep in business logic:

```kotlin
// Let Snitch handle validation
val email by query(ofEmail)

// In the handler - already validated and safe to use
val emailAddress = request[email]
```

### 5. Test Your Validators

Create unit tests for your validators, especially custom ones:

```kotlin
@Test
fun `ofEmail validator should accept valid email addresses`() {
    val validEmails = listOf(
        "user@example.com",
        "firstname.lastname@example.com",
        "user+tag@example.com"
    )
    
    validEmails.forEach { email ->
        assertTrue(ofEmail.regex.matches(email))
    }
}

@Test
fun `ofEmail validator should reject invalid email addresses`() {
    val invalidEmails = listOf(
        "",
        "user@",
        "@example.com",
        "user@example"
    )
    
    invalidEmails.forEach { email ->
        assertFalse(ofEmail.regex.matches(email))
    }
}
```

## Conclusion

Validators are a powerful feature of Snitch that ensure your HTTP inputs are properly validated and transformed. By using validators effectively, you can:

- Create more robust APIs with clear, consistent validation
- Transform raw HTTP inputs into domain-specific types
- Generate accurate API documentation automatically
- Reduce boilerplate validation code in your handlers
- Enforce validation at the edge of your application

Remember that validators are not just for validation but also for transformation. Using them effectively enables you to work with strongly typed values throughout your codebase, making your application more maintainable and less error-prone.

---

## From: README.md

# Deep Dive

Welcome to the in-depth guides! This section contains detailed guides to help you master different aspects of Snitch.

## Getting Started
- [Quick Start Guide](../tutorials/QuickStart.md) - Set up a basic Snitch application in minutes
- [Artifacts Overview](../resources/Artifacts.md) - Learn about all the modules in the Snitch ecosystem
- [Using Shank with Snitch](../tutorials/UsingShank.md) - Dependency injection guide
- [Advanced Shank Patterns](../tutorials/ShankPatterns.md) - Design patterns for effective dependency management

## Core Concepts
- [Anatomy of Endpoints](Anatomy-of-Endpoints.md) - Understanding the structure of endpoints in Snitch
- [Anatomy of Handlers](Anatomy-of-Handlers.md) - Deep dive into request handlers
- [Anatomy of Validators](Anatomy-of-Validators.md) - Learn how validation works

## Advanced Features
- [Mastering Snitch Parameters](Mastering-Snitch-Parameters.md) - Everything about parameters
- [Mastering Snitch Conditions](Mastering-Snitch-Conditions.md) - Advanced access control
- [Mastering Snitch BeforeAfter](Mastering-Snitch-BeforeAfter.md) - Pre and post-processing
- [Mastering Snitch Decorations](Mastering-Snitch-Decorations.md) - Custom middleware
- [Mastering Snitch Validators](Mastering-Snitch-Validators.md) - Creating custom validators

## Case Studies
Check out our blog for real-world implementations and case studies:
- [Blog Posts](../../blog/)

---

## From: Working-With-Parameters.md

# Working with Parameters in Snitch

This in-depth guide explores Snitch's parameter handling system, covering advanced topics, implementation details, and best practices for building robust, type-safe APIs.

## Parameter System Architecture

Snitch's parameter system is built on Kotlin's property delegation pattern, providing both compile-time and runtime safety. The system consists of several key components:

1. **Parameter Definitions**: Type-safe property delegates that define parameters
2. **Validators**: Functions that validate and transform parameter values
3. **Parameter Registry**: Keeps track of all parameters used in routes
4. **Parameter Extraction**: Pulls parameter values from HTTP requests
5. **Parameter Access**: Type-safe access to parameter values in handlers

## Parameter Delegates

Each parameter type is implemented as a property delegate:

- `path()`: Path parameters embedded in URL segments
- `query()`: Query parameters from the URL query string
- `header()`: Parameters from HTTP headers
- `body<T>()`: Type-safe access to the request body

Each delegate creates a parameter definition that is registered with the framework when routes are defined.

## Parameter Definition Internals

Let's look at how parameters are defined under the hood:

```kotlin
// PathParam implementation (simplified)
class PathParam<T : Any, C : Any>(
    override val name: String,
    override val validator: ValueValidator<T, C>,
    override val description: String,
    override val emptyAsMissing: Boolean,
    override val invalidAsMissing: Boolean,
    override val visibility: ParameterVisibility,
    override val condition: ValueCondition<C>?
) : Parameter<T, C>
```

The `Parameter<T, C>` interface defines common properties and behaviors for all parameter types:

- `name`: The parameter name used in documentation and error messages
- `validator`: Validates and transforms the parameter string value to type T
- `description`: Human-readable description for documentation
- `emptyAsMissing`: Controls whether empty values are treated as missing
- `invalidAsMissing`: Controls whether invalid values are treated as missing
- `visibility`: Controls whether parameter appears in documentation
- `condition`: Additional validation logic for the parameter

## Parameter Registration and Resolution

When a route is defined, its parameters are registered with the framework:

```kotlin
val userId by path(ofInt)

// The route definition registers the userId parameter
GET("users" / userId) isHandledBy { ... }
```

During request handling:

1. Parameters are extracted from the request
2. Each parameter is validated using its validator
3. Additional conditions are checked
4. If validation fails, an appropriate error response is returned
5. If successful, the handler is invoked with access to the validated parameters

## Advanced Parameter Usage

### Custom Validator Implementation

Creating a custom validator involves implementing the `ValueValidator<T, C>` interface:

```kotlin
// Custom UUID validator implementation
val ofUUID = object : ValueValidator<String, UUID> {
    override val invalidValueErrorMessage = "Invalid UUID format"
    
    override fun validate(value: String): UUID {
        try {
            return UUID.fromString(value)
        } catch (e: IllegalArgumentException) {
            throw InvalidParameterException(invalidValueErrorMessage)
        }
    }
    
    override fun serialize(value: UUID): String {
        return value.toString()
    }
}

// Usage
val userId by path(ofUUID, description = "User ID in UUID format")
```

For simpler validators, you can use the `validator` helper function:

```kotlin
val ofUUID = validator { input ->
    try {
        UUID.fromString(input)
        input
    } catch (e: IllegalArgumentException) {
        throw InvalidParameterException("Invalid UUID format")
    }
}
```

### Parameter Conditions

Conditions provide additional validation for parameters beyond basic type conversion:

```kotlin
// Condition implementation
val positiveNumber = condition<Int> { value ->
    if (value <= 0) {
        ConditionResult.Failure("Value must be positive")
    } else {
        ConditionResult.Success
    }
}

// Usage with a parameter
val quantity by query(ofInt, condition = positiveNumber)
```

Conditions are evaluated after the parameter has been successfully validated and converted to its target type.

### Parameter Visibility

Control whether parameters appear in documentation:

```kotlin
// Public parameter visible in documentation
val apiKey by header(visibility = ParameterVisibility.PUBLIC)

// Internal parameter hidden from documentation
val internalId by header(visibility = ParameterVisibility.INTERNAL)
```

### Parameter Grouping and Organization

For better code organization, group related parameters in objects:

```kotlin
object UserParameters {
    val id by path(ofInt, description = "User ID")
    val email by query(ofEmail, description = "User email")
    val status by optionalQuery(
        validator { input -> UserStatus.valueOf(input.uppercase()) },
        default = UserStatus.ACTIVE,
        description = "User status"
    )
}

object PaginationParameters {
    val page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")
    val size by optionalQuery(ofNonNegativeInt, default = 20, description = "Page size")
    val sort by optionalQuery(description = "Sort field")
    val direction by optionalQuery(
        validator { input -> SortDirection.valueOf(input.uppercase()) },
        default = SortDirection.ASC,
        description = "Sort direction"
    )
}
```

This approach makes route definitions more readable and groups related parameters logically:

```kotlin
GET("users") withQuery PaginationParameters.page withQuery PaginationParameters.size isHandledBy {
    val page = request[PaginationParameters.page]
    val size = request[PaginationParameters.size]
    // ...
}
```

## Parameter Validation Flow

When a request is processed, parameters go through the following validation flow:

1. **Extraction**: Parameters are extracted from the request
   - Path parameters from URL path segments
   - Query parameters from the query string
   - Header parameters from request headers

2. **Presence Check**: For required parameters, verify the parameter is present

3. **Empty Value Handling**: Apply `emptyAsMissing` logic if configured

4. **Type Validation and Conversion**: Apply the parameter's validator
   - Validates the string value
   - Converts to the target type
   - May throw `InvalidParameterException` if validation fails

5. **Invalid Value Handling**: Apply `invalidAsMissing` logic if configured and validation failed

6. **Condition Check**: Apply additional conditions if defined
   - Evaluated on the converted value
   - May return failure with a custom error message

7. **Default Value Application**: For optional parameters with defaults, apply the default value if the parameter is missing

8. **Availability**: Make validated parameters available to the handler

If any step fails, the framework generates an appropriate error response, typically a 400 Bad Request with details about the invalid parameter.

## Body Parameter Handling

Body parameters are handled differently from other parameter types:

1. The request body is read and parsed according to the Content-Type
2. The parsed data is converted to the target type
3. The typed body is made available in handlers via the `body` property

Body parameters are defined in route declarations:

```kotlin
POST("users") with body<CreateUserRequest>() isHandledBy {
    // Access body properties directly
    val name = body.name
    val email = body.email
    // ...
}
```

For more control over body parsing and validation, use the `parsing` handler:

```kotlin
val createUser by parsing<CreateUserRequest>() handling {
    // Additional validation
    if (body.name.isBlank()) {
        return@handling "Name cannot be blank".badRequest()
    }
    
    // Process the request
    userService.createUser(body.name, body.email)
    "User created".created
}
```

## Combining Parameters with Path Building

Snitch's path building syntax integrates seamlessly with parameters:

```kotlin
// Basic path with parameter
GET("users" / userId) isHandledBy { ... }

// Nested paths with multiple parameters
val api = routes {
    "users" / {
        GET() isHandledBy { ... }  // GET /users
        
        userId / {
            GET() isHandledBy { ... }  // GET /users/{userId}
            
            "posts" / {
                GET() isHandledBy { ... }  // GET /users/{userId}/posts
                
                postId / {
                    GET() isHandledBy { ... }  // GET /users/{userId}/posts/{postId}
                }
            }
        }
    }
}
```

This composition approach makes it easy to build hierarchical APIs with clear parameter scoping.

## Type-Safe Parameter Access

Snitch provides type-safe access to parameters in handlers:

```kotlin
val userId by path(ofInt)
val page by optionalQuery(ofInt, default = 1)

val handler by handling {
    val id: Int = request[userId]  // Type-safe access
    val pageNum: Int = request[page]  // Default applied if missing
    
    // ...
}
```

The type information is preserved through the property delegate system, so you get compile-time type checking for parameter access.

## Error Handling and Customization

You can customize how parameter validation errors are handled:

```kotlin
// Global error handler for parameter validation errors
app.handleException(InvalidParameterException::class) { exception, _ ->
    ErrorResponse(
        code = 400,
        message = "Invalid parameter: ${exception.message}"
    ).badRequest()
}

// Custom error handler for specific routes
routes {
    handleException(InvalidParameterException::class) { exception, _ ->
        ErrorResponse(
            code = 400,
            message = "Validation failed: ${exception.message}",
            details = mapOf("parameter" to exception.parameterName)
        ).badRequest()
    }
    
    // Routes with custom error handling...
}
```

## Working with Collections of Parameters

Handling collections of parameter values:

```kotlin
// Define a multi-value query parameter
val tags by query(description = "Filter by tags", multiValued = true)

// Access as a list in the handler
val handler by handling {
    val tagList: List<String> = request[tags]
    // ...
}
```

For more complex parsing:

```kotlin
// Define a collection parameter with custom parsing
val sortFields by query(
    validator { input ->
        input.split(",").map { field ->
            val parts = field.split(":")
            val name = parts[0]
            val direction = if (parts.size > 1) parts[1].uppercase() else "ASC"
            SortField(name, SortDirection.valueOf(direction))
        }
    },
    description = "Sorting fields in format field:direction,field:direction"
)

// Access in handler
val handler by handling {
    val sorting: List<SortField> = request[sortFields]
    // ...
}
```

## Performance Considerations

The parameter handling system is designed to be efficient:

1. **Property Delegates**: Parameters are defined once at initialization time
2. **Lazy Validation**: Parameters are only validated when accessed
3. **Caching**: Validation results are cached within a request
4. **Early Validation**: Basic validation happens before handlers are invoked, preventing unnecessary work

For optimal performance:

- Use appropriate validators for your parameter types
- Consider organizing parameters by usage patterns
- Leverage built-in validators when possible
- Use conditional logic in handlers for complex validation scenarios

## Integration with API Documentation

Parameters are automatically included in API documentation:

- Path parameters are shown in URL templates
- Query parameters are listed with types and descriptions
- Header parameters are included in expected headers
- Body parameters are documented with schemas when possible

To improve documentation:

- Add clear descriptions to all parameters
- Use appropriate visibility settings
- Organize parameters logically
- Consider using custom validators with descriptive error messages

## Best Practices

### Parameter Naming

Follow consistent naming conventions:

- Use camelCase for parameter names
- Be descriptive but concise
- Use singular nouns for single values (e.g., `userId`)
- Use plural nouns for collections (e.g., `tags`)
- Prefer specific names over generic ones (e.g., `email` instead of `value`)

### Parameter Organization

Organize parameters for maintainability:

- Group related parameters in objects
- Use common objects for shared parameters (e.g., pagination)
- Keep parameter definitions close to their usage
- Consider organizing parameters by domain concept

### Validation Strategy

Create a robust validation strategy:

- Validate parameters at the appropriate level
- Use parameter validators for basic type and format validation
- Use conditions for business rule validation
- Use handler logic for complex or cross-parameter validation
- Consider using the Jakarta Bean Validation API for complex objects

### Parameter Documentation

Document parameters thoroughly:

- Add clear descriptions to all parameters
- Indicate parameter constraints (e.g., "must be positive")
- Document default values for optional parameters
- Use examples for complex parameters

### Parameter Security

Consider security implications:

- Validate all user input
- Sanitize path and query parameters
- Be cautious with header parameters that may contain sensitive data
- Consider using `emptyAsMissing` for parameters that should never be empty
- Use conditions to implement additional security checks

## Conclusion

Snitch's parameter handling system provides a powerful, type-safe approach to working with request parameters. By leveraging Kotlin's property delegation feature, it offers a declarative syntax for parameter definition with strong type safety and robust validation.

Understanding the internals of the parameter system allows you to build more maintainable, secure, and well-documented APIs with Snitch, while taking advantage of the framework's type safety and validation features.

---

## From: Artifacts.md

# Snitch Artifacts

Snitch is modular by design, providing several artifacts that can be used independently based on your needs. All artifacts are published to Maven Central.

## Core Artifacts

### snitch-bootstrap

```kotlin
implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
```

This is the main artifact most users should depend on. It includes everything needed to create a complete web service using Snitch with Undertow as the server and Gson for JSON parsing.

**Dependencies**: Includes core, gsonparser, and undertow modules.

### snitch-core

```kotlin
implementation("io.github.memoizr:snitch-core:1.0.0")
```

The core module contains the essential building blocks of Snitch:
- DSL for defining routes and handlers
- Parameter definition and validation framework
- Middleware and conditions system
- Documentation generation engine

This module is server-agnostic and doesn't include any specific JSON parsing implementation.

### snitch-types

```kotlin
implementation("io.github.memoizr:snitch-types:1.0.0")
```

A lightweight module containing the basic types and interfaces used across the Snitch ecosystem. This module has minimal dependencies and can be used in your domain model to avoid pulling in the entire Snitch framework.

## Extensions and Implementations

### snitch-undertow

```kotlin
implementation("io.github.memoizr:snitch-undertow:1.0.0")
```

Provides Undertow server integration for Snitch. Undertow is a flexible, high-performance web server by JBoss that serves as the default server implementation for Snitch.

### snitch-gsonparser

```kotlin
implementation("io.github.memoizr:snitch-gsonparser:1.0.0")
```

Implements JSON parsing and serialization using Google's Gson library. This module allows Snitch to convert between JSON and Kotlin objects.

### snitch-coroutines

```kotlin
implementation("io.github.memoizr:snitch-coroutines:1.0.0")
```

Adds Kotlin Coroutines support to Snitch, allowing you to define suspending handlers and use the full power of Kotlin's asynchronous programming features.

Requires the `-Xcontext-receivers` compiler flag:

```kotlin
tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = freeCompilerArgs + "-Xcontext-receivers"
    }
}
```

### snitch-auth

```kotlin
implementation("io.github.memoizr:snitch-auth:1.0.0")
```

Provides authentication and authorization capabilities for Snitch applications, including support for JWT tokens, role-based access control, and security middleware.

### snitch-validation

```kotlin
implementation("io.github.memoizr:snitch-validation:1.0.0")
```

Provides integration with Hibernate Validator (Jakarta Bean Validation), allowing you to use standard validation annotations in your request/response models.

### snitch-tests

```kotlin
testImplementation("io.github.memoizr:snitch-tests:1.0.0")
```

Contains testing utilities and a fluent DSL for writing integration tests for Snitch services. Includes assertion helpers and logging configuration for tests.

### snitch-shank

```kotlin
implementation("io.github.memoizr:snitch-shank:1.0.0")
```

Integrates the Shank dependency injection library with Snitch, providing a lightweight, code-generated DI solution for your applications.

### snitch-exposed

```kotlin
implementation("io.github.memoizr:snitch-exposed:1.0.0")
```

Integrates the Exposed SQL library with Snitch, providing type-safe database access with automatic object mapping and transaction management.

### snitch-exposed-h2

```kotlin
implementation("io.github.memoizr:snitch-exposed-h2:1.0.0")
```

Provides specialized support for H2 databases with Snitch and Exposed, ideal for development and testing environments.

### snitch-exposed-postgres

```kotlin
implementation("io.github.memoizr:snitch-exposed-postgres:1.0.0")
```

Provides specialized support for PostgreSQL databases with Snitch and Exposed, suitable for production environments.

### snitch-kofix

```kotlin
testImplementation("io.github.memoizr:snitch-kofix:1.0.0")
```

Testing utilities for property-based testing and mocking in Snitch applications.

## Choosing the Right Dependencies

For most applications, the bootstrap module is sufficient:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
}
```

For applications requiring coroutines:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("io.github.memoizr:snitch-coroutines:1.0.0")
}
```

For applications with database access:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("io.github.memoizr:snitch-exposed:1.0.0")
    implementation("io.github..memoizr:snitch-exposed-postgres:1.0.0") // For production
    implementation("io.github.memoizr:snitch-exposed-h2:1.0.0") // For testing
}
```

For applications requiring authentication:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")
    implementation("io.github.memoizr:snitch-auth:1.0.0")
}
```

For a more customized setup using a different JSON library or web server, you can use just the core module and add your own implementations:

```kotlin
dependencies {
    implementation("io.github.memoizr:snitch-core:1.0.0")
    // Add your preferred JSON parser and server
}
```

## Artifact Breakdown

| Artifact | Purpose | Key Features |
|----------|---------|--------------|
| snitch-bootstrap | Complete starter package | All-in-one solution for getting started quickly |
| snitch-core | Core framework | Route definitions, handlers, parameter validation, middleware |
| snitch-types | Common types | Basic types used throughout the framework |
| snitch-undertow | Server implementation | Integrates with Undertow web server |
| snitch-gsonparser | JSON parsing | Handles JSON serialization/deserialization with Gson |
| snitch-coroutines | Async support | Kotlin Coroutines integration for asynchronous handlers |
| snitch-auth | Authentication | Authentication and authorization support |
| snitch-validation | Enhanced validation | Hibernate Validator integration |
| snitch-tests | Testing utilities | Testing DSL and assertion helpers |
| snitch-shank | Dependency injection | Lightweight DI integration |
| snitch-exposed | Database access | Core database integration with Exposed |
| snitch-exposed-h2 | H2 database | H2 database support for development and testing |
| snitch-exposed-postgres | PostgreSQL database | PostgreSQL support for production use |
| snitch-kofix | Testing utilities | Property-based testing and mocking |

---

## From: Database-Integration.md

# Database Integration with Snitch Exposed

Snitch offers first-class database integration through its Exposed modules, providing a seamless, type-safe experience for working with relational databases in your applications. This guide explores how Snitch's Exposed modules help you integrate databases into your applications with minimal boilerplate and maximum type safety.

## Introduction

Working with databases in web applications is often fraught with challenges:

- **Type safety** is frequently lost at the database boundary
- **Object-relational impedance mismatch** requires tedious mapping code
- **Transaction management** adds complexity to request handling
- **Database schema evolution** creates maintenance challenges

Snitch solves these problems through a powerful integration with the [Exposed](https://github.com/JetBrains/Exposed) SQL library for Kotlin. This integration provides type-safe database access with automatic object mapping and transaction management tailored specifically for Snitch applications.

## Available Modules

Snitch provides three modules for database integration:

1. **exposed**: Core module with base abstractions, mapping utilities, and transaction management
2. **exposed-h2**: Specialized module for H2 database connections, ideal for testing and development
3. **exposed-postgres**: Specialized module for PostgreSQL database connections, suitable for production

## Key Benefits

### 1. Type-Safe Database Access

Snitch Exposed modules leverage Kotlin's type system to provide compile-time safety for database operations:

```kotlin
// Type-safe table definition
object Users : Table("users") {
    val id = integer("id").autoIncrement()
    val name = varchar("name", 255)
    val email = varchar("email", 255)
    
    override val primaryKey = PrimaryKey(id)
}

// Type-safe query
val user = transaction {
    Users.findOne<UserModel> { Users.email eq "user@example.com" }
}
```

The compiler ensures that:
- Your queries reference existing columns
- Your comparisons use the correct data types
- Your result mappings align with your domain models

### 2. Automatic Object Mapping

One of the most powerful features of Snitch Exposed is its automatic object mapping. This eliminates the tedious and error-prone code typically required to map between database tables and domain objects:

```kotlin
// Domain model
data class User(val name: String, val email: String)
data class UserWithId(val id: Int, val name: String, val email: String)

// Automatic mapping from database to domain model
val users = transaction {
    Users.findAll<UserWithId>()
}

// Automatic mapping from domain model to database
val user = User("John Doe", "john@example.com")
transaction {
    Users.insert(user)
}
```

Behind the scenes, Snitch:
1. Inspects the properties of your domain model using Kotlin reflection
2. Matches them with database column names
3. Performs appropriate type conversions
4. Handles value classes and nested objects
5. Supports custom mapping for complex cases

This eliminates thousands of lines of boilerplate code in typical applications while maintaining type safety.

### 3. Integrated Transaction Management

Snitch Exposed seamlessly integrates transaction management with the routing system:

```kotlin
withTransaction {
    POST("users") with body<User>() isHandledBy {
        val user = body
        val id = Users.insert(user)[Users.id]
        UserResponse(id, user.name, user.email).ok
    }
}
```

This provides several benefits:
- **Automatic transaction boundaries** around route handlers
- **Consistent error handling** with automatic rollback on exceptions
- **Clean code organization** without explicit transaction blocks

### 4. Value Class Support

Modern Kotlin applications often use value classes for type safety. Snitch Exposed provides first-class support for value classes:

```kotlin
// Domain model with value classes
@JvmInline
value class UserId(val value: Int)

data class UserWithValueId(val id: UserId, val name: String, val email: String)

// Automatic mapping works with value classes
val user = transaction {
    Users.findOne<UserWithValueId> { Users.id eq 1 }
}

println(user.id.value) // Accesses the wrapped value
```

This enables more type-safe domain models without sacrificing database integration.

### 5. Flexible Schema Management

Snitch Exposed provides tools for schema management:

```kotlin
// Create tables
transaction {
    SchemaUtils.create(Users, Posts, Comments)
}

// Add missing columns during updates
database.addMissingColumns(Users)

// Drop tables
transaction {
    SchemaUtils.drop(Users)
}
```

Combined with migration tools, this gives you flexible options for evolving your database schema alongside your application.

## Database-Specific Modules

### H2 Integration

The `exposed-h2` module provides specialized support for H2 databases, which are particularly useful for:

- **Development environments** where quick setup is important
- **Testing** where database isolation is critical
- **Embedded applications** that need a lightweight database

Key features include:
- In-memory database support with zero configuration
- File-based database options for persistence
- Automatic schema creation and teardown

Example:

```kotlin
// Quick in-memory database for testing
val config = h2ConnectionConfig()
ExposedModule.connection(config)

// File-based database for development
val devConfig = h2ConnectionConfig(
    name = "myapp",
    inMemory = false,
    directory = "./data"
)
ExposedModule.connection(devConfig)
```

### PostgreSQL Integration

The `exposed-postgres` module provides specialized support for PostgreSQL databases, which are ideal for:

- **Production environments** requiring advanced database features
- **High-performance applications** needing robust concurrency
- **Data-intensive applications** leveraging PostgreSQL's rich data types

Key features include:
- Connection pooling for efficient resource use
- SSL configuration for secure connections
- Support for PostgreSQL-specific data types
- Advanced query capabilities

Example:

```kotlin
// Basic PostgreSQL connection
val config = postgresConnectionConfig(
    host = "localhost",
    database = "myapp",
    user = "appuser",
    password = "password"
)
ExposedModule.connection(config)

// With connection pooling
val pooledConfig = postgresConnectionConfig(
    dataSource = createHikariDataSource() // Your connection pool
)
ExposedModule.connection(pooledConfig)
```

## Advanced Usage Patterns

### Custom Type Mapping

For complex mapping scenarios, Snitch Exposed provides a custom mapping facility:

```kotlin
// Define custom mapping between types
AutoMapper.customMapping<User, UserDTO>(
    from = { user -> UserDTO(user.name, user.email, "Additional info") },
    to = { dto -> User(dto.name, dto.email) }
)

// Now you can convert between them
val user = User("John", "john@example.com")
val dto = user.to<UserDTO>()
```

This is particularly useful for:
- Converting between persistence models and API models
- Handling legacy database schemas
- Supporting complex business logic during mapping

### Transaction Strategies

Snitch Exposed supports different transaction strategies to match your application's needs:

```kotlin
// Explicit transactions for fine-grained control
POST("users") isHandledBy {
    val user = body
    transaction {
        // Database operations
    }
    "User created".ok
}

// Transaction-per-request for comprehensive coverage
withTransaction {
    POST("users") with body<User>() isHandledBy {
        // Everything here runs within a transaction
    }
    
    GET("users") isHandledBy {
        // This handler also runs in a transaction
    }
}
```

### Working with Relationships

Snitch Exposed makes it easy to work with database relationships:

```kotlin
// Table definitions
object Users : Table("users") {
    val id = integer("id").autoIncrement()
    val name = varchar("name", 255)
    
    override val primaryKey = PrimaryKey(id)
}

object Posts : Table("posts") {
    val id = integer("id").autoIncrement()
    val userId = integer("user_id") references Users.id
    val title = varchar("title", 255)
    val content = text("content")
    
    override val primaryKey = PrimaryKey(id)
}

// Domain models
data class User(val id: Int, val name: String)
data class Post(val id: Int, val userId: Int, val title: String, val content: String)
data class UserWithPosts(val id: Int, val name: String, val posts: List<Post>)

// Query with relationships
val usersWithPosts = transaction {
    Users.findAll<User>().map { user ->
        val posts = Posts.findAll<Post> { Posts.userId eq user.id }
        UserWithPosts(user.id, user.name, posts)
    }
}
```

## Performance Considerations

Snitch Exposed is designed for performance:

1. **Connection pooling** reuses database connections efficiently
2. **Batch operations** minimize database roundtrips
3. **Lazy loading** defers expensive operations until needed
4. **Caching** reduces redundant database queries

For maximum performance:

```kotlin
// Batch inserts for bulk operations
transaction {
    Users.batchInsert(userList) {
        it[name] = it.name
        it[email] = it.email
    }
}

// Targeted queries to minimize data transfer
val userCount = transaction {
    Users.selectAll().count()
} 

// Using database-specific optimizations
transaction {
    // PostgreSQL JSON functions for complex data
    Users.select { Users.metadata.jsonPathExists("$.preferences") }
}
```

## Integration with Snitch Features

Snitch Exposed integrates seamlessly with other Snitch features:

### Validation Integration

```kotlin
withTransaction {
    POST("users") with validate<User>() isHandledBy {
        // Validation runs before the transaction begins
        // Database operations only happen for valid requests
        val user = body
        Users.insert(user)
        "User created".ok
    }
}
```

### Error Handling Integration

```kotlin
withTransaction {
    POST("users") with body<User>() isHandledBy {
        try {
            val user = body
            Users.insert(user)
            "User created".ok
        } catch (e: Exception) {
            // Transaction automatically rolls back
            "Error: ${e.message}".serverError()
        }
    }
}
```

### Testing Integration

```kotlin
// Test setup with in-memory database
@BeforeEach
fun setup() {
    val config = h2ConnectionConfig()
    ExposedModule.connection(config)
    
    transaction {
        SchemaUtils.create(TestTable)
    }
}

// Test endpoint with transaction
@Test
fun `test user creation`() {
    given {
        withTransaction {
            POST("users") with body<User>() isHandledBy {
                val user = body
                Users.insert(user)
                "User created".ok
            }
        }
    } then {
        POST("/users") withBody User("Test", "test@example.com") expect {
            expect that it.statusCode() isEqualTo 200
            
            // Verify database state
            transaction {
                val count = Users.selectAll().count()
                expect that count isEqualTo 1
            }
        }
    }
}
```

## Best Practices

### 1. Domain Model Separation

Keep your domain models separate from your database entities:

```kotlin
// Database table
object Users : Table("users") {
    val id = integer("id").autoIncrement()
    val name = varchar("name", 255)
    val email = varchar("email", 255)
    
    override val primaryKey = PrimaryKey(id)
}

// Domain model (persistence)
data class UserEntity(val id: Int, val name: String, val email: String)

// Domain model (business logic)
data class User(val id: Int, val name: String, val email: String, val isValid: Boolean)

// API model
data class UserResponse(val id: Int, val name: String)
```

This separation allows each model to evolve independently according to its concerns.

### 2. Repository Pattern

Encapsulate database access in repository classes:

```kotlin
class UserRepository {
    fun findById(id: Int): User? = transaction {
        Users.findOneOrNull<UserEntity> { Users.id eq id }
            ?.let { mapToUser(it) }
    }
    
    fun create(user: User): Int = transaction {
        val entity = mapToEntity(user)
        Users.insert(entity)[Users.id]
    }
    
    private fun mapToUser(entity: UserEntity): User = // mapping logic
    private fun mapToEntity(user: User): UserEntity = // mapping logic
}
```

This approach:
- Centralizes database access logic
- Makes database operations more testable
- Provides a clean API for business logic

### 3. Transaction Management

Choose the right transaction boundaries:

```kotlin
// Transaction per request (most common)
withTransaction {
    // Multiple endpoint handlers here
}

// Transaction per operation (more granular)
POST("users") isHandledBy {
    transaction {
        // Single operation
    }
}

// Transaction per unit of work (intermediate)
POST("complex-operation") isHandledBy {
    transaction {
        // Multiple related operations
        // Either all succeed or all fail
    }
}
```

### 4. Error Handling

Implement robust error handling:

```kotlin
withTransaction {
    POST("users") with body<User>() isHandledBy {
        try {
            // Database operations
        } catch (e: Exception) {
            logger.error("Database error", e)
            when (e) {
                is UniqueConstraintException -> "User already exists".conflict()
                is ReferenceConstraintException -> "Referenced entity not found".badRequest()
                else -> "Internal server error".serverError()
            }
        }
    }
}
```

### 5. Testing Strategy

Adopt a comprehensive testing strategy:

- **Unit tests**: Test your repositories in isolation
- **Integration tests**: Test endpoints with an in-memory H2 database
- **Schema tests**: Verify your schema changes are compatible
- **Performance tests**: Validate database performance under load

## Conclusion

Snitch Exposed offers a powerful, type-safe approach to database integration that eliminates boilerplate while maintaining the flexibility and performance needed for real-world applications. By leveraging Kotlin's type system and reflection capabilities, it provides a seamless bridge between your domain models and database schema.

Whether you're building a simple application with H2 or a complex system with PostgreSQL, Snitch Exposed gives you the tools to work with databases efficiently and confidently.

## Further Reading

- [Exposed Documentation](https://github.com/JetBrains/Exposed/wiki)
- [H2 Database Engine](https://h2database.com/html/main.html)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)

---

