"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[9270],{5147:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});var t=s(6365),i=s(4848),a=s(8453);const r={slug:"expressivity-and-scaling-with-snitch",title:"Expressive Code at Scale: How Snitch Transforms API Development",authors:["snitch-team"],tags:["snitch","expressivity","code-quality","scaling","dsl","type-safety"]},o="Expressive Code at Scale: How Snitch Transforms API Development",l={authorsImageUrls:[void 0]},d=[{value:"The Hidden Costs of Unexpressive Code",id:"the-hidden-costs-of-unexpressive-code",level:2},{value:"Expressivity&#39;s Evolution: From Ruby on Rails to Kotlin DSLs",id:"expressivitys-evolution-from-ruby-on-rails-to-kotlin-dsls",level:2},{value:"Ruby on Rails: The Expressivity Pioneer",id:"ruby-on-rails-the-expressivity-pioneer",level:3},{value:"The Rise of Typed Functional Languages",id:"the-rise-of-typed-functional-languages",level:3},{value:"The Best of Both Worlds: Kotlin DSLs",id:"the-best-of-both-worlds-kotlin-dsls",level:2},{value:"Snitch: Pushing the Boundaries of Expressive, Type-Safe Code",id:"snitch-pushing-the-boundaries-of-expressive-type-safe-code",level:2},{value:"Spring Boot (Java)",id:"spring-boot-java",level:3},{value:"Ktor (Kotlin)",id:"ktor-kotlin",level:3},{value:"Snitch (Kotlin)",id:"snitch-kotlin",level:3},{value:"Expressivity and Scaling: An Unexpected Synergy",id:"expressivity-and-scaling-an-unexpected-synergy",level:2},{value:"The Unfair Advantage: Type Safety + Expressivity",id:"the-unfair-advantage-type-safety--expressivity",level:2},{value:"1. Error Prevention",id:"1-error-prevention",level:3},{value:"2. Refactoring Confidence",id:"2-refactoring-confidence",level:3},{value:"3. Self-Documenting Code",id:"3-self-documenting-code",level:3},{value:"Industry Impact: Changing How We Think About API Development",id:"industry-impact-changing-how-we-think-about-api-development",level:2},{value:"Conclusion: Expressivity as a Competitive Advantage",id:"conclusion-expressivity-as-a-competitive-advantage",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In the world of software development, there's a persistent myth that we must choose between code that is pleasant to write and code that scales well technically. Many believe that as systems grow, elegance must give way to verbosity, and expressivity must be sacrificed for safety and performance."}),"\n",(0,i.jsx)(n.p,{children:"Snitch challenges this false dichotomy by combining the best of both worlds: an incredibly expressive DSL with the rigorous type safety of Kotlin. Let's explore why expressivity matters at scale, and how Snitch pushes the boundaries of what's possible."}),"\n",(0,i.jsx)(n.h2,{id:"the-hidden-costs-of-unexpressive-code",children:"The Hidden Costs of Unexpressive Code"}),"\n",(0,i.jsx)(n.p,{children:'When we talk about "scaling" software, we usually focus on technical metrics: requests per second, response times, resource utilization. But there\'s another crucial scaling dimension that gets less attention: human scaling.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Human scaling refers to how well your codebase can grow while remaining comprehensible and maintainable by a team of developers."})}),"\n",(0,i.jsx)(n.p,{children:"Unexpressive code creates an enormous tax on human scaling:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cognitive load"}),": Developers must mentally translate between what the code says and what it means"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Onboarding friction"}),": New team members take longer to become productive"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintenance burdens"}),": Bug fixes and feature additions require more careful analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Knowledge silos"}),": Implementation details become specialized knowledge"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Refactoring hesitancy"}),": Complex code discourages necessary evolution"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These costs compound as systems grow larger, often leading to what's colloquially known as \"technical debt\" - a debt that's paid through slower development cycles, more bugs, and ultimately, competitive disadvantage."}),"\n",(0,i.jsx)(n.h2,{id:"expressivitys-evolution-from-ruby-on-rails-to-kotlin-dsls",children:"Expressivity's Evolution: From Ruby on Rails to Kotlin DSLs"}),"\n",(0,i.jsx)(n.p,{children:'The software industry has long recognized the value of expressive code. Ruby on Rails, which emerged in 2004, built much of its success on prioritizing "developer happiness" and the principle of convention over configuration.'}),"\n",(0,i.jsx)(n.h3,{id:"ruby-on-rails-the-expressivity-pioneer",children:"Ruby on Rails: The Expressivity Pioneer"}),"\n",(0,i.jsx)(n.p,{children:"Ruby on Rails showed that a framework could be both powerful and a joy to use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"class UsersController < ApplicationController\n  before_action :require_login\n  \n  def index\n    @users = User.all\n  end\n  \n  def show\n    @user = User.find(params[:id])\n  end\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"This code is remarkably readable - almost English-like in its clarity. But as Rails applications grew, they often encountered challenges:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime errors"}),": The lack of compile-time type checking meant many errors weren't caught until execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance challenges"}),": The very features that made Rails expressive often came with performance costs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Magic"}),': Rails\' "convention over configuration" sometimes felt like "magic" that was hard to debug']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing burden"}),": Without type checks, comprehensive test coverage became absolutely essential"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-rise-of-typed-functional-languages",children:"The Rise of Typed Functional Languages"}),"\n",(0,i.jsx)(n.p,{children:'The pendulum then swung in the other direction. Languages like Scala, Haskell, and later TypeScript gained popularity partly as a reaction to the perceived "unsafety" of dynamic languages like Ruby.'}),"\n",(0,i.jsx)(n.p,{children:"Consider this Scala example using the Play Framework:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'def getUser(id: Long) = Action { \n  userRepository.findById(id) match {\n    case Some(user) => Ok(Json.toJson(user))\n    case None => NotFound("User not found")\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This code benefits from strong typing and pattern matching, but loses some of the immediate readability that made Rails so appealing."}),"\n",(0,i.jsx)(n.h2,{id:"the-best-of-both-worlds-kotlin-dsls",children:"The Best of Both Worlds: Kotlin DSLs"}),"\n",(0,i.jsx)(n.p,{children:"Kotlin emerged as a language that could provide the safety of static typing with the expressiveness of a modern language. Its support for DSLs (Domain Specific Languages) opened up new possibilities for frameworks."}),"\n",(0,i.jsx)(n.p,{children:"Here's a simple example using Kotlin's built-in HTML DSL:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'html {\n    head {\n        title("My Page")\n    }\n    body {\n        h1 { +"Welcome" }\n        p { +"This is a paragraph" }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This code is both expressive and type-safe. Errors like misspelling a tag name or using the wrong nesting structure would be caught at compile time."}),"\n",(0,i.jsx)(n.h2,{id:"snitch-pushing-the-boundaries-of-expressive-type-safe-code",children:"Snitch: Pushing the Boundaries of Expressive, Type-Safe Code"}),"\n",(0,i.jsx)(n.p,{children:"Snitch takes the concept of expressive, type-safe DSLs to a new level for HTTP APIs. Let's compare a typical REST endpoint in some popular frameworks to see the evolution:"}),"\n",(0,i.jsx)(n.h3,{id:"spring-boot-java",children:"Spring Boot (Java)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/users")\npublic class UserController {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @GetMapping("/{id}")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return userRepository.findById(id)\n            .map(user -> ResponseEntity.ok(user))\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @PostMapping\n    @PreAuthorize("hasRole(\'ADMIN\')")\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO userDTO) {\n        User user = new User(userDTO.getName(), userDTO.getEmail());\n        User savedUser = userRepository.save(user);\n        return ResponseEntity.created(URI.create("/api/users/" + savedUser.getId()))\n            .body(savedUser);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ktor-kotlin",children:"Ktor (Kotlin)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'routing {\n    route("/api/users") {\n        get("/{id}") {\n            val id = call.parameters["id"]?.toLongOrNull()\n            if (id == null) {\n                call.respond(HttpStatusCode.BadRequest, "Invalid ID format")\n                return@get\n            }\n            \n            val user = userRepository.findById(id)\n            if (user != null) {\n                call.respond(user)\n            } else {\n                call.respond(HttpStatusCode.NotFound, "User not found")\n            }\n        }\n        \n        authenticate {\n            post {\n                val userDTO = call.receive<UserDTO>()\n                if (!isAdmin(call.principal)) {\n                    call.respond(HttpStatusCode.Forbidden)\n                    return@post\n                }\n                \n                val user = User(userDTO.name, userDTO.email)\n                val savedUser = userRepository.save(user)\n                call.respond(HttpStatusCode.Created, savedUser)\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"snitch-kotlin",children:"Snitch (Kotlin)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val userId by path(ofLong)\nval userDTO by body<UserDTO>()\n\nval usersRouter = routes {\n    "api" / "users" / {\n        GET(userId) isHandledBy {\n            userRepository.findById(request[userId])\n                ?.ok\n                ?: "User not found".notFound()\n        }\n        \n        POST() with userDTO onlyIf hasAdminRole isHandledBy {\n            val user = User(request[userDTO].name, request[userDTO].email)\n            val savedUser = userRepository.save(user)\n            savedUser.created\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Snitch's approach offers several distinctive advantages for expressivity while maintaining type safety:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Declarative path definition"}),": Routes are defined hierarchically and read naturally from left to right"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter declaration separation"}),": Parameters are defined once and reused, reducing repetition"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Infix notation"}),": ",(0,i.jsx)(n.code,{children:"isHandledBy"}),", ",(0,i.jsx)(n.code,{children:"with"}),", and ",(0,i.jsx)(n.code,{children:"onlyIf"})," create an almost English-like readability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result DSL"}),": ",(0,i.jsx)(n.code,{children:".ok"}),", ",(0,i.jsx)(n.code,{children:".notFound()"}),", and ",(0,i.jsx)(n.code,{children:".created"})," make response codes clear and concise"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type safety throughout"}),": From parameter parsing to handler execution, everything is type-checked"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No annotations"}),": Logic flows naturally without being broken up by annotations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Composability"}),": Routes can be modularized and composed easily"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"expressivity-and-scaling-an-unexpected-synergy",children:"Expressivity and Scaling: An Unexpected Synergy"}),"\n",(0,i.jsx)(n.p,{children:"Here's where Snitch truly shines - as your API grows more complex, Snitch's expressivity becomes even more valuable, not less."}),"\n",(0,i.jsx)(n.p,{children:"Consider a more complex API with nested resources, multiple role-based permissions, and sophisticated validation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val userId by path(ofLong)\nval postId by path(ofLong)\nval commentId by path(ofLong)\nval limit by query(ofIntRange(1, 100), default = 20)\nval offset by query(ofNonNegativeInt, default = 0)\nval postBody by body<CreatePostRequest>()\nval commentBody by body<CreateCommentRequest>()\n\nval apiRoutes = routes {\n    "api" / "v1" / {\n        "users" / userId / {\n            GET() onlyIf (isResourceOwner(userId) or hasAdminRole) isHandledBy { \n                getUserProfile() \n            }\n            \n            "posts" / {\n                GET() withQueries(limit, offset) isHandledBy { \n                    getUserPosts() \n                }\n                \n                POST() with postBody onlyIf isResourceOwner(userId) isHandledBy { \n                    createPost() \n                }\n                \n                postId / {\n                    GET() isHandledBy { \n                        getPost() \n                    }\n                    \n                    PUT() with postBody onlyIf (\n                        isResourceOwner(userId) and isPostOwner(postId)\n                    ) isHandledBy { \n                        updatePost() \n                    }\n                    \n                    "comments" / {\n                        GET() withQueries(limit, offset) isHandledBy { \n                            getPostComments() \n                        }\n                        \n                        POST() with commentBody onlyIf isAuthenticated isHandledBy {\n                            createComment() \n                        }\n                        \n                        commentId / {\n                            DELETE() onlyIf (\n                                isCommentAuthor(commentId) or \n                                isPostOwner(postId) or \n                                hasModeratorRole\n                            ) isHandledBy { \n                                deleteComment() \n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Despite the complexity of this API, the code remains remarkably readable. You can trace the URL structure visually through the nesting, see the HTTP methods at a glance, and understand the authorization rules directly in the route definitions."}),"\n",(0,i.jsxs)(n.p,{children:["This is where the true value proposition of Snitch emerges: ",(0,i.jsx)(n.strong,{children:"as complexity increases, the code doesn't degrade into an unreadable mess - it maintains its clarity and expressiveness."})]}),"\n",(0,i.jsx)(n.h2,{id:"the-unfair-advantage-type-safety--expressivity",children:"The Unfair Advantage: Type Safety + Expressivity"}),"\n",(0,i.jsx)(n.p,{children:'Most frameworks force you to choose between expressivity and type safety. Snitch gives you both, creating what we might call an "unfair advantage" in three key areas:'}),"\n",(0,i.jsx)(n.h3,{id:"1-error-prevention",children:"1. Error Prevention"}),"\n",(0,i.jsx)(n.p,{children:"Traditional expressive frameworks like Rails and Express catch errors at runtime. Snitch catches them at compile time:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// This would not compile - userId is not defined\nGET(userId) isHandledBy { getUserProfile() }\n\n// This would not compile - wrong parameter type\nval userId by path(ofString)\nuserRepository.findById(request[userId].toLong()) // Type mismatch\n\n// This would not compile - missing required parameter\nPOST() isHandledBy { createUser() } // Body parameter missing\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-refactoring-confidence",children:"2. Refactoring Confidence"}),"\n",(0,i.jsx)(n.p,{children:"When you need to refactor a large API, type safety is invaluable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// Rename a parameter\nval oldUserId by path(ofLong) // Deprecated\nval userId by path(ofLong) // New name\n\n// The compiler will flag every place oldUserId is used\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-self-documenting-code",children:"3. Self-Documenting Code"}),"\n",(0,i.jsx)(n.p,{children:"Snitch's expressive DSL makes the code itself excellent documentation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// The route structure visually represents the URL hierarchy\n// HTTP methods are capitalized and stand out\n// Parameters are clearly defined\n// Authorization rules are spelled out in the route definition\n"})}),"\n",(0,i.jsx)(n.p,{children:"And because Snitch automatically generates OpenAPI documentation from this code, your API docs are always in sync with the implementation."}),"\n",(0,i.jsx)(n.h2,{id:"industry-impact-changing-how-we-think-about-api-development",children:"Industry Impact: Changing How We Think About API Development"}),"\n",(0,i.jsx)(n.p,{children:"The combination of expressivity and type safety in Snitch has potential implications for the entire field of API development:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced testing burden"}),": With many errors caught at compile time, tests can focus on business logic rather than basic type checking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Improved developer experience"}),": Frameworks that prioritize both safety and expressivity will set a new standard for developer experience"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"More maintainable codebases"}),": As projects age, the value of self-documenting, type-safe code increases dramatically"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster onboarding"}),": New team members can understand the API structure more quickly and make contributions with greater confidence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Higher quality APIs"}),": By making good practices the easy path, frameworks like Snitch nudge developers toward better API design"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion-expressivity-as-a-competitive-advantage",children:"Conclusion: Expressivity as a Competitive Advantage"}),"\n",(0,i.jsx)(n.p,{children:"In the early days of web development, expressivity was often seen as a nice-to-have feature - something that made developers happy but didn't necessarily contribute to business outcomes. Today, we understand that expressive, maintainable code is a genuine competitive advantage:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It allows teams to respond more quickly to changing requirements"}),"\n",(0,i.jsx)(n.li,{children:"It reduces bugs and security vulnerabilities"}),"\n",(0,i.jsx)(n.li,{children:"It makes it easier to attract and retain talented developers"}),"\n",(0,i.jsx)(n.li,{children:"It lowers the long-term cost of maintenance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Snitch demonstrates that expressivity and type safety are not opposing forces but complementary strengths. By bringing them together in a cohesive framework, Snitch offers a glimpse of the future of API development - one where we no longer have to choose between code that is a joy to write and code that scales robustly."}),"\n",(0,i.jsx)(n.p,{children:"As the complexity of our systems continues to grow, frameworks that help us manage that complexity without sacrificing readability will become increasingly valuable. Snitch isn't just a more pleasant way to build APIs - it's a more sustainable approach to software development in an increasingly complex world."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},6365:e=>{e.exports=JSON.parse('{"permalink":"/snitch/blog/expressivity-and-scaling-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2023-05-28-expressivity-and-scaling-with-snitch.md","source":"@site/blog/2023-05-28-expressivity-and-scaling-with-snitch.md","title":"Expressive Code at Scale: How Snitch Transforms API Development","description":"In the world of software development, there\'s a persistent myth that we must choose between code that is pleasant to write and code that scales well technically. Many believe that as systems grow, elegance must give way to verbosity, and expressivity must be sacrificed for safety and performance.","date":"2023-05-28T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/snitch/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Expressivity","permalink":"/snitch/blog/tags/expressivity","description":"Articles about expressive code and API design"},{"inline":false,"label":"Code Quality","permalink":"/snitch/blog/tags/code-quality","description":"Articles about improving code readability, maintainability, and quality"},{"inline":false,"label":"Scaling","permalink":"/snitch/blog/tags/scaling","description":"Content about scaling applications and architecture"},{"inline":false,"label":"DSL","permalink":"/snitch/blog/tags/dsl","description":"Articles about Domain Specific Languages and their applications"},{"inline":false,"label":"Type Safety","permalink":"/snitch/blog/tags/type-safety","description":"Articles about type systems and compile-time safety"}],"readingTime":8.475,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/snitch/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"expressivity-and-scaling-with-snitch","title":"Expressive Code at Scale: How Snitch Transforms API Development","authors":["snitch-team"],"tags":["snitch","expressivity","code-quality","scaling","dsl","type-safety"]},"unlisted":false,"prevItem":{"title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","permalink":"/snitch/blog/typesafe-validation-with-snitch"},"nextItem":{"title":"Migration Guide: From Spring Boot to Snitch","permalink":"/snitch/blog/migrating-from-spring-to-snitch"}}')},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);