"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[1180],{4159:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"in depth/Mastering-Snitch-Decorations","title":"Decorations","description":"Decorations are a powerful feature in Snitch that allow you to modify request handling behavior across multiple routes. They provide a clean, composable way to implement cross-cutting concerns like logging, authentication, transaction management, and more. This tutorial will guide you through everything you need to know about decorations, from basic usage to advanced patterns.","source":"@site/docs/in depth/Mastering-Snitch-Decorations.md","sourceDirName":"in depth","slug":"/in depth/Mastering-Snitch-Decorations","permalink":"/docs/in depth/Mastering-Snitch-Decorations","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/in depth/Mastering-Snitch-Decorations.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Conditions","permalink":"/docs/in depth/Mastering-Snitch-Conditions"},"next":{"title":"Parameters","permalink":"/docs/in depth/Mastering-Snitch-Parameters"}}');var o=i(4848),a=i(8453);const r={},s="Decorations",c={},d=[{value:"Understanding Decorations",id:"understanding-decorations",level:2},{value:"Basic Decoration Usage",id:"basic-decoration-usage",level:2},{value:"Creating Custom Decorations",id:"creating-custom-decorations",level:2},{value:"Parameterized Decorations",id:"parameterized-decorations",level:3},{value:"Decoration Composition",id:"decoration-composition",level:2},{value:"Composition Properties",id:"composition-properties",level:3},{value:"Nesting Decorations",id:"nesting-decorations",level:2},{value:"Decoration Order and Execution Flow",id:"decoration-order-and-execution-flow",level:2},{value:"Integration with Conditions",id:"integration-with-conditions",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Logging",id:"logging",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Transaction Management",id:"transaction-management",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Response Transformation",id:"response-transformation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Decorations Focused",id:"1-keep-decorations-focused",level:3},{value:"2. Use Composition for Complex Behavior",id:"2-use-composition-for-complex-behavior",level:3},{value:"3. Be Mindful of Decoration Order",id:"3-be-mindful-of-decoration-order",level:3},{value:"4. Always Call <code>next()</code> Unless Short-Circuiting",id:"4-always-call-next-unless-short-circuiting",level:3},{value:"5. Handle Exceptions Appropriately",id:"5-handle-exceptions-appropriately",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:3},{value:"Logging with Transaction Management",id:"logging-with-transaction-management",level:3},{value:"API Versioning",id:"api-versioning",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Caching",id:"caching",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"decorations",children:"Decorations"})}),"\n",(0,o.jsx)(n.p,{children:"Decorations are a powerful feature in Snitch that allow you to modify request handling behavior across multiple routes. They provide a clean, composable way to implement cross-cutting concerns like logging, authentication, transaction management, and more. This tutorial will guide you through everything you need to know about decorations, from basic usage to advanced patterns."}),"\n",(0,o.jsx)(n.h2,{id:"understanding-decorations",children:"Understanding Decorations"}),"\n",(0,o.jsx)(n.p,{children:"In Snitch, a decoration is a higher-order function that wraps around route handlers to modify their behavior. Decorations can:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Execute code before the handler runs"}),"\n",(0,o.jsx)(n.li,{children:"Execute code after the handler runs"}),"\n",(0,o.jsx)(n.li,{children:"Transform the response from the handler"}),"\n",(0,o.jsx)(n.li,{children:"Short-circuit the request and return a response without calling the handler"}),"\n",(0,o.jsx)(n.li,{children:"Handle exceptions thrown by the handler"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Decorations are implemented using the ",(0,o.jsx)(n.code,{children:"decorateWith"})," function, which creates a decorator that can be applied to routes or route hierarchies."]}),"\n",(0,o.jsx)(n.h2,{id:"basic-decoration-usage",children:"Basic Decoration Usage"}),"\n",(0,o.jsx)(n.p,{children:"The simplest way to use decorations is to apply them to a route or route hierarchy:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val logged = decorateWith {\n    val method = request.method.name\n    val path = request.path\n    Logger.info("Begin Request: $method $path")\n    next().also {\n        Logger.info("End Request: $method $path ${it.statusCode.code}")\n    }\n}\n\nval routes = routes {\n    logged {\n        GET("hello").isHandledBy { "Hello, world!".ok }\n        POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, all requests to ",(0,o.jsx)(n.code,{children:"/hello"})," and ",(0,o.jsx)(n.code,{children:"/users"})," will be logged before and after handling."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-decorations",children:"Creating Custom Decorations"}),"\n",(0,o.jsxs)(n.p,{children:["You can create custom decorations using the ",(0,o.jsx)(n.code,{children:"decorateWith"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val withTransaction = decorateWith { \n    transaction { \n        next() \n    } \n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The lambda passed to ",(0,o.jsx)(n.code,{children:"decorateWith"})," receives a ",(0,o.jsx)(n.code,{children:"RequestWrapper"})," implicitly and should call ",(0,o.jsx)(n.code,{children:"next()"})," to execute the next decoration or handler in the chain. It should return a ",(0,o.jsx)(n.code,{children:"Response"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"parameterized-decorations",children:"Parameterized Decorations"}),"\n",(0,o.jsx)(n.p,{children:"You can create reusable decoration factories that accept parameters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'fun withMetricLabel(label: String) = decorateWith {\n    val startTime = System.currentTimeMillis()\n    val response = next()\n    val endTime = System.currentTimeMillis()\n    metrics.record(label, endTime - startTime)\n    response\n}\n\n// Usage\nwithMetricLabel("user-service") {\n    GET("users").isHandledBy { getUsers() }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"decoration-composition",children:"Decoration Composition"}),"\n",(0,o.jsxs)(n.p,{children:["One of the most powerful features of Snitch decorations is their composability. You can combine multiple decorations using the ",(0,o.jsx)(n.code,{children:"+"})," operator:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val combinedDecoration = withTransaction + logged\n\n// Execution order:\n// 1. withTransaction (applied first)\n// 2. logged (applied second)\n// 3. handler\n"})}),"\n",(0,o.jsx)(n.p,{children:"When decorations are composed, they are applied from right to left. In the example above, the execution order would be:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"withTransaction"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"logged"})}),"\n",(0,o.jsx)(n.li,{children:"The actual handler"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This means that the request flows through the decorations in the order they are composed, and the response flows back in the reverse order."}),"\n",(0,o.jsx)(n.h3,{id:"composition-properties",children:"Composition Properties"}),"\n",(0,o.jsx)(n.p,{children:"Decoration composition has several important properties:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Associativity"}),": ",(0,o.jsx)(n.code,{children:"(a + b) + c"})," is equivalent to ",(0,o.jsx)(n.code,{children:"a + (b + c)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Identity"}),": There exists an identity decoration that, when composed with any decoration, yields the original decoration"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Right-to-left evaluation"}),": In ",(0,o.jsx)(n.code,{children:"a + b + c"}),", decoration ",(0,o.jsx)(n.code,{children:"c"})," is applied first, then ",(0,o.jsx)(n.code,{children:"b"}),", then ",(0,o.jsx)(n.code,{children:"a"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These properties make decorations a powerful tool for building complex middleware chains."}),"\n",(0,o.jsx)(n.h2,{id:"nesting-decorations",children:"Nesting Decorations"}),"\n",(0,o.jsx)(n.p,{children:"In addition to composition, decorations can also be nested:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'logged {\n    withTransaction {\n        GET("users").isHandledBy { getUsers() }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"When decorations are nested, they are applied from outside to inside. In the example above, the execution order would be:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"logged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"withTransaction"})}),"\n",(0,o.jsx)(n.li,{children:"The actual handler"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This is different from composition, where the order is right to left."}),"\n",(0,o.jsx)(n.h2,{id:"decoration-order-and-execution-flow",children:"Decoration Order and Execution Flow"}),"\n",(0,o.jsx)(n.p,{children:"Understanding the execution flow of decorations is crucial for using them effectively. Let's look at a more complex example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// Composition\n(decoration1 + decoration2) {\n    // Nesting\n    decoration3 {\n        GET("hello").isHandledBy { "Hello, world!".ok }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the execution order would be:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"decoration2"})," (from composition, right to left)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"decoration1"})," (from composition, right to left)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"decoration3"})," (from nesting, outside to inside)"]}),"\n",(0,o.jsx)(n.li,{children:"The actual handler"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"And the response would flow back in the reverse order:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"The actual handler"}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"decoration3"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"decoration1"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"decoration2"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This allows you to create sophisticated middleware chains with precise control over the execution order."}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-conditions",children:"Integration with Conditions"}),"\n",(0,o.jsxs)(n.p,{children:["Decorations work seamlessly with Snitch's condition system. You can use the ",(0,o.jsx)(n.code,{children:"transformEndpoints"})," function to create decorations that also add parameters and apply conditions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val authenticated = transformEndpoints {\n    with(listOf(accessToken)).decorated {\n        when (request[accessToken]) {\n            is Authentication.Authenticated -> next()\n            is Authentication.Unauthenticated -> UNAUTHORIZED()\n        }\n    }\n}\n\n// Usage\nauthenticated {\n    GET("profile").isHandledBy { getProfile() }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This approach is particularly useful for authentication and authorization, where you need to both add parameters (like access tokens) and check conditions before proceeding."}),"\n",(0,o.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,o.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val logged = decorateWith {\n    val method = request.method.name\n    val path = request.path\n    Logger.info("Begin Request: $method $path")\n    next().also {\n        Logger.info("End Request: $method $path ${it.statusCode.code}")\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// Define auth token parameter\nval authToken by header("X-Auth-Token")\n\n// Authentication decoration\nval authenticated = decorateWith(authToken) {\n    when (request[authToken]) {\n        "user-token" -> next()\n        null -> "Unauthorized".unauthorized()\n        else -> "Unauthorized".unauthorized()\n    }\n\n}\n\n// Role-based authorization\nval requireAdmin = decorateWith(authToken) {\n    val token = request[authToken]\n    if (token == "admin-token") {\n        next()\n    } else {\n        "Forbidden - Admin access required".forbidden()\n    }\n}\n\n// Usage\nauthenticated {\n    // Public endpoint - just needs authentication\n    GET("profile").isHandledBy { "User profile".ok }\n\n    // Admin endpoint - needs both authentication and admin role\n    requireAdmin {\n        GET("admin/dashboard").isHandledBy { "Admin dashboard".ok }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"transaction-management",children:"Transaction Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val withTransaction = decorateWith { \n    transaction { \n        next() \n    } \n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val handleErrors = decorateWith {\n    try {\n        next()\n    } catch (e: Exception) {\n        logger.error("Error handling request: ${e.message}")\n        "Internal server error".serverError()\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"response-transformation",children:"Response Transformation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val addCorsHeaders = decorateWith {\n    val response = next()\n    response.copy(\n        headers = response.headers + mapOf(\n            "Access-Control-Allow-Origin" to "*",\n            "Access-Control-Allow-Methods" to "GET, POST, PUT, DELETE, OPTIONS",\n            "Access-Control-Allow-Headers" to "Content-Type, Authorization"\n        )\n    )\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"1-keep-decorations-focused",children:"1. Keep Decorations Focused"}),"\n",(0,o.jsx)(n.p,{children:"Each decoration should handle one specific concern. This makes them more reusable and easier to understand."}),"\n",(0,o.jsx)(n.h3,{id:"2-use-composition-for-complex-behavior",children:"2. Use Composition for Complex Behavior"}),"\n",(0,o.jsx)(n.p,{children:"Instead of creating complex decorations, compose simple ones:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// Good\nval combinedDecoration = logged + withTransaction\n\n// Not as good\nval complexDecoration = decorateWith {\n    logger().info("Request started")\n    transaction { \n        next() \n    }.also {\n        logger().info("Request completed")\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"3-be-mindful-of-decoration-order",children:"3. Be Mindful of Decoration Order"}),"\n",(0,o.jsx)(n.p,{children:"The order of decorations matters. For example, if you want to measure the time including transaction overhead, you would do:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val measureTime + withTransaction\n"})}),"\n",(0,o.jsx)(n.p,{children:"But if you want to measure only the time spent in the handler, excluding transaction overhead, you would do:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val withTransaction + measureTime\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"4-always-call-next-unless-short-circuiting",children:["4. Always Call ",(0,o.jsx)(n.code,{children:"next()"})," Unless Short-Circuiting"]}),"\n",(0,o.jsxs)(n.p,{children:["If your decoration doesn't call ",(0,o.jsx)(n.code,{children:"next()"}),", the handler will never be executed. This is useful for short-circuiting (e.g., for authentication), but make sure it's intentional."]}),"\n",(0,o.jsx)(n.h3,{id:"5-handle-exceptions-appropriately",children:"5. Handle Exceptions Appropriately"}),"\n",(0,o.jsxs)(n.p,{children:["If your decoration might throw exceptions, consider wrapping the ",(0,o.jsx)(n.code,{children:"next()"})," call in a try-catch block to ensure proper cleanup."]}),"\n",(0,o.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,o.jsx)(n.h3,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,o.jsx)(n.p,{children:"Looking at a real-world example from a production codebase:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// Authentication decoration\nval authenticated = transformEndpoints {\n    with(listOf(accessToken)).decorated {\n        when (request[accessToken]) {\n            is Authentication.Authenticated -> next()\n            is Authentication.Unauthenticated -> UNAUTHORIZED()\n        }\n    }\n}\n\n// Access to user principal and role\nval RequestWrapper.principal: UserId get() = \n    (request[accessToken] as Authentication.Authenticated).claims.userId\nval RequestWrapper.role: Role get() = \n    (request[accessToken] as Authentication.Authenticated).claims.role\n\n// Condition for checking principal equality\nfun principalEquals(param: Parameter<out Any, *>) = condition("Principal equals ${param.name}") {\n    if (principal.value == params(param.name)) Successful\n    else Failed(FORBIDDEN())\n}\n\n// Usage in routes\nval usersController = routes {\n    withTransaction {\n        POST() with body<CreateUserRequest>() isHandledBy createUser\n        \n        userId / "posts" / {\n            authenticated {\n                GET() onlyIf principalEquals(userId) isHandledBy getPosts\n                POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost\n            }\n        }\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This example shows how decorations (",(0,o.jsx)(n.code,{children:"withTransaction"}),", ",(0,o.jsx)(n.code,{children:"authenticated"}),") can be combined with conditions (",(0,o.jsx)(n.code,{children:"principalEquals"}),") to create a comprehensive authentication and authorization system."]}),"\n",(0,o.jsx)(n.h3,{id:"logging-with-transaction-management",children:"Logging with Transaction Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'val routes = routes {\n    logged {\n        withTransaction {\n            GET("users").isHandledBy { getUsers() }\n            POST("users").with(body<CreateUserRequest>()).isHandledBy { createUser() }\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"api-versioning",children:"API Versioning"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'fun withApiVersion(version: Int) = decorateWith {\n    request.attributes["apiVersion"] = version\n    next()\n}\n\n// Usage\nval routes = routes {\n    withApiVersion(1) {\n        GET("api/users").isHandledBy { getUsersV1() }\n    }\n    \n    withApiVersion(2) {\n        GET("api/users").isHandledBy { getUsersV2() }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'fun rateLimit(maxRequests: Int, perTimeWindow: Duration) = decorateWith {\n    val clientIp = request.undertow.exchange.sourceAddress.address.hostAddress\n    val requestCount = rateLimiter.getRequestCount(clientIp, perTimeWindow)\n    \n    if (requestCount >= maxRequests) {\n        return@decorateWith "Rate limit exceeded. Try again later.".error(TOO_MANY_REQUESTS)\n    }\n    \n    rateLimiter.incrementRequestCount(clientIp)\n    next()\n}\n\n// Usage\nrateLimit(2, Duration.ofMinutes(1)) {\n    GET("api/messages").isHandledBy { "Messages".ok }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"caching",children:"Caching"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'fun cache(ttl: Duration) = decorateWith {\n    val cacheKey = "${request.method.name}-${request.path}"\n    val cachedResponse = cacheService.get(cacheKey)\n\n    if (cachedResponse != null) {\n        return@decorateWith RawHttpResponse(StatusCodes.OK, cachedResponse)\n    }\n\n    val response = next()\n    cacheService.put(cacheKey, response.value(parser) as String, ttl)\n    response\n}\n\n// Usage\ncache(Duration.ofMinutes(5)) {\n    GET("api/products").isHandledBy { getProducts() }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application. By mastering Snitch's decoration system, you can implement sophisticated middleware chains with minimal code, keeping your routes clean and focused on business logic. Decorations provide a powerful, composable way to handle cross-cutting concerns in your application."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);