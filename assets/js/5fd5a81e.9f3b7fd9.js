"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[66],{8400:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorials/ShankInAction","title":"Shank in Action: Building a Real-World Application","description":"This tutorial demonstrates how to use Shank, Snitch\'s powerful dependency injection library, to build a maintainable and testable real-world application. We\'ll create a blog platform with user authentication, post management, and comments.","source":"@site/docs/tutorials/ShankInAction.md","sourceDirName":"tutorials","slug":"/tutorials/ShankInAction","permalink":"/docs/tutorials/ShankInAction","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/ShankInAction.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Snitch Quick Start Guide","permalink":"/docs/tutorials/QuickStart"},"next":{"title":"Advanced Shank Design Patterns","permalink":"/docs/tutorials/ShankPatterns"}}');var o=t(4848),a=t(8453);const s={},r="Shank in Action: Building a Real-World Application",l={},c=[{value:"What is Shank?",id:"what-is-shank",level:2},{value:"Project Setup",id:"project-setup",level:2},{value:"Domain Model",id:"domain-model",level:2},{value:"Setting Up Shank Modules",id:"setting-up-shank-modules",level:2},{value:"The Power of Shank: Service Layer",id:"the-power-of-shank-service-layer",level:2},{value:"API Layer with Snitch and Shank",id:"api-layer-with-snitch-and-shank",level:2},{value:"Application Entry Point",id:"application-entry-point",level:2},{value:"Testing with Shank",id:"testing-with-shank",level:2},{value:"Why Shank is Convenient",id:"why-shank-is-convenient",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"shank-in-action-building-a-real-world-application",children:"Shank in Action: Building a Real-World Application"})}),"\n",(0,o.jsx)(n.p,{children:"This tutorial demonstrates how to use Shank, Snitch's powerful dependency injection library, to build a maintainable and testable real-world application. We'll create a blog platform with user authentication, post management, and comments."}),"\n",(0,o.jsx)(n.h2,{id:"what-is-shank",children:"What is Shank?"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://github.com/memoizr/shank",children:"Shank"})," is a lightweight, high-performance dependency injection library for Kotlin that integrates seamlessly with Snitch. It provides:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Industry-leading performance"}),": Unmatched startup and runtime performance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Zero reflection"}),": No runtime overhead or class scanning"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Strict type safety"}),": Will never throw runtime exceptions related to types"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Polymorphism support"}),": Interface-based dependency injection"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Testing support"}),": Easy factory overriding for testing"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,o.jsx)(n.p,{children:"Let's start by setting up our project structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// build.gradle.kts\nplugins {\n    kotlin("jvm") version "1.9.0"\n    application\n}\n\ndependencies {\n    implementation("io.github.memoizr:snitch-bootstrap:2.0.0")\n    implementation("org.jetbrains.exposed:exposed-core:0.41.1")\n    implementation("org.jetbrains.exposed:exposed-dao:0.41.1")\n    implementation("org.jetbrains.exposed:exposed-jdbc:0.41.1")\n    implementation("org.postgresql:postgresql:42.6.0")\n    implementation("de.mkammerer:argon2-jvm:2.11")\n    \n    testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")\n    testImplementation("io.mockk:mockk:1.13.5")\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"domain-model",children:"Domain Model"}),"\n",(0,o.jsx)(n.p,{children:"First, let's define our domain models:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"// src/main/kotlin/blog/domain/models.kt\npackage blog.domain\n\nimport java.time.Instant\nimport java.util.UUID\n\ndata class User(\n    val id: UUID,\n    val username: String,\n    val email: String,\n    val createdAt: Instant\n)\n\ndata class Post(\n    val id: UUID,\n    val title: String,\n    val content: String,\n    val authorId: UUID,\n    val createdAt: Instant,\n    val updatedAt: Instant\n)\n\ndata class Comment(\n    val id: UUID,\n    val postId: UUID,\n    val authorId: UUID,\n    val content: String,\n    val createdAt: Instant\n)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"setting-up-shank-modules",children:"Setting Up Shank Modules"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's organize our application using Shank modules. This is where Shank's elegance and convenience really shine:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// src/main/kotlin/blog/infrastructure/ApplicationModule.kt\npackage blog.infrastructure\n\nimport blog.domain.Clock\nimport blog.domain.SystemClock\nimport snitch.shank.ShankModule\nimport snitch.shank.new\nimport snitch.shank.single\nimport java.time.Instant\n\nobject ApplicationModule : ShankModule {\n    // Core application dependencies\n    val clock = single<Clock> { -> SystemClock() }\n    \n    // Creates a new timestamp each time it\'s called\n    val now = new { -> Instant.now(clock().utc()) }\n    \n    // Logger is a singleton\n    val logger = single { -> LoggerFactory.getLogger("blog-app") }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Notice how we're using ",(0,o.jsx)(n.code,{children:"single"})," for dependencies that should have only one instance, and ",(0,o.jsx)(n.code,{children:"new"})," for dependencies that should be created fresh each time they're requested. This is one of Shank's conveniences - clear, explicit scoping."]}),"\n",(0,o.jsx)(n.p,{children:"Let's add our database module:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// src/main/kotlin/blog/infrastructure/DatabaseModule.kt\npackage blog.infrastructure\n\nimport org.jetbrains.exposed.sql.Database\nimport snitch.shank.ShankModule\nimport snitch.shank.single\n\nobject DatabaseModule : ShankModule {\n    // Database connection is a singleton\n    val connection = single { ->\n        Database.connect(\n            "jdbc:postgresql://localhost:5432/blog",\n            driver = "org.postgresql.Driver",\n            user = "postgres",\n            password = "postgres"\n        )\n    }\n    \n    // Database wrapper is a singleton\n    val database = single { -> PostgresDatabase(connection()) }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"And our repositories:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"// src/main/kotlin/blog/infrastructure/RepositoryModule.kt\npackage blog.infrastructure\n\nimport blog.domain.repositories.*\nimport blog.infrastructure.repositories.*\nimport snitch.shank.ShankModule\nimport snitch.shank.single\n\nobject RepositoryModule : ShankModule {\n    // Bind implementations to interfaces\n    val userRepository = single<UserRepository> { -> \n        PostgresUserRepository(\n            DatabaseModule.database(),\n            ApplicationModule.now()\n        ) \n    }\n    \n    val postRepository = single<PostRepository> { -> \n        PostgresPostRepository(\n            DatabaseModule.database(),\n            ApplicationModule.now()\n        ) \n    }\n    \n    val commentRepository = single<CommentRepository> { -> \n        PostgresCommentRepository(\n            DatabaseModule.database(),\n            ApplicationModule.now()\n        ) \n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Finally, let's add our security module:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// src/main/kotlin/blog/infrastructure/SecurityModule.kt\npackage blog.infrastructure\n\nimport de.mkammerer.argon2.Argon2Factory\nimport snitch.shank.ShankModule\nimport snitch.shank.single\nimport java.security.KeyPairGenerator\nimport java.security.interfaces.RSAPrivateCrtKey\n\nobject SecurityModule : ShankModule {\n    // Generate a key pair for JWT signing\n    val keyPair = single { ->\n        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")\n        keyPairGenerator.initialize(2048)\n        keyPairGenerator.genKeyPair()\n    }\n\n    // Extract keys from the key pair\n    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }\n    val publicKey = single { -> keyPair().public }\n    \n    // Password hashing\n    val argon = single { -> Argon2Factory.create() }\n    val passwordHasher = single<PasswordHasher> { -> Argon2PasswordHasher(argon()) }\n    \n    // JWT management\n    val jwtManager = single { -> JWTManager(privateKey(), publicKey()) }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"the-power-of-shank-service-layer",children:"The Power of Shank: Service Layer"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's create our service layer. This is where Shank's convenience becomes evident - we can easily compose our services using dependencies from different modules:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"// src/main/kotlin/blog/application/ServiceModule.kt\npackage blog.application\n\nimport blog.application.services.*\nimport blog.infrastructure.ApplicationModule\nimport blog.infrastructure.RepositoryModule\nimport blog.infrastructure.SecurityModule\nimport snitch.shank.ShankModule\nimport snitch.shank.single\n\nobject ServiceModule : ShankModule {\n    // User service with dependencies from multiple modules\n    val userService = single<UserService> { -> \n        UserServiceImpl(\n            RepositoryModule.userRepository(),\n            SecurityModule.passwordHasher(),\n            SecurityModule.jwtManager(),\n            ApplicationModule.now()\n        ) \n    }\n    \n    // Post service\n    val postService = single<PostService> { -> \n        PostServiceImpl(\n            RepositoryModule.postRepository(),\n            RepositoryModule.userRepository(),\n            ApplicationModule.now()\n        ) \n    }\n    \n    // Comment service\n    val commentService = single<CommentService> { -> \n        CommentServiceImpl(\n            RepositoryModule.commentRepository(),\n            RepositoryModule.postRepository(),\n            ApplicationModule.now()\n        ) \n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"api-layer-with-snitch-and-shank",children:"API Layer with Snitch and Shank"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's create our API layer using Snitch and Shank together:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// src/main/kotlin/blog/api/Router.kt\npackage blog.api\n\nimport blog.application.ServiceModule\nimport blog.domain.exceptions.NotFoundException\nimport blog.domain.exceptions.UnauthorizedException\nimport snitch.dsl.*\nimport snitch.dsl.response.*\nimport snitch.parsers.GsonJsonParser\nimport snitch.router.decorateWith\nimport snitch.service.RoutedService\nimport snitch.undertow.snitch\n\n// Request/response models\ndata class LoginRequest(val username: String, val password: String)\ndata class LoginResponse(val token: String)\n\ndata class CreatePostRequest(val title: String, val content: String)\ndata class PostResponse(val id: String, val title: String, val content: String, val author: String)\n\n// Path parameters\nval userId by path()\nval postId by path()\nval commentId by path()\n\n// Header parameters for authentication\nval accessToken by header(\n    condition = validAccessToken,\n    name = "Authorization",\n    description = "Bearer token for authentication"\n)\n\n// Validator for access token\nval validAccessToken = stringValidator { token ->\n    if (token.startsWith("Bearer ")) {\n        try {\n            // Use jwtManager from SecurityModule to validate the token\n            val jwtManager = SecurityModule.jwtManager()\n            val userId = jwtManager.validateToken(token.substring(7))\n            Authentication.Authenticated(userId)\n        } catch (e: Exception) {\n            Authentication.InvalidToken\n        }\n    } else {\n        Authentication.MissingToken\n    }\n}\n\n// Authentication result model\nsealed interface Authentication {\n    data class Authenticated(val userId: String) : Authentication\n    interface Unauthenticated : Authentication\n    object InvalidToken : Unauthenticated\n    object MissingToken : Unauthenticated\n}\n\n// Authentication middleware using Shank with proper parameter declaration\nval authenticated = decorateWith(accessToken) {\n    when (val auth = request[accessToken]) {\n        is Authentication.Authenticated -> {\n            // Set user ID in request attributes for use in handlers\n            request.attributes["userId"] = auth.userId\n            next()\n        }\n        is Authentication.Unauthenticated -> "Authentication required".unauthorized()\n    }\n}\n\n// Main router\nval router = routes {\n    "api" / {\n        "auth" / {\n            // Login endpoint\n            POST("login") with body<LoginRequest>() isHandledBy {\n                val userService = ServiceModule.userService()\n                try {\n                    val token = userService.login(body.username, body.password)\n                    LoginResponse(token).ok\n                } catch (e: UnauthorizedException) {\n                    "Invalid credentials".unauthorized()\n                }\n            }\n        }\n        \n        "posts" / {\n            // Get all posts\n            GET() isHandledBy {\n                val postService = ServiceModule.postService()\n                postService.getAllPosts().ok\n            }\n            \n            // Get post by ID\n            postId / {\n                GET() isHandledBy {\n                    val postService = ServiceModule.postService()\n                    try {\n                        val id = request[postId]\n                        postService.getPostById(id).ok\n                    } catch (e: NotFoundException) {\n                        "Post not found".notFound()\n                    }\n                }\n            }\n            \n            // Protected routes\n            authenticated {\n                // Create post\n                POST() with body<CreatePostRequest>() isHandledBy {\n                    val postService = ServiceModule.postService()\n                    val userId = request.attributes["userId"] as String\n                    val post = postService.createPost(userId, body.title, body.content)\n                    post.created\n                }\n                \n                // Update post\n                postId / {\n                    PUT() with body<CreatePostRequest>() isHandledBy {\n                        val postService = ServiceModule.postService()\n                        val userId = request.attributes["userId"] as String\n                        val id = request[postId]\n                        try {\n                            val post = postService.updatePost(id, userId, body.title, body.content)\n                            post.ok\n                        } catch (e: NotFoundException) {\n                            "Post not found".notFound()\n                        } catch (e: UnauthorizedException) {\n                            "Not authorized to update this post".forbidden()\n                        }\n                    }\n                    \n                    // Delete post\n                    DELETE() isHandledBy {\n                        val postService = ServiceModule.postService()\n                        val userId = request.attributes["userId"] as String\n                        val id = request[postId]\n                        try {\n                            postService.deletePost(id, userId)\n                            "Post deleted".ok\n                        } catch (e: NotFoundException) {\n                            "Post not found".notFound()\n                        } catch (e: UnauthorizedException) {\n                            "Not authorized to delete this post".forbidden()\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"application-entry-point",children:"Application Entry Point"}),"\n",(0,o.jsx)(n.p,{children:"Finally, let's create our application entry point:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"// src/main/kotlin/blog/Application.kt\npackage blog\n\nimport blog.api.router\nimport blog.infrastructure.DatabaseModule\nimport snitch.config.SnitchConfig\nimport snitch.parsers.GsonJsonParser\nimport snitch.undertow.snitch\n\nfun main() {\n    // Initialize database\n    val database = DatabaseModule.database()\n    database.createSchema()\n    \n    // Start the service\n    snitch(GsonJsonParser, SnitchConfig(port = 3000))\n        .onRoutes(router)\n        .handleExceptions()\n        .start()\n        .serveDocumenation()\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"testing-with-shank",children:"Testing with Shank"}),"\n",(0,o.jsx)(n.p,{children:"One of Shank's most convenient features is its support for testing. Let's see how to test our service layer:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'// src/test/kotlin/blog/application/services/UserServiceTest.kt\npackage blog.application.services\n\nimport blog.domain.User\nimport blog.domain.repositories.UserRepository\nimport blog.infrastructure.ApplicationModule\nimport blog.infrastructure.RepositoryModule\nimport blog.infrastructure.SecurityModule\nimport io.mockk.every\nimport io.mockk.mockk\nimport io.mockk.verify\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport java.time.Instant\nimport java.util.UUID\nimport kotlin.test.assertEquals\n\nclass UserServiceTest {\n    private val mockUserRepository = mockk<UserRepository>()\n    private val mockPasswordHasher = mockk<PasswordHasher>()\n    private val mockJwtManager = mockk<JwtManager>()\n    \n    @BeforeEach\n    fun setup() {\n        // Override real implementations with mocks\n        RepositoryModule.userRepository.overrideFactory { -> mockUserRepository }\n        SecurityModule.passwordHasher.overrideFactory { -> mockPasswordHasher }\n        SecurityModule.jwtManager.overrideFactory { -> mockJwtManager }\n        \n        // Set up a fixed timestamp for testing\n        val fixedInstant = Instant.parse("2023-01-01T00:00:00Z")\n        ApplicationModule.now.overrideFactory { -> fixedInstant }\n    }\n    \n    @AfterEach\n    fun tearDown() {\n        // Restore original implementations\n        RepositoryModule.userRepository.restore()\n        SecurityModule.passwordHasher.restore()\n        SecurityModule.jwtManager.restore()\n        ApplicationModule.now.restore()\n    }\n    \n    @Test\n    fun `login should return token when credentials are valid`() {\n        // Arrange\n        val username = "testuser"\n        val password = "password123"\n        val hashedPassword = "hashed_password"\n        val userId = UUID.randomUUID()\n        val token = "jwt_token"\n        \n        val user = User(\n            id = userId,\n            username = username,\n            email = "test@example.com",\n            createdAt = Instant.now()\n        )\n        \n        every { mockUserRepository.findByUsername(username) } returns user\n        every { mockPasswordHasher.verify(hashedPassword, password) } returns true\n        every { mockJwtManager.createToken(userId.toString()) } returns token\n        \n        // Act\n        val userService = ServiceModule.userService()\n        val result = userService.login(username, password)\n        \n        // Assert\n        assertEquals(token, result)\n        verify { mockUserRepository.findByUsername(username) }\n        verify { mockPasswordHasher.verify(hashedPassword, password) }\n        verify { mockJwtManager.createToken(userId.toString()) }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"why-shank-is-convenient",children:"Why Shank is Convenient"}),"\n",(0,o.jsx)(n.p,{children:"As you've seen throughout this tutorial, Shank offers several conveniences that make it an excellent choice for dependency injection in Snitch applications:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Explicit Dependencies"}),": Dependencies are clearly defined and easy to trace, making your code more maintainable."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"No Magic"}),": Unlike other DI frameworks, Shank doesn't use reflection or annotations, making it faster and more predictable."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Type Safety"}),": Shank leverages Kotlin's type system to ensure type safety at compile time."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Testability"}),": Shank's ability to override dependencies makes testing straightforward and reliable."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance"}),": Shank's lightweight design ensures minimal overhead, making it ideal for high-performance applications."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Modularity"}),": Shank encourages organizing your code into cohesive modules, improving code organization."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Flexibility"}),": Shank supports various dependency scopes (singleton, factory, scoped), giving you control over object lifecycles."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"In this tutorial, we've built a complete blog application using Snitch and Shank. We've seen how Shank's convenient dependency injection system makes it easy to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Organize code into logical modules"}),"\n",(0,o.jsx)(n.li,{children:"Manage dependencies between different parts of the application"}),"\n",(0,o.jsx)(n.li,{children:"Test components in isolation"}),"\n",(0,o.jsx)(n.li,{children:"Create maintainable and flexible code"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Shank's simplicity and power make it an excellent choice for dependency injection in Kotlin applications, especially when combined with Snitch's elegant routing and request handling."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(n.p,{children:"To further explore Shank and Snitch:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Check out the ",(0,o.jsx)(n.a,{href:"/docs/tutorials/ShankPatterns",children:"Shank Patterns"})," guide for advanced usage patterns"]}),"\n",(0,o.jsxs)(n.li,{children:["Explore the ",(0,o.jsx)(n.a,{href:"/docs/tutorials/UsingShank",children:"Using Shank"})," guide for more details on Shank's features"]}),"\n",(0,o.jsx)(n.li,{children:"Look at the example project in the repository for a complete working example"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);