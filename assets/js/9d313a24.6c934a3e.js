"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[1586],{1854:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"tutorials/Mastering-Snitch-BeforeAfter","title":"Mastering Snitch Before and After Actions","description":"The Before and After action mechanism in Snitch provides a powerful way to run code around your route handlers. It allows you to execute logic before a request is processed and after a response is generated, which is useful for cross-cutting concerns such as logging, authentication, authorization, and performance monitoring.","source":"@site/docs/tutorials/Mastering-Snitch-BeforeAfter.md","sourceDirName":"tutorials","slug":"/tutorials/Mastering-Snitch-BeforeAfter","permalink":"/docs/tutorials/Mastering-Snitch-BeforeAfter","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/Mastering-Snitch-BeforeAfter.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Anatomy of the Snitch Validator DSL","permalink":"/docs/tutorials/Anatomy-of-Validators"},"next":{"title":"Mastering Snitch Conditions","permalink":"/docs/tutorials/Mastering-Snitch-Conditions"}}');var t=r(4848),i=r(8453);const s={},a="Mastering Snitch Before and After Actions",l={},d=[{value:"Understanding Before and After Actions",id:"understanding-before-and-after-actions",level:2},{value:"Route-Level Actions",id:"route-level-actions",level:2},{value:"Defining Before Actions",id:"defining-before-actions",level:3},{value:"Defining After Actions",id:"defining-after-actions",level:3},{value:"Combining Before and After Actions",id:"combining-before-and-after-actions",level:3},{value:"Global Actions",id:"global-actions",level:2},{value:"Applying to Multiple Routes",id:"applying-to-multiple-routes",level:3},{value:"Execution Order",id:"execution-order",level:2},{value:"Order for Before Actions",id:"order-for-before-actions",level:3},{value:"Order for After Actions",id:"order-for-after-actions",level:3},{value:"Complete Execution Flow",id:"complete-execution-flow",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Exceptions in Before Actions",id:"exceptions-in-before-actions",level:3},{value:"Exceptions in Handlers",id:"exceptions-in-handlers",level:3},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Logging",id:"logging",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Request Metrics",id:"request-metrics",level:3},{value:"Database Transactions",id:"database-transactions",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Before and After Actions Focused",id:"1-keep-before-and-after-actions-focused",level:3},{value:"2. Use Global Actions for Cross-Cutting Concerns",id:"2-use-global-actions-for-cross-cutting-concerns",level:3},{value:"3. Be Careful with Response Modification",id:"3-be-careful-with-response-modification",level:3},{value:"4. Handle Errors Explicitly",id:"4-handle-errors-explicitly",level:3},{value:"5. Be Mindful of Execution Order",id:"5-be-mindful-of-execution-order",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mastering-snitch-before-and-after-actions",children:"Mastering Snitch Before and After Actions"})}),"\n",(0,t.jsx)(n.p,{children:"The Before and After action mechanism in Snitch provides a powerful way to run code around your route handlers. It allows you to execute logic before a request is processed and after a response is generated, which is useful for cross-cutting concerns such as logging, authentication, authorization, and performance monitoring."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-before-and-after-actions",children:"Understanding Before and After Actions"}),"\n",(0,t.jsx)(n.p,{children:"Before and After actions are similar to middleware in other frameworks. They allow you to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Before Actions"}),": Execute code before the route handler is called"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"After Actions"}),": Execute code after the route handler has completed and a response is generated"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These actions have full access to the request context, including path, query, and header parameters, and can also modify the response returned by the handler."}),"\n",(0,t.jsx)(n.h2,{id:"route-level-actions",children:"Route-Level Actions"}),"\n",(0,t.jsx)(n.p,{children:"Route-level actions are applied to individual routes, allowing for fine-grained control over which routes need specific pre- or post-processing."}),"\n",(0,t.jsx)(n.h3,{id:"defining-before-actions",children:"Defining Before Actions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId)\n    .doBefore { \n        // Code to run before the handler\n        logger.info("Accessing user: ${request[userId]}")\n    }\n    .isHandledBy {\n        // Handler code\n        userRepository.getUser(request[userId]).ok\n    }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"defining-after-actions",children:"Defining After Actions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId)\n    .doAfter { \n        // Code to run after the handler has generated a response\n        logger.info("User access completed with status: ${response.statusCode}")\n    }\n    .isHandledBy {\n        // Handler code\n        userRepository.getUser(request[userId]).ok\n    }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"combining-before-and-after-actions",children:"Combining Before and After Actions"}),"\n",(0,t.jsx)(n.p,{children:"You can chain multiple before and after actions on a single route:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId)\n    .doBefore { logger.info("Request started") }\n    .doBefore { metrics.incrementRequestCount() }\n    .doAfter { metrics.recordResponseTime() }\n    .doAfter { logger.info("Request completed") }\n    .isHandledBy {\n        userRepository.getUser(request[userId]).ok\n    }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"global-actions",children:"Global Actions"}),"\n",(0,t.jsx)(n.p,{children:"Global actions let you apply the same logic to multiple routes or across your entire application, reducing code duplication."}),"\n",(0,t.jsx)(n.h3,{id:"applying-to-multiple-routes",children:"Applying to Multiple Routes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'applyToAll_({\n    GET("users" / userId) isHandledBy getUserHandler\n    POST("users") with body<CreateUserRequest>() isHandledBy createUserHandler\n    PUT("users" / userId) with body<UpdateUserRequest>() isHandledBy updateUserHandler\n}) {\n    doBefore { \n        logger.info("${request.method} ${request.path} started")\n    }\n    doAfter { \n        logger.info("${request.method} ${request.path} completed with status ${response.statusCode}")\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"execution-order",children:"Execution Order"}),"\n",(0,t.jsx)(n.p,{children:"Understanding the execution order of before and after actions is crucial for building correct, predictable behavior."}),"\n",(0,t.jsx)(n.h3,{id:"order-for-before-actions",children:"Order for Before Actions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Before actions execute in reverse declaration order"})," (last declared, first executed)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Global before actions execute before route-level before actions"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'applyToAll_({\n    GET("foo")\n        .doBefore { /* Route before 1 */ }\n        .doBefore { /* Route before 2 */ }\n        .isHandledBy { /* Handler */ }\n}) {\n    doBefore { /* Global before 1 */ }\n    doBefore { /* Global before 2 */ }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Execution order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Global before 2"}),"\n",(0,t.jsx)(n.li,{children:"Global before 1"}),"\n",(0,t.jsx)(n.li,{children:"Route before 2"}),"\n",(0,t.jsx)(n.li,{children:"Route before 1"}),"\n",(0,t.jsx)(n.li,{children:"Handler"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"order-for-after-actions",children:"Order for After Actions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"After actions execute in declaration order"})," (first declared, first executed)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Route-level after actions execute before global after actions"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'applyToAll_({\n    GET("foo")\n        .doAfter { /* Route after 1 */ }\n        .doAfter { /* Route after 2 */ }\n        .isHandledBy { /* Handler */ }\n}) {\n    doAfter { /* Global after 1 */ }\n    doAfter { /* Global after 2 */ }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Execution order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Handler"}),"\n",(0,t.jsx)(n.li,{children:"Route after 1"}),"\n",(0,t.jsx)(n.li,{children:"Route after 2"}),"\n",(0,t.jsx)(n.li,{children:"Global after 1"}),"\n",(0,t.jsx)(n.li,{children:"Global after 2"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"complete-execution-flow",children:"Complete Execution Flow"}),"\n",(0,t.jsx)(n.p,{children:"The complete execution flow for a request is:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Global before actions (in reverse declaration order)"}),"\n",(0,t.jsx)(n.li,{children:"Route-level before actions (in reverse declaration order)"}),"\n",(0,t.jsx)(n.li,{children:"Route handler"}),"\n",(0,t.jsx)(n.li,{children:"Route-level after actions (in declaration order)"}),"\n",(0,t.jsx)(n.li,{children:"Global after actions (in declaration order)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"The behavior of before and after actions differs slightly when errors occur:"}),"\n",(0,t.jsx)(n.h3,{id:"exceptions-in-before-actions",children:"Exceptions in Before Actions"}),"\n",(0,t.jsx)(n.p,{children:"When an exception occurs in a before action:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The exception is caught and processed by any registered exception handlers"}),"\n",(0,t.jsxs)(n.li,{children:["The route handler is ",(0,t.jsx)(n.strong,{children:"not"})," executed"]}),"\n",(0,t.jsxs)(n.li,{children:["After actions are ",(0,t.jsx)(n.strong,{children:"not"})," executed automatically (as of the current implementation)"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("foo")\n    .doBefore { \n        throw RuntimeException("Error in before action")\n    }\n    .doAfter { \n        // Currently not executed when before action throws an exception\n    }\n    .isHandledBy {\n        // Not executed when before action throws an exception\n    }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"exceptions-in-handlers",children:"Exceptions in Handlers"}),"\n",(0,t.jsx)(n.p,{children:"When an exception occurs in a route handler:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The exception is caught and processed by any registered exception handlers"}),"\n",(0,t.jsxs)(n.li,{children:["After actions are ",(0,t.jsx)(n.strong,{children:"not"})," executed automatically (as of the current implementation)"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Register exception handler\nhandleException(RuntimeException::class) {\n    logger.error("Exception caught: ${it.message}")\n    "Error occurred".serverError()\n}\n\nGET("foo")\n    .doBefore { /* Executes normally */ }\n    .doAfter { \n        // Currently not executed when handler throws an exception\n    }\n    .isHandledBy {\n        throw RuntimeException("Error in handler")\n    }\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": According to the test file, there's a TODO comment indicating that after actions don't currently run in case of exceptions in before actions or handlers, but this behavior may be implemented in future versions."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"Before and after actions are ideal for many cross-cutting concerns:"}),"\n",(0,t.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val Router.withLogging get() = transformEndpoints {\n    doBefore { \n        logger.info("Request started: ${request.method} ${request.path}")\n        request.attributes["startTime"] = System.currentTimeMillis()\n    }\n    doAfter {\n        val startTime = request.attributes["startTime"] as Long\n        val duration = System.currentTimeMillis() - startTime\n        logger.info("Request completed: ${request.method} ${request.path} - ${response.statusCode} (${duration}ms)")\n    }\n}\n\n// Usage\nwithLogging {\n    GET("users") isHandledBy { /* handler */ }\n    POST("users") isHandledBy { /* handler */ }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val accessToken by header(validJwtValidator)\n\nval Router.authenticated get() = transformEndpoints {\n    with(queries(accessToken)).doBefore {\n        val token = request[accessToken]\n        if (token is Authentication.Unauthenticated) {\n            return@doBefore "Unauthorized".unauthorized()\n        }\n    }\n}\n\n// Usage\nauthenticated {\n    GET("profile") isHandledBy getUserProfile\n    PUT("settings") isHandledBy updateUserSettings\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"request-metrics",children:"Request Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val Router.withMetrics get() = transformEndpoints {\n    doBefore {\n        metrics.incrementRequestCount(request.path)\n        request.attributes["startTime"] = System.nanoTime()\n    }\n    doAfter {\n        val duration = System.nanoTime() - (request.attributes["startTime"] as Long)\n        metrics.recordResponseTime(request.path, duration)\n        metrics.recordStatusCode(request.path, response.statusCode.code)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"database-transactions",children:"Database Transactions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val Router.withTransaction get() = transformEndpoints {\n    doBefore {\n        transaction.begin()\n    }\n    doAfter {\n        if (response.isSuccessful()) {\n            transaction.commit()\n        } else {\n            transaction.rollback()\n        }\n    }\n}\n\n// Usage\nwithTransaction {\n    POST("orders") isHandledBy createOrder\n    PUT("orders" / orderId) isHandledBy updateOrder\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-keep-before-and-after-actions-focused",children:"1. Keep Before and After Actions Focused"}),"\n",(0,t.jsx)(n.p,{children:"Each before and after action should have a single responsibility. Instead of having one big action that does multiple things, chain smaller, focused actions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Good\nGET("users")\n    .doBefore { validateRequest() }\n    .doBefore { authenticate() }\n    .doBefore { authorize() }\n    .doAfter { logResponse() }\n    .doAfter { collectMetrics() }\n    .isHandledBy { /* handler */ }\n\n// Avoid\nGET("users")\n    .doBefore { \n        validateRequest()\n        authenticate()\n        authorize()\n    }\n    .doAfter { \n        logResponse()\n        collectMetrics()\n    }\n    .isHandledBy { /* handler */ }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-use-global-actions-for-cross-cutting-concerns",children:"2. Use Global Actions for Cross-Cutting Concerns"}),"\n",(0,t.jsx)(n.p,{children:"When actions need to be applied across multiple routes or your entire application, use global actions to reduce duplication:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Error logging applied to all routes\napplyToAll_({\n    // All your routes\n}) {\n    doAfter { \n        if (response.statusCode.isError()) {\n            logger.error("Error response: ${response.statusCode} - ${response.body}")\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-be-careful-with-response-modification",children:"3. Be Careful with Response Modification"}),"\n",(0,t.jsx)(n.p,{children:"After actions have the ability to modify the response. Use this power with care:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users")\n    .doAfter { \n        // Only modify the response when needed\n        if (response.statusCode.isSuccess() && response is JsonResponse) {\n            // Add additional info to JSON response\n            response.addAttribute("serverTime", System.currentTimeMillis())\n        }\n    }\n    .isHandledBy { /* handler */ }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-handle-errors-explicitly",children:"4. Handle Errors Explicitly"}),"\n",(0,t.jsx)(n.p,{children:"Be explicit about error handling in your before and after actions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users")\n    .doBefore { \n        try {\n            // Risky operation\n        } catch (e: Exception) {\n            logger.error("Error in before action", e)\n            return@doBefore "An error occurred".serverError()\n        }\n    }\n    .isHandledBy { /* handler */ }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"5-be-mindful-of-execution-order",children:"5. Be Mindful of Execution Order"}),"\n",(0,t.jsx)(n.p,{children:"Remember that before actions execute in reverse order and after actions execute in declaration order:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users")\n    // Executes third\n    .doBefore { logger.info("Authorization check") }\n    // Executes second\n    .doBefore { logger.info("Authentication check") }\n    // Executes first\n    .doBefore { logger.info("Request validation") }\n    \n    // Executes first after handler\n    .doAfter { logger.info("Log response") }\n    // Executes second after handler\n    .doAfter { logger.info("Collect metrics") }\n    \n    .isHandledBy { /* handler */ }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The Before and After action mechanism in Snitch provides a powerful way to organize cross-cutting concerns in your HTTP application. By understanding how these actions are executed and how they interact with exception handling, you can build clean, maintainable, and robust applications."}),"\n",(0,t.jsx)(n.p,{children:"Remember that actions should be focused, reusable, and predictable. Use global actions for common functionality and route-level actions for specific requirements. Be aware of the current limitations in error handling, and always consider the execution order when designing your action chains."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var o=r(6540);const t={},i=o.createContext(t);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);