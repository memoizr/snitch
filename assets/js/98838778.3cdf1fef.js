"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[2373],{1321:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"in depth/Database-Integration-With-Exposed","title":"In-Depth: Database Integration with Exposed","description":"This document provides an in-depth exploration of Snitch\'s integration with the Exposed SQL library, focusing on the technical aspects and internal workings of the implementation.","source":"@site/docs/in depth/Database-Integration-With-Exposed.md","sourceDirName":"in depth","slug":"/in depth/Database-Integration-With-Exposed","permalink":"/docs/in depth/Database-Integration-With-Exposed","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/in depth/Database-Integration-With-Exposed.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Validator DSL","permalink":"/docs/in depth/Anatomy-of-Validators"},"next":{"title":"Before and After Actions","permalink":"/docs/in depth/Mastering-Snitch-BeforeAfter"}}');var t=s(4848),a=s(8453);const r={},o="In-Depth: Database Integration with Exposed",l={},c=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"DatabaseConnectionConfig",id:"databaseconnectionconfig",level:3},{value:"ExposedModule",id:"exposedmodule",level:3},{value:"Transaction Management",id:"transaction-management",level:3},{value:"Object Mapping",id:"object-mapping",level:3},{value:"Schema Management",id:"schema-management",level:3},{value:"Database-Specific Implementations",id:"database-specific-implementations",level:2},{value:"H2 Integration",id:"h2-integration",level:3},{value:"PostgreSQL Integration",id:"postgresql-integration",level:3},{value:"Technical Deep Dive",id:"technical-deep-dive",level:2},{value:"Automatic Mapping Implementation",id:"automatic-mapping-implementation",level:3},{value:"Transaction Implementation",id:"transaction-implementation",level:3},{value:"Value Class Support",id:"value-class-support",level:3},{value:"Custom Type Mapping System",id:"custom-type-mapping-system",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Query Optimization",id:"query-optimization",level:3},{value:"Integration with Testing",id:"integration-with-testing",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Custom Column Types",id:"custom-column-types",level:3},{value:"Database Migration Strategies",id:"database-migration-strategies",level:3},{value:"Repository Pattern Implementation",id:"repository-pattern-implementation",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"in-depth-database-integration-with-exposed",children:"In-Depth: Database Integration with Exposed"})}),"\n",(0,t.jsx)(e.p,{children:"This document provides an in-depth exploration of Snitch's integration with the Exposed SQL library, focusing on the technical aspects and internal workings of the implementation."}),"\n",(0,t.jsx)(e.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,t.jsx)(e.p,{children:"Snitch's Exposed integration consists of three main modules:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"exposed"}),": Core module with the foundational abstractions and utilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"exposed-h2"}),": H2 database adapter for testing and development"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"exposed-postgres"}),": PostgreSQL adapter for production use"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The architecture follows these design principles:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Type safety"}),": Leveraging Kotlin's type system for database operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Automatic mapping"}),": Using reflection to minimize boilerplate"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transaction management"}),": Integrating with Snitch's routing system"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Database agnosticism"}),": Core abstractions work with any supported database"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(e.h3,{id:"databaseconnectionconfig",children:"DatabaseConnectionConfig"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"DatabaseConnectionConfig"})," class serves as the primary configuration point:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"data class DatabaseConnectionConfig(\n    val url: String,\n    val driver: String,\n    val user: String,\n    val password: String,\n    val setupConnection: ((Database) -> Unit)? = null,\n    val databaseConfig: DatabaseConfig? = null,\n    val manager: (Database) -> TransactionManager = { db -> TransactionManager.manager.defaultDatabase = db }\n)\n"})}),"\n",(0,t.jsx)(e.p,{children:"This configuration is used to establish a database connection and configure transaction management."}),"\n",(0,t.jsx)(e.h3,{id:"exposedmodule",children:"ExposedModule"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"ExposedModule"})," provides dependency injection support via Shank:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"object ExposedModule {\n    private val connectionProvider = single<DatabaseConnectionConfig, Database> { config ->\n        Database.connect(\n            url = config.url,\n            driver = config.driver,\n            user = config.user,\n            password = config.password,\n            databaseConfig = config.databaseConfig\n        ).also {\n            config.setupConnection?.invoke(it)\n            config.manager(it)\n        }\n    }\n\n    fun connection(config: DatabaseConnectionConfig): Database = connectionProvider(config)\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"This creates a singleton database connection that can be shared throughout your application."}),"\n",(0,t.jsx)(e.h3,{id:"transaction-management",children:"Transaction Management"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"withTransaction"})," decorator integrates transactions with route handlers:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"fun Routes.withTransaction(builder: TransactionalRoutes.() -> Unit) {\n    val routes = TransactionalRoutes().apply(builder)\n    routes.endpoints.forEach { addEndpoint(it) }\n}\n\nclass TransactionalRoutes : Routes() {\n    override fun <T : Any> addEndpoint(endpoint: Endpoint<T>) {\n        val wrappedHandler = { request: Request<T> ->\n            transaction {\n                endpoint.handler(request)\n            }\n        }\n        super.addEndpoint(endpoint.copy(handler = wrappedHandler))\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"This approach ensures that:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Each route handler executes within a transaction"}),"\n",(0,t.jsx)(e.li,{children:"Exceptions trigger automatic rollback"}),"\n",(0,t.jsx)(e.li,{children:"Successful execution commits the transaction"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"object-mapping",children:"Object Mapping"}),"\n",(0,t.jsxs)(e.p,{children:["The core of the automatic mapping system resides in the ",(0,t.jsx)(e.code,{children:"Mapping.kt"})," file, which provides:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Type Conversion"}),": Converting between domain models and database entities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Property Mapping"}),": Matching properties by name between objects"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Value Class Handling"}),": Supporting Kotlin's value classes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Custom Mapping"}),": Allowing user-defined conversions"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The mapping system uses Kotlin reflection to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Inspect property names and types"}),"\n",(0,t.jsx)(e.li,{children:"Match database columns to model properties"}),"\n",(0,t.jsx)(e.li,{children:"Perform appropriate type conversions"}),"\n",(0,t.jsx)(e.li,{children:"Handle nested objects and collections"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Key extension functions:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// Convert between similar objects\ninline fun <reified R : Any> Any.to(): R\n\n// Map ResultRow to domain model\nfun <T : ColumnSet, R : Any> ResultRow.to(from: T, to: KClass<R>): R\n\n// Insert domain model into table\nfun <R : Any> Table.insert(value: R, customize: Table.(UpdateBuilder<*>) -> Unit = {}): InsertStatement<Number>\n\n// Find all entities and map to domain model\ninline fun <reified R : Any> Table.findAll(e: SqlExpressionBuilder.() -> Op<Boolean> = { Op.TRUE })\n"})}),"\n",(0,t.jsx)(e.h3,{id:"schema-management",children:"Schema Management"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"ExposedDatabase"})," class provides utilities for schema management:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"class ExposedDatabase(\n    private val connection: Database,\n    private vararg val tables: Table\n) {\n    fun createSchema() = transaction(connection) {\n        SchemaUtils.create(*tables)\n    }\n    \n    fun dropSchema() = transaction(connection) {\n        SchemaUtils.drop(*tables)\n    }\n    \n    fun addMissingColumns() = transaction(connection) {\n        SchemaUtils.addMissingColumnsStatements(*tables)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"database-specific-implementations",children:"Database-Specific Implementations"}),"\n",(0,t.jsx)(e.h3,{id:"h2-integration",children:"H2 Integration"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"exposed-h2"})," module provides a simplified API for H2 database connections:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'fun h2ConnectionConfig(\n    name: String = "test",\n    inMemory: Boolean = true,\n    directory: String? = null,\n    url: String = buildH2Url(name, inMemory, directory),\n    user: String = "sa",\n    password: String = ""\n): DatabaseConnectionConfig {\n    return DatabaseConnectionConfig(\n        url = url,\n        driver = "org.h2.Driver",\n        user = user,\n        password = password\n    )\n}\n\nprivate fun buildH2Url(name: String, inMemory: Boolean, directory: String?): String {\n    return if (inMemory) {\n        "jdbc:h2:mem:$name;DB_CLOSE_DELAY=-1;"\n    } else {\n        "jdbc:h2:${directory ?: "~"}/$name;DB_CLOSE_DELAY=-1;"\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"This provides sensible defaults for H2 databases, particularly useful for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Unit and integration testing with in-memory databases"}),"\n",(0,t.jsx)(e.li,{children:"Development environments with quick setup"}),"\n",(0,t.jsx)(e.li,{children:"Simple applications that don't need a separate database server"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"postgresql-integration",children:"PostgreSQL Integration"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"exposed-postgres"})," module supports PostgreSQL connections with advanced options:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'fun postgresConnectionConfig(\n    host: String = "localhost",\n    port: Int = 5432,\n    database: String,\n    user: String,\n    password: String,\n    properties: Map<String, String> = emptyMap(),\n    url: String = buildPostgresUrl(host, port, database, properties),\n    dataSource: DataSource? = null\n): DatabaseConnectionConfig {\n    return if (dataSource != null) {\n        DatabaseConnectionConfig(\n            url = url,\n            driver = "org.postgresql.Driver",\n            user = user,\n            password = password,\n            setupConnection = { db ->\n                (db as DatabaseImpl).config.apply {\n                    this.dataSource = dataSource\n                }\n            }\n        )\n    } else {\n        DatabaseConnectionConfig(\n            url = url,\n            driver = "org.postgresql.Driver",\n            user = user,\n            password = password\n        )\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"This supports:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Standard PostgreSQL connections"}),"\n",(0,t.jsx)(e.li,{children:"Connection pooling via HikariCP or other DataSource implementations"}),"\n",(0,t.jsx)(e.li,{children:"Advanced connection properties for tuning performance and security"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"technical-deep-dive",children:"Technical Deep Dive"}),"\n",(0,t.jsx)(e.h3,{id:"automatic-mapping-implementation",children:"Automatic Mapping Implementation"}),"\n",(0,t.jsx)(e.p,{children:"The core mapping functionality uses Kotlin reflection to inspect classes and convert between them:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'fun <R : Any> Any.to(target: KClass<R>): R {\n    if (this::class == target) return this as R\n    if (target.isValue) return mapValueClass(target, this) as R\n\n    val members = this::class.members.toList().map { it.name to it }.toMap()\n    val constructor = target.constructors.first()\n    \n    try {\n        val args = constructor.parameters.map {\n            val sourceValue = members[it.name]?.call(this)?.unwrap()\n            val targetClass = it.type.classifier as KClass<*>\n\n            it to if (sourceValue == null) {\n                null\n            } else {\n                // Handle different mapping scenarios...\n            }\n        }\n        \n        val instance = constructor.callBy(\n            args.toMap().filterNot { (!it.key.type.isMarkedNullable && it.value == null) }\n        )\n        return instance\n    } catch (e: Exception) {\n        println("Error mapping $this to ${target}")\n        throw e\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"This complex system handles various mapping scenarios:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Direct mapping of identical types"}),"\n",(0,t.jsx)(e.li,{children:"Value class mapping"}),"\n",(0,t.jsx)(e.li,{children:"Collection mapping (List/Set)"}),"\n",(0,t.jsx)(e.li,{children:"Custom mapping via the AutoMapper"}),"\n",(0,t.jsx)(e.li,{children:"Recursive mapping of nested objects"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"transaction-implementation",children:"Transaction Implementation"}),"\n",(0,t.jsx)(e.p,{children:"The transaction integration leverages Exposed's transaction API:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"inline fun <T> transaction(\n    statement: Transaction.() -> T\n): T {\n    return org.jetbrains.exposed.sql.transactions.transaction {\n        try {\n            statement()\n        } catch (e: Exception) {\n            rollback()\n            throw e\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"When combined with Snitch's routing:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"class TransactionalRoutes : Routes() {\n    override fun <T : Any> addEndpoint(endpoint: Endpoint<T>) {\n        val wrappedHandler = { request: Request<T> ->\n            transaction {\n                endpoint.handler(request)\n            }\n        }\n        super.addEndpoint(endpoint.copy(handler = wrappedHandler))\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"This ensures that:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Every request handler executes within a transaction"}),"\n",(0,t.jsx)(e.li,{children:"Exceptions trigger transaction rollback"}),"\n",(0,t.jsx)(e.li,{children:"Successful execution commits the transaction"}),"\n",(0,t.jsx)(e.li,{children:"The transaction spans the entire request handling process"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"value-class-support",children:"Value Class Support"}),"\n",(0,t.jsx)(e.p,{children:"Value classes receive special handling to maintain type safety:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'private fun mapValueClass(targetClass: KClass<*>, sourceValue: Any) = try {\n    val first = targetClass.constructors.first()\n    val kClass = first.parameters.first().type.classifier as KClass<*>\n    if (kClass != sourceValue::class) {\n        (\n            mapping[sourceValue::class]?.from?.invoke(sourceValue)\n                ?: mapping[kClass]?.to?.invoke(sourceValue)\n            )\n            ?.wrap(targetClass)\n    } else {\n        first.call(sourceValue)\n    }\n} catch (e: Exception) {\n    println("Error instantiating value $sourceValue to $targetClass")\n    throw e\n}\n\nfun Any.unwrap() = if (this::class.isValue) this::class.members.first().call(this) else this\nfun Any.wrap(target: KClass<*>) = if (target.isValue) target.constructors.first().call(this) else this\n'})}),"\n",(0,t.jsx)(e.p,{children:"This allows transparent conversion between primitive types and their value class wrappers."}),"\n",(0,t.jsx)(e.h3,{id:"custom-type-mapping-system",children:"Custom Type Mapping System"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"AutoMapper"})," provides a registry for custom type conversions:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"object AutoMapper {\n    val mapping = mutableMapOf<KClass<*>, Mapper<Any, Any>>()\n\n    inline fun <reified FROM, TO> customMapping(noinline from: (FROM) -> TO, noinline to: (TO) -> FROM) {\n        mapping[FROM::class] = Mapper(from, to) as Mapper<Any, Any>\n    }\n}\n\ndata class Mapper<FROM, TO>(val from: (FROM) -> TO, val to: (TO) -> FROM)\n"})}),"\n",(0,t.jsx)(e.p,{children:"This registry is consulted during the mapping process to apply custom conversions when needed."}),"\n",(0,t.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,t.jsx)(e.p,{children:"For production use, connection pooling is essential:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'import com.zaxxer.hikari.HikariConfig\nimport com.zaxxer.hikari.HikariDataSource\n\nfun createConnectionPool(\n    url: String,\n    user: String,\n    password: String,\n    maxPoolSize: Int = 10\n): DataSource {\n    val config = HikariConfig().apply {\n        jdbcUrl = url\n        username = user\n        this.password = password\n        maximumPoolSize = maxPoolSize\n        isAutoCommit = false\n        transactionIsolation = "TRANSACTION_REPEATABLE_READ"\n    }\n    return HikariDataSource(config)\n}\n\n// Use with PostgreSQL\nval dataSource = createConnectionPool(\n    url = "jdbc:postgresql://localhost:5432/myapp",\n    user = "dbuser",\n    password = "password"\n)\n\nval config = postgresConnectionConfig(\n    url = "jdbc:postgresql://localhost:5432/myapp",\n    user = "dbuser",\n    password = "password",\n    dataSource = dataSource\n)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(e.p,{children:"For bulk operations, batch processing is significantly more efficient:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// Individual inserts - slow for large datasets\nuserList.forEach { user ->\n    Users.insert(user)\n}\n\n// Batch insert - much faster\nUsers.batchInsert(userList) { user ->\n    this[Users.name] = user.name\n    this[Users.email] = user.email\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"query-optimization",children:"Query Optimization"}),"\n",(0,t.jsx)(e.p,{children:"Strategic querying can dramatically improve performance:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// Inefficient: Loads all users then filters in memory\nval users = transaction {\n    Users.findAll<User>()\n}.filter { it.age > 30 }\n\n// Efficient: Filters at the database level\nval users = transaction {\n    Users.findAll<User> { Users.age greater 30 }\n}\n\n// Inefficient: N+1 query problem\nval usersWithPosts = transaction {\n    Users.findAll<User>().map { user ->\n        val posts = Posts.findAll<Post> { Posts.userId eq user.id } // One query per user!\n        UserWithPosts(user, posts)\n    }\n}\n\n// More efficient: Join in a single query\nval usersWithPosts = transaction {\n    (Users innerJoin Posts)\n        .select { Posts.userId eq Users.id }\n        .groupBy { it[Users.id] }\n        .map { (userId, rows) ->\n            val user = Users.findOne<User> { Users.id eq userId }\n            val posts = rows.map { Posts.to<Post>(it) }\n            UserWithPosts(user, posts)\n        }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-testing",children:"Integration with Testing"}),"\n",(0,t.jsx)(e.p,{children:"The Exposed modules are designed to integrate seamlessly with testing:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'class UserRepositoryTest {\n    private lateinit var repository: UserRepository\n    \n    @BeforeEach\n    fun setup() {\n        // Create a unique in-memory database for test isolation\n        val config = h2ConnectionConfig(name = "test_${UUID.randomUUID()}")\n        ExposedModule.connection(config)\n        \n        transaction {\n            SchemaUtils.create(Users)\n        }\n        \n        repository = UserRepository()\n    }\n    \n    @Test\n    fun `create user stores data correctly`() {\n        // Arrange\n        val user = User("Test User", "test@example.com")\n        \n        // Act\n        val id = repository.createUser(user)\n        \n        // Assert\n        val retrievedUser = repository.getUserById(id)\n        assertEquals("Test User", retrievedUser?.name)\n        assertEquals("test@example.com", retrievedUser?.email)\n    }\n    \n    @AfterEach\n    fun tearDown() {\n        transaction {\n            SchemaUtils.drop(Users)\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"This approach provides:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test isolation with unique databases"}),"\n",(0,t.jsx)(e.li,{children:"Fast test execution with in-memory storage"}),"\n",(0,t.jsx)(e.li,{children:"Realistic database behavior for integration tests"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,t.jsx)(e.h3,{id:"custom-column-types",children:"Custom Column Types"}),"\n",(0,t.jsx)(e.p,{children:"Exposed supports custom column types for complex data:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'// Define a column type for storing JSONs\nclass JsonColumnType<T : Any>(\n    private val klass: KClass<T>,\n    private val objectMapper: ObjectMapper\n) : ColumnType() {\n    override fun sqlType(): String = "TEXT"\n    \n    override fun valueFromDB(value: Any): T = when(value) {\n        is String -> objectMapper.readValue(value, klass.java)\n        else -> error("Unexpected value: $value of ${value::class.qualifiedName}")\n    }\n    \n    override fun notNullValueToDB(value: Any): String = objectMapper.writeValueAsString(value)\n}\n\n// Use it in a table\nobject Users : Table("users") {\n    val id = integer("id").autoIncrement()\n    val name = varchar("name", 255)\n    val preferences = registerColumn<UserPreferences>("preferences", JsonColumnType(UserPreferences::class, objectMapper))\n    \n    override val primaryKey = PrimaryKey(id)\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"database-migration-strategies",children:"Database Migration Strategies"}),"\n",(0,t.jsx)(e.p,{children:"For evolving schemas, you can use the Exposed utilities:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'class DatabaseMigration(\n    private val connection: Database,\n    private vararg val tables: Table\n) {\n    fun migrateSchema() = transaction(connection) {\n        // Get statements to add missing columns\n        val statements = SchemaUtils.addMissingColumnsStatements(*tables)\n        \n        // Execute each statement\n        statements.forEach { statement ->\n            exec(statement)\n        }\n        \n        // Check for any table structure changes\n        for (table in tables) {\n            val existingIndices = exec("SHOW INDEX FROM ${table.tableName}") { rs ->\n                val indices = mutableListOf<String>()\n                while (rs.next()) {\n                    indices.add(rs.getString("Column_name"))\n                }\n                indices\n            } ?: emptyList()\n            \n            // Create any missing indices\n            table.indices.forEach { index ->\n                val columns = index.columns.joinToString(", ") { it.name }\n                if (!existingIndices.contains(columns)) {\n                    val indexType = if (index.unique) "UNIQUE" else ""\n                    exec("CREATE $indexType INDEX idx_${table.tableName}_${index.name} ON ${table.tableName}($columns)")\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"repository-pattern-implementation",children:"Repository Pattern Implementation"}),"\n",(0,t.jsx)(e.p,{children:"A clean repository implementation with Snitch Exposed:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'interface UserRepository {\n    fun findById(id: Int): User?\n    fun findAll(): List<User>\n    fun create(user: User): Int\n    fun update(user: User): Boolean\n    fun delete(id: Int): Boolean\n}\n\nclass ExposedUserRepository : UserRepository {\n    override fun findById(id: Int): User? = transaction {\n        Users.findOneOrNull<UserEntity> { Users.id eq id }\n            ?.let { mapToDomain(it) }\n    }\n    \n    override fun findAll(): List<User> = transaction {\n        Users.findAll<UserEntity>()\n            .map { mapToDomain(it) }\n    }\n    \n    override fun create(user: User): Int = transaction {\n        val entity = mapToEntity(user)\n        Users.insert(entity)[Users.id]\n    }\n    \n    override fun update(user: User): Boolean = transaction {\n        val entity = mapToEntity(user)\n        val updated = Users.updateWhere(entity) { Users.id eq entity.id }\n        updated > 0\n    }\n    \n    override fun delete(id: Int): Boolean = transaction {\n        val deleted = Users.deleteWhere { Users.id eq id }\n        deleted > 0\n    }\n    \n    private fun mapToDomain(entity: UserEntity): User = User(\n        id = entity.id,\n        name = entity.name,\n        email = entity.email,\n        isActive = entity.status == "ACTIVE"\n    )\n    \n    private fun mapToEntity(domain: User): UserEntity = UserEntity(\n        id = domain.id,\n        name = domain.name,\n        email = domain.email,\n        status = if (domain.isActive) "ACTIVE" else "INACTIVE"\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Snitch's Exposed integration provides a powerful, flexible foundation for database operations in your applications. The combination of type safety, automatic mapping, and seamless transaction management creates a developer-friendly experience while maintaining the performance and flexibility needed for production applications."}),"\n",(0,t.jsx)(e.p,{children:"By understanding the internal workings of this integration, you can leverage its full capabilities and customize it to fit your specific requirements."}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/JetBrains/Exposed",children:"Exposed GitHub Repository"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/JetBrains/Exposed/wiki",children:"Exposed Wiki"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://h2database.com/html/main.html",children:"H2 Database Documentation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://www.postgresql.org/docs/",children:"PostgreSQL Documentation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/brettwooldridge/HikariCP",children:"HikariCP Connection Pool"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>r,x:()=>o});var i=s(6540);const t={},a=i.createContext(t);function r(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);