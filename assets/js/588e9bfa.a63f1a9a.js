"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[6987],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const a={},t=r.createContext(a);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(t.Provider,{value:n},e.children)}},9816:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"in depth/Working-With-Parameters","title":"Working with Parameters in Snitch","description":"This in-depth guide explores Snitch\'s parameter handling system, covering advanced topics, implementation details, and best practices for building robust, type-safe APIs.","source":"@site/docs/in depth/Working-With-Parameters.md","sourceDirName":"in depth","slug":"/in depth/Working-With-Parameters","permalink":"/docs/in depth/Working-With-Parameters","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/in depth/Working-With-Parameters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Validators","permalink":"/docs/in depth/Mastering-Snitch-Validators"},"next":{"title":"Snitch Artifacts","permalink":"/docs/resources/Artifacts"}}');var a=i(4848),t=i(8453);const s={},l="Working with Parameters in Snitch",d={},o=[{value:"Parameter System Architecture",id:"parameter-system-architecture",level:2},{value:"Parameter Delegates",id:"parameter-delegates",level:2},{value:"Parameter Definition Internals",id:"parameter-definition-internals",level:2},{value:"Parameter Registration and Resolution",id:"parameter-registration-and-resolution",level:2},{value:"Advanced Parameter Usage",id:"advanced-parameter-usage",level:2},{value:"Custom Validator Implementation",id:"custom-validator-implementation",level:3},{value:"Parameter Conditions",id:"parameter-conditions",level:3},{value:"Parameter Visibility",id:"parameter-visibility",level:3},{value:"Parameter Grouping and Organization",id:"parameter-grouping-and-organization",level:3},{value:"Parameter Validation Flow",id:"parameter-validation-flow",level:2},{value:"Body Parameter Handling",id:"body-parameter-handling",level:2},{value:"Combining Parameters with Path Building",id:"combining-parameters-with-path-building",level:2},{value:"Type-Safe Parameter Access",id:"type-safe-parameter-access",level:2},{value:"Error Handling and Customization",id:"error-handling-and-customization",level:2},{value:"Working with Collections of Parameters",id:"working-with-collections-of-parameters",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Integration with API Documentation",id:"integration-with-api-documentation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Parameter Naming",id:"parameter-naming",level:3},{value:"Parameter Organization",id:"parameter-organization",level:3},{value:"Validation Strategy",id:"validation-strategy",level:3},{value:"Parameter Documentation",id:"parameter-documentation",level:3},{value:"Parameter Security",id:"parameter-security",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"working-with-parameters-in-snitch",children:"Working with Parameters in Snitch"})}),"\n",(0,a.jsx)(n.p,{children:"This in-depth guide explores Snitch's parameter handling system, covering advanced topics, implementation details, and best practices for building robust, type-safe APIs."}),"\n",(0,a.jsx)(n.h2,{id:"parameter-system-architecture",children:"Parameter System Architecture"}),"\n",(0,a.jsx)(n.p,{children:"Snitch's parameter system is built on Kotlin's property delegation pattern, providing both compile-time and runtime safety. The system consists of several key components:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Definitions"}),": Type-safe property delegates that define parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validators"}),": Functions that validate and transform parameter values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Registry"}),": Keeps track of all parameters used in routes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Extraction"}),": Pulls parameter values from HTTP requests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Access"}),": Type-safe access to parameter values in handlers"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"parameter-delegates",children:"Parameter Delegates"}),"\n",(0,a.jsx)(n.p,{children:"Each parameter type is implemented as a property delegate:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"path()"}),": Path parameters embedded in URL segments"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"query()"}),": Query parameters from the URL query string"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"header()"}),": Parameters from HTTP headers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"body<T>()"}),": Type-safe access to the request body"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Each delegate creates a parameter definition that is registered with the framework when routes are defined."}),"\n",(0,a.jsx)(n.h2,{id:"parameter-definition-internals",children:"Parameter Definition Internals"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at how parameters are defined under the hood:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// PathParam implementation (simplified)\nclass PathParam<T : Any, C : Any>(\n    override val name: String,\n    override val validator: ValueValidator<T, C>,\n    override val description: String,\n    override val emptyAsMissing: Boolean,\n    override val invalidAsMissing: Boolean,\n    override val visibility: ParameterVisibility,\n    override val condition: ValueCondition<C>?\n) : Parameter<T, C>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Parameter<T, C>"})," interface defines common properties and behaviors for all parameter types:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"name"}),": The parameter name used in documentation and error messages"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"validator"}),": Validates and transforms the parameter string value to type T"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"description"}),": Human-readable description for documentation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"emptyAsMissing"}),": Controls whether empty values are treated as missing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"invalidAsMissing"}),": Controls whether invalid values are treated as missing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"visibility"}),": Controls whether parameter appears in documentation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"condition"}),": Additional validation logic for the parameter"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"parameter-registration-and-resolution",children:"Parameter Registration and Resolution"}),"\n",(0,a.jsx)(n.p,{children:"When a route is defined, its parameters are registered with the framework:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val userId by path(ofInt)\n\n// The route definition registers the userId parameter\nGET("users" / userId) isHandledBy { ... }\n'})}),"\n",(0,a.jsx)(n.p,{children:"During request handling:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Parameters are extracted from the request"}),"\n",(0,a.jsx)(n.li,{children:"Each parameter is validated using its validator"}),"\n",(0,a.jsx)(n.li,{children:"Additional conditions are checked"}),"\n",(0,a.jsx)(n.li,{children:"If validation fails, an appropriate error response is returned"}),"\n",(0,a.jsx)(n.li,{children:"If successful, the handler is invoked with access to the validated parameters"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-parameter-usage",children:"Advanced Parameter Usage"}),"\n",(0,a.jsx)(n.h3,{id:"custom-validator-implementation",children:"Custom Validator Implementation"}),"\n",(0,a.jsxs)(n.p,{children:["Creating a custom validator involves implementing the ",(0,a.jsx)(n.code,{children:"ValueValidator<T, C>"})," interface:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Custom UUID validator implementation\nval ofUUID = object : ValueValidator<String, UUID> {\n    override val invalidValueErrorMessage = "Invalid UUID format"\n    \n    override fun validate(value: String): UUID {\n        try {\n            return UUID.fromString(value)\n        } catch (e: IllegalArgumentException) {\n            throw InvalidParameterException(invalidValueErrorMessage)\n        }\n    }\n    \n    override fun serialize(value: UUID): String {\n        return value.toString()\n    }\n}\n\n// Usage\nval userId by path(ofUUID, description = "User ID in UUID format")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For simpler validators, you can use the ",(0,a.jsx)(n.code,{children:"validator"})," helper function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val ofUUID = validator { input ->\n    try {\n        UUID.fromString(input)\n        input\n    } catch (e: IllegalArgumentException) {\n        throw InvalidParameterException("Invalid UUID format")\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"parameter-conditions",children:"Parameter Conditions"}),"\n",(0,a.jsx)(n.p,{children:"Conditions provide additional validation for parameters beyond basic type conversion:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Condition implementation\nval positiveNumber = condition<Int> { value ->\n    if (value <= 0) {\n        ConditionResult.Failure("Value must be positive")\n    } else {\n        ConditionResult.Success\n    }\n}\n\n// Usage with a parameter\nval quantity by query(ofInt, condition = positiveNumber)\n'})}),"\n",(0,a.jsx)(n.p,{children:"Conditions are evaluated after the parameter has been successfully validated and converted to its target type."}),"\n",(0,a.jsx)(n.h3,{id:"parameter-visibility",children:"Parameter Visibility"}),"\n",(0,a.jsx)(n.p,{children:"Control whether parameters appear in documentation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Public parameter visible in documentation\nval apiKey by header(visibility = ParameterVisibility.PUBLIC)\n\n// Internal parameter hidden from documentation\nval internalId by header(visibility = ParameterVisibility.INTERNAL)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"parameter-grouping-and-organization",children:"Parameter Grouping and Organization"}),"\n",(0,a.jsx)(n.p,{children:"For better code organization, group related parameters in objects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'object UserParameters {\n    val id by path(ofInt, description = "User ID")\n    val email by query(ofEmail, description = "User email")\n    val status by optionalQuery(\n        validator { input -> UserStatus.valueOf(input.uppercase()) },\n        default = UserStatus.ACTIVE,\n        description = "User status"\n    )\n}\n\nobject PaginationParameters {\n    val page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")\n    val size by optionalQuery(ofNonNegativeInt, default = 20, description = "Page size")\n    val sort by optionalQuery(description = "Sort field")\n    val direction by optionalQuery(\n        validator { input -> SortDirection.valueOf(input.uppercase()) },\n        default = SortDirection.ASC,\n        description = "Sort direction"\n    )\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This approach makes route definitions more readable and groups related parameters logically:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'GET("users") withQuery PaginationParameters.page withQuery PaginationParameters.size isHandledBy {\n    val page = request[PaginationParameters.page]\n    val size = request[PaginationParameters.size]\n    // ...\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"parameter-validation-flow",children:"Parameter Validation Flow"}),"\n",(0,a.jsx)(n.p,{children:"When a request is processed, parameters go through the following validation flow:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Extraction"}),": Parameters are extracted from the request"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Path parameters from URL path segments"}),"\n",(0,a.jsx)(n.li,{children:"Query parameters from the query string"}),"\n",(0,a.jsx)(n.li,{children:"Header parameters from request headers"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Presence Check"}),": For required parameters, verify the parameter is present"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Empty Value Handling"}),": Apply ",(0,a.jsx)(n.code,{children:"emptyAsMissing"})," logic if configured"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Type Validation and Conversion"}),": Apply the parameter's validator"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Validates the string value"}),"\n",(0,a.jsx)(n.li,{children:"Converts to the target type"}),"\n",(0,a.jsxs)(n.li,{children:["May throw ",(0,a.jsx)(n.code,{children:"InvalidParameterException"})," if validation fails"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Invalid Value Handling"}),": Apply ",(0,a.jsx)(n.code,{children:"invalidAsMissing"})," logic if configured and validation failed"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Condition Check"}),": Apply additional conditions if defined"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Evaluated on the converted value"}),"\n",(0,a.jsx)(n.li,{children:"May return failure with a custom error message"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Default Value Application"}),": For optional parameters with defaults, apply the default value if the parameter is missing"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Availability"}),": Make validated parameters available to the handler"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If any step fails, the framework generates an appropriate error response, typically a 400 Bad Request with details about the invalid parameter."}),"\n",(0,a.jsx)(n.h2,{id:"body-parameter-handling",children:"Body Parameter Handling"}),"\n",(0,a.jsx)(n.p,{children:"Body parameters are handled differently from other parameter types:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The request body is read and parsed according to the Content-Type"}),"\n",(0,a.jsx)(n.li,{children:"The parsed data is converted to the target type"}),"\n",(0,a.jsxs)(n.li,{children:["The typed body is made available in handlers via the ",(0,a.jsx)(n.code,{children:"body"})," property"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Body parameters are defined in route declarations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'POST("users") with body<CreateUserRequest>() isHandledBy {\n    // Access body properties directly\n    val name = body.name\n    val email = body.email\n    // ...\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For more control over body parsing and validation, use the ",(0,a.jsx)(n.code,{children:"parsing"})," handler:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val createUser by parsing<CreateUserRequest>() handling {\n    // Additional validation\n    if (body.name.isBlank()) {\n        return@handling "Name cannot be blank".badRequest()\n    }\n    \n    // Process the request\n    userService.createUser(body.name, body.email)\n    "User created".created\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"combining-parameters-with-path-building",children:"Combining Parameters with Path Building"}),"\n",(0,a.jsx)(n.p,{children:"Snitch's path building syntax integrates seamlessly with parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Basic path with parameter\nGET("users" / userId) isHandledBy { ... }\n\n// Nested paths with multiple parameters\nval api = routes {\n    "users" / {\n        GET() isHandledBy { ... }  // GET /users\n        \n        userId / {\n            GET() isHandledBy { ... }  // GET /users/{userId}\n            \n            "posts" / {\n                GET() isHandledBy { ... }  // GET /users/{userId}/posts\n                \n                postId / {\n                    GET() isHandledBy { ... }  // GET /users/{userId}/posts/{postId}\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This composition approach makes it easy to build hierarchical APIs with clear parameter scoping."}),"\n",(0,a.jsx)(n.h2,{id:"type-safe-parameter-access",children:"Type-Safe Parameter Access"}),"\n",(0,a.jsx)(n.p,{children:"Snitch provides type-safe access to parameters in handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val userId by path(ofInt)\nval page by optionalQuery(ofInt, default = 1)\n\nval handler by handling {\n    val id: Int = request[userId]  // Type-safe access\n    val pageNum: Int = request[page]  // Default applied if missing\n    \n    // ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The type information is preserved through the property delegate system, so you get compile-time type checking for parameter access."}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-and-customization",children:"Error Handling and Customization"}),"\n",(0,a.jsx)(n.p,{children:"You can customize how parameter validation errors are handled:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Global error handler for parameter validation errors\napp.handleException(InvalidParameterException::class) { exception, _ ->\n    ErrorResponse(\n        code = 400,\n        message = "Invalid parameter: ${exception.message}"\n    ).badRequest()\n}\n\n// Custom error handler for specific routes\nroutes {\n    handleException(InvalidParameterException::class) { exception, _ ->\n        ErrorResponse(\n            code = 400,\n            message = "Validation failed: ${exception.message}",\n            details = mapOf("parameter" to exception.parameterName)\n        ).badRequest()\n    }\n    \n    // Routes with custom error handling...\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"working-with-collections-of-parameters",children:"Working with Collections of Parameters"}),"\n",(0,a.jsx)(n.p,{children:"Handling collections of parameter values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Define a multi-value query parameter\nval tags by query(description = "Filter by tags", multiValued = true)\n\n// Access as a list in the handler\nval handler by handling {\n    val tagList: List<String> = request[tags]\n    // ...\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"For more complex parsing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Define a collection parameter with custom parsing\nval sortFields by query(\n    validator { input ->\n        input.split(",").map { field ->\n            val parts = field.split(":")\n            val name = parts[0]\n            val direction = if (parts.size > 1) parts[1].uppercase() else "ASC"\n            SortField(name, SortDirection.valueOf(direction))\n        }\n    },\n    description = "Sorting fields in format field:direction,field:direction"\n)\n\n// Access in handler\nval handler by handling {\n    val sorting: List<SortField> = request[sortFields]\n    // ...\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The parameter handling system is designed to be efficient:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Property Delegates"}),": Parameters are defined once at initialization time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lazy Validation"}),": Parameters are only validated when accessed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Caching"}),": Validation results are cached within a request"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Early Validation"}),": Basic validation happens before handlers are invoked, preventing unnecessary work"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For optimal performance:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use appropriate validators for your parameter types"}),"\n",(0,a.jsx)(n.li,{children:"Consider organizing parameters by usage patterns"}),"\n",(0,a.jsx)(n.li,{children:"Leverage built-in validators when possible"}),"\n",(0,a.jsx)(n.li,{children:"Use conditional logic in handlers for complex validation scenarios"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-api-documentation",children:"Integration with API Documentation"}),"\n",(0,a.jsx)(n.p,{children:"Parameters are automatically included in API documentation:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Path parameters are shown in URL templates"}),"\n",(0,a.jsx)(n.li,{children:"Query parameters are listed with types and descriptions"}),"\n",(0,a.jsx)(n.li,{children:"Header parameters are included in expected headers"}),"\n",(0,a.jsx)(n.li,{children:"Body parameters are documented with schemas when possible"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"To improve documentation:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Add clear descriptions to all parameters"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate visibility settings"}),"\n",(0,a.jsx)(n.li,{children:"Organize parameters logically"}),"\n",(0,a.jsx)(n.li,{children:"Consider using custom validators with descriptive error messages"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"parameter-naming",children:"Parameter Naming"}),"\n",(0,a.jsx)(n.p,{children:"Follow consistent naming conventions:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use camelCase for parameter names"}),"\n",(0,a.jsx)(n.li,{children:"Be descriptive but concise"}),"\n",(0,a.jsxs)(n.li,{children:["Use singular nouns for single values (e.g., ",(0,a.jsx)(n.code,{children:"userId"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Use plural nouns for collections (e.g., ",(0,a.jsx)(n.code,{children:"tags"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Prefer specific names over generic ones (e.g., ",(0,a.jsx)(n.code,{children:"email"})," instead of ",(0,a.jsx)(n.code,{children:"value"}),")"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"parameter-organization",children:"Parameter Organization"}),"\n",(0,a.jsx)(n.p,{children:"Organize parameters for maintainability:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Group related parameters in objects"}),"\n",(0,a.jsx)(n.li,{children:"Use common objects for shared parameters (e.g., pagination)"}),"\n",(0,a.jsx)(n.li,{children:"Keep parameter definitions close to their usage"}),"\n",(0,a.jsx)(n.li,{children:"Consider organizing parameters by domain concept"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"validation-strategy",children:"Validation Strategy"}),"\n",(0,a.jsx)(n.p,{children:"Create a robust validation strategy:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Validate parameters at the appropriate level"}),"\n",(0,a.jsx)(n.li,{children:"Use parameter validators for basic type and format validation"}),"\n",(0,a.jsx)(n.li,{children:"Use conditions for business rule validation"}),"\n",(0,a.jsx)(n.li,{children:"Use handler logic for complex or cross-parameter validation"}),"\n",(0,a.jsx)(n.li,{children:"Consider using the Jakarta Bean Validation API for complex objects"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"parameter-documentation",children:"Parameter Documentation"}),"\n",(0,a.jsx)(n.p,{children:"Document parameters thoroughly:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Add clear descriptions to all parameters"}),"\n",(0,a.jsx)(n.li,{children:'Indicate parameter constraints (e.g., "must be positive")'}),"\n",(0,a.jsx)(n.li,{children:"Document default values for optional parameters"}),"\n",(0,a.jsx)(n.li,{children:"Use examples for complex parameters"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"parameter-security",children:"Parameter Security"}),"\n",(0,a.jsx)(n.p,{children:"Consider security implications:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Validate all user input"}),"\n",(0,a.jsx)(n.li,{children:"Sanitize path and query parameters"}),"\n",(0,a.jsx)(n.li,{children:"Be cautious with header parameters that may contain sensitive data"}),"\n",(0,a.jsxs)(n.li,{children:["Consider using ",(0,a.jsx)(n.code,{children:"emptyAsMissing"})," for parameters that should never be empty"]}),"\n",(0,a.jsx)(n.li,{children:"Use conditions to implement additional security checks"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Snitch's parameter handling system provides a powerful, type-safe approach to working with request parameters. By leveraging Kotlin's property delegation feature, it offers a declarative syntax for parameter definition with strong type safety and robust validation."}),"\n",(0,a.jsx)(n.p,{children:"Understanding the internals of the parameter system allows you to build more maintainable, secure, and well-documented APIs with Snitch, while taking advantage of the framework's type safety and validation features."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);