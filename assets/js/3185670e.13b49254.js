"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[2758],{5029:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var i=n(6266),a=n(4848),o=n(8453);const r={slug:"typesafe-validation-with-snitch",title:"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety",authors:["snitch-team"],tags:["snitch","validation","type-safety","kotlin"]},s="Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety",l={authorsImageUrls:[void 0]},d=[{value:"The Problem with Traditional Validation",id:"the-problem-with-traditional-validation",level:2},{value:"Snitch&#39;s Type-Safe Validation Approach",id:"snitchs-type-safe-validation-approach",level:2},{value:"Extending to Complex Validation",id:"extending-to-complex-validation",level:2},{value:"Automatic Error Responses",id:"automatic-error-responses",level:2},{value:"From Strings to Domain Types",id:"from-strings-to-domain-types",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"One of the most common sources of bugs in web applications is improper handling of user input. Traditional frameworks often leave validation as an afterthought, resulting in runtime errors that could have been caught earlier. Snitch takes a different approach, making validation a first-class concern with compile-time safety."}),"\n",(0,a.jsx)(t.h2,{id:"the-problem-with-traditional-validation",children:"The Problem with Traditional Validation"}),"\n",(0,a.jsx)(t.p,{children:"Most web frameworks handle validation in ways that delay error detection:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Runtime validation"})," that only fails when code executes"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"String-based configurations"})," that aren't checked by the compiler"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Separate validation layers"})," disconnected from handler code"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Type erasure"})," that loses information about what's being validated"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"These approaches lead to a familiar pattern: write code, run application, discover validation errors, fix them, repeat. This cycle is not only inefficient but can let bugs slip through to production."}),"\n",(0,a.jsx)(t.h2,{id:"snitchs-type-safe-validation-approach",children:"Snitch's Type-Safe Validation Approach"}),"\n",(0,a.jsx)(t.p,{children:"Snitch addresses these issues through its validator system:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-kotlin",children:'// Define a domain type\ndata class UserId(val value: String)\n\n// Create a validator that both validates and transforms\nval ofUserId = validator<String, UserId>(\n    "valid user ID",\n    """^[a-zA-Z0-9]{8,12}$""".toRegex()\n) {\n    UserId(it)\n}\n\n// Use it with a parameter\nval userId by path(ofUserId)\n\n// Access the validated parameter\nval getUser by handling {\n    val id: UserId = request[userId] // Already validated and transformed\n    userRepository.findById(id)\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This approach offers several immediate benefits:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Combined validation and transformation"})," - The validator both checks input and converts it to your domain type"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Type safety throughout"})," - Your handler code works with properly typed values, not raw strings"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Early validation failures"})," - Invalid inputs are rejected before reaching your business logic"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Self-documenting code"})," - The validation requirements are clear from the validator definition"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"extending-to-complex-validation",children:"Extending to Complex Validation"}),"\n",(0,a.jsx)(t.p,{children:"Snitch's validator system scales elegantly to more complex scenarios:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-kotlin",children:'// Advanced email validator with domain restrictions\nval ofCorporateEmail = validator<String, Email>(\n    "corporate email address",\n    """^[a-zA-Z0-9._%+-]+@company\\.com$""".toRegex()\n) { \n    if (!it.endsWith("@company.com")) {\n        throw ValidationException("Must be a company.com email")\n    }\n    \n    Email(it)\n}\n\n// Combined validators for a request body\ndata class SignupRequest(val name: String, val email: String, val age: Int)\n\nval ofSignupRequest = bodyValidator<SignupRequest>("valid signup") { body ->\n    // Validate all fields\n    if (body.name.isEmpty()) throw ValidationException("Name cannot be empty")\n    if (!isValidEmail(body.email)) throw ValidationException("Invalid email format")\n    if (body.age < 18) throw ValidationException("Must be 18 or older")\n    \n    // Return validated object\n    body\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"automatic-error-responses",children:"Automatic Error Responses"}),"\n",(0,a.jsx)(t.p,{children:"When validation fails, Snitch automatically generates appropriate error responses:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  "error": "Validation failed",\n  "details": {\n    "email": "Invalid email format",\n    "age": "Must be 18 or older"\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"No need to write custom error handling code for each validator - the framework handles this for you, producing consistent, informative error messages for API consumers."}),"\n",(0,a.jsx)(t.h2,{id:"from-strings-to-domain-types",children:"From Strings to Domain Types"}),"\n",(0,a.jsx)(t.p,{children:"Perhaps the most powerful aspect of Snitch's validator system is how it bridges the gap between raw HTTP inputs (which are always strings) and your domain model:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-kotlin",children:'// Transform path parameter strings into domain types\nval orderId by path(ofOrderId)\nval status by query(ofOrderStatus)\n\nGET("orders" / orderId) withQuery status isHandledBy {\n    // Work with domain types directly\n    val id: OrderId = request[orderId]\n    val orderStatus: OrderStatus = request[status]\n    \n    orderRepository.findOrder(id, orderStatus)\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This type-safe approach eliminates an entire category of bugs and makes your code more readable and maintainable."}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"By making validation type-safe and integrated into the parameter definition process, Snitch transforms what is traditionally a source of runtime errors into compile-time safety. This shift not only catches issues earlier in the development process but also leads to more robust, self-documenting code that's easier to maintain and evolve over time."}),"\n",(0,a.jsx)(t.p,{children:'The next time you find yourself chasing down an "Invalid input" error in production, remember that with the right framework, that bug could have been caught before your code even compiled.'})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},6266:e=>{e.exports=JSON.parse('{"permalink":"/snitch/blog/typesafe-validation-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2023-10-17-typesafe-validation-with-snitch.md","source":"@site/blog/2023-10-17-typesafe-validation-with-snitch.md","title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","description":"One of the most common sources of bugs in web applications is improper handling of user input. Traditional frameworks often leave validation as an afterthought, resulting in runtime errors that could have been caught earlier. Snitch takes a different approach, making validation a first-class concern with compile-time safety.","date":"2023-10-17T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/snitch/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Validation","permalink":"/snitch/blog/tags/validation","description":"Content about data validation and input processing"},{"inline":false,"label":"Type Safety","permalink":"/snitch/blog/tags/type-safety","description":"Articles about type systems and compile-time safety"},{"inline":false,"label":"Kotlin","permalink":"/snitch/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"}],"readingTime":3.145,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/snitch/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"typesafe-validation-with-snitch","title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","authors":["snitch-team"],"tags":["snitch","validation","type-safety","kotlin"]},"unlisted":false,"prevItem":{"title":"Spring Boot vs Snitch: A Comprehensive Comparison for Modern API Development","permalink":"/snitch/blog/spring-boot-vs-snitch"},"nextItem":{"title":"Expressive Code at Scale: How Snitch Transforms API Development","permalink":"/snitch/blog/expressivity-and-scaling-with-snitch"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);