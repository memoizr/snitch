"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[5043],{1582:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"resources/Database-Integration","title":"Database Integration with Snitch Exposed","description":"Snitch offers first-class database integration through its Exposed modules, providing a seamless, type-safe experience for working with relational databases in your applications. This guide explores how Snitch\'s Exposed modules help you integrate databases into your applications with minimal boilerplate and maximum type safety.","source":"@site/docs/resources/Database-Integration.md","sourceDirName":"resources","slug":"/resources/Database-Integration","permalink":"/docs/resources/Database-Integration","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/resources/Database-Integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Snitch Artifacts","permalink":"/docs/resources/Artifacts"},"next":{"title":"Snitch Tutorials","permalink":"/docs/tutorials/"}}');var a=s(4848),t=s(8453);const r={},o="Database Integration with Snitch Exposed",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Available Modules",id:"available-modules",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"1. Type-Safe Database Access",id:"1-type-safe-database-access",level:3},{value:"2. Automatic Object Mapping",id:"2-automatic-object-mapping",level:3},{value:"3. Integrated Transaction Management",id:"3-integrated-transaction-management",level:3},{value:"4. Value Class Support",id:"4-value-class-support",level:3},{value:"5. Flexible Schema Management",id:"5-flexible-schema-management",level:3},{value:"Database-Specific Modules",id:"database-specific-modules",level:2},{value:"H2 Integration",id:"h2-integration",level:3},{value:"PostgreSQL Integration",id:"postgresql-integration",level:3},{value:"Advanced Usage Patterns",id:"advanced-usage-patterns",level:2},{value:"Custom Type Mapping",id:"custom-type-mapping",level:3},{value:"Transaction Strategies",id:"transaction-strategies",level:3},{value:"Working with Relationships",id:"working-with-relationships",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Integration with Snitch Features",id:"integration-with-snitch-features",level:2},{value:"Validation Integration",id:"validation-integration",level:3},{value:"Error Handling Integration",id:"error-handling-integration",level:3},{value:"Testing Integration",id:"testing-integration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Domain Model Separation",id:"1-domain-model-separation",level:3},{value:"2. Repository Pattern",id:"2-repository-pattern",level:3},{value:"3. Transaction Management",id:"3-transaction-management",level:3},{value:"4. Error Handling",id:"4-error-handling",level:3},{value:"5. Testing Strategy",id:"5-testing-strategy",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"database-integration-with-snitch-exposed",children:"Database Integration with Snitch Exposed"})}),"\n",(0,a.jsx)(n.p,{children:"Snitch offers first-class database integration through its Exposed modules, providing a seamless, type-safe experience for working with relational databases in your applications. This guide explores how Snitch's Exposed modules help you integrate databases into your applications with minimal boilerplate and maximum type safety."}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Working with databases in web applications is often fraught with challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type safety"})," is frequently lost at the database boundary"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Object-relational impedance mismatch"})," requires tedious mapping code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transaction management"})," adds complexity to request handling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Database schema evolution"})," creates maintenance challenges"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Snitch solves these problems through a powerful integration with the ",(0,a.jsx)(n.a,{href:"https://github.com/JetBrains/Exposed",children:"Exposed"})," SQL library for Kotlin. This integration provides type-safe database access with automatic object mapping and transaction management tailored specifically for Snitch applications."]}),"\n",(0,a.jsx)(n.h2,{id:"available-modules",children:"Available Modules"}),"\n",(0,a.jsx)(n.p,{children:"Snitch provides three modules for database integration:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"exposed"}),": Core module with base abstractions, mapping utilities, and transaction management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"exposed-h2"}),": Specialized module for H2 database connections, ideal for testing and development"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"exposed-postgres"}),": Specialized module for PostgreSQL database connections, suitable for production"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,a.jsx)(n.h3,{id:"1-type-safe-database-access",children:"1. Type-Safe Database Access"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed modules leverage Kotlin's type system to provide compile-time safety for database operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Type-safe table definition\nobject Users : Table("users") {\n    val id = integer("id").autoIncrement()\n    val name = varchar("name", 255)\n    val email = varchar("email", 255)\n    \n    override val primaryKey = PrimaryKey(id)\n}\n\n// Type-safe query\nval user = transaction {\n    Users.findOne<UserModel> { Users.email eq "user@example.com" }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The compiler ensures that:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Your queries reference existing columns"}),"\n",(0,a.jsx)(n.li,{children:"Your comparisons use the correct data types"}),"\n",(0,a.jsx)(n.li,{children:"Your result mappings align with your domain models"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-automatic-object-mapping",children:"2. Automatic Object Mapping"}),"\n",(0,a.jsx)(n.p,{children:"One of the most powerful features of Snitch Exposed is its automatic object mapping. This eliminates the tedious and error-prone code typically required to map between database tables and domain objects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Domain model\ndata class User(val name: String, val email: String)\ndata class UserWithId(val id: Int, val name: String, val email: String)\n\n// Automatic mapping from database to domain model\nval users = transaction {\n    Users.findAll<UserWithId>()\n}\n\n// Automatic mapping from domain model to database\nval user = User("John Doe", "john@example.com")\ntransaction {\n    Users.insert(user)\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Behind the scenes, Snitch:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Inspects the properties of your domain model using Kotlin reflection"}),"\n",(0,a.jsx)(n.li,{children:"Matches them with database column names"}),"\n",(0,a.jsx)(n.li,{children:"Performs appropriate type conversions"}),"\n",(0,a.jsx)(n.li,{children:"Handles value classes and nested objects"}),"\n",(0,a.jsx)(n.li,{children:"Supports custom mapping for complex cases"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This eliminates thousands of lines of boilerplate code in typical applications while maintaining type safety."}),"\n",(0,a.jsx)(n.h3,{id:"3-integrated-transaction-management",children:"3. Integrated Transaction Management"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed seamlessly integrates transaction management with the routing system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'withTransaction {\n    POST("users") with body<User>() isHandledBy {\n        val user = body\n        val id = Users.insert(user)[Users.id]\n        UserResponse(id, user.name, user.email).ok\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This provides several benefits:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic transaction boundaries"})," around route handlers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Consistent error handling"})," with automatic rollback on exceptions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clean code organization"})," without explicit transaction blocks"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-value-class-support",children:"4. Value Class Support"}),"\n",(0,a.jsx)(n.p,{children:"Modern Kotlin applications often use value classes for type safety. Snitch Exposed provides first-class support for value classes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Domain model with value classes\n@JvmInline\nvalue class UserId(val value: Int)\n\ndata class UserWithValueId(val id: UserId, val name: String, val email: String)\n\n// Automatic mapping works with value classes\nval user = transaction {\n    Users.findOne<UserWithValueId> { Users.id eq 1 }\n}\n\nprintln(user.id.value) // Accesses the wrapped value\n"})}),"\n",(0,a.jsx)(n.p,{children:"This enables more type-safe domain models without sacrificing database integration."}),"\n",(0,a.jsx)(n.h3,{id:"5-flexible-schema-management",children:"5. Flexible Schema Management"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed provides tools for schema management:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Create tables\ntransaction {\n    SchemaUtils.create(Users, Posts, Comments)\n}\n\n// Add missing columns during updates\ndatabase.addMissingColumns(Users)\n\n// Drop tables\ntransaction {\n    SchemaUtils.drop(Users)\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Combined with migration tools, this gives you flexible options for evolving your database schema alongside your application."}),"\n",(0,a.jsx)(n.h2,{id:"database-specific-modules",children:"Database-Specific Modules"}),"\n",(0,a.jsx)(n.h3,{id:"h2-integration",children:"H2 Integration"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"exposed-h2"})," module provides specialized support for H2 databases, which are particularly useful for:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Development environments"})," where quick setup is important"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing"})," where database isolation is critical"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Embedded applications"})," that need a lightweight database"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Key features include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"In-memory database support with zero configuration"}),"\n",(0,a.jsx)(n.li,{children:"File-based database options for persistence"}),"\n",(0,a.jsx)(n.li,{children:"Automatic schema creation and teardown"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Quick in-memory database for testing\nval config = h2ConnectionConfig()\nExposedModule.connection(config)\n\n// File-based database for development\nval devConfig = h2ConnectionConfig(\n    name = "myapp",\n    inMemory = false,\n    directory = "./data"\n)\nExposedModule.connection(devConfig)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"postgresql-integration",children:"PostgreSQL Integration"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"exposed-postgres"})," module provides specialized support for PostgreSQL databases, which are ideal for:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Production environments"})," requiring advanced database features"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"High-performance applications"})," needing robust concurrency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data-intensive applications"})," leveraging PostgreSQL's rich data types"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Key features include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Connection pooling for efficient resource use"}),"\n",(0,a.jsx)(n.li,{children:"SSL configuration for secure connections"}),"\n",(0,a.jsx)(n.li,{children:"Support for PostgreSQL-specific data types"}),"\n",(0,a.jsx)(n.li,{children:"Advanced query capabilities"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Basic PostgreSQL connection\nval config = postgresConnectionConfig(\n    host = "localhost",\n    database = "myapp",\n    user = "appuser",\n    password = "password"\n)\nExposedModule.connection(config)\n\n// With connection pooling\nval pooledConfig = postgresConnectionConfig(\n    dataSource = createHikariDataSource() // Your connection pool\n)\nExposedModule.connection(pooledConfig)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-usage-patterns",children:"Advanced Usage Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"custom-type-mapping",children:"Custom Type Mapping"}),"\n",(0,a.jsx)(n.p,{children:"For complex mapping scenarios, Snitch Exposed provides a custom mapping facility:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Define custom mapping between types\nAutoMapper.customMapping<User, UserDTO>(\n    from = { user -> UserDTO(user.name, user.email, "Additional info") },\n    to = { dto -> User(dto.name, dto.email) }\n)\n\n// Now you can convert between them\nval user = User("John", "john@example.com")\nval dto = user.to<UserDTO>()\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is particularly useful for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Converting between persistence models and API models"}),"\n",(0,a.jsx)(n.li,{children:"Handling legacy database schemas"}),"\n",(0,a.jsx)(n.li,{children:"Supporting complex business logic during mapping"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"transaction-strategies",children:"Transaction Strategies"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed supports different transaction strategies to match your application's needs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Explicit transactions for fine-grained control\nPOST("users") isHandledBy {\n    val user = body\n    transaction {\n        // Database operations\n    }\n    "User created".ok\n}\n\n// Transaction-per-request for comprehensive coverage\nwithTransaction {\n    POST("users") with body<User>() isHandledBy {\n        // Everything here runs within a transaction\n    }\n    \n    GET("users") isHandledBy {\n        // This handler also runs in a transaction\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"working-with-relationships",children:"Working with Relationships"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed makes it easy to work with database relationships:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Table definitions\nobject Users : Table("users") {\n    val id = integer("id").autoIncrement()\n    val name = varchar("name", 255)\n    \n    override val primaryKey = PrimaryKey(id)\n}\n\nobject Posts : Table("posts") {\n    val id = integer("id").autoIncrement()\n    val userId = integer("user_id") references Users.id\n    val title = varchar("title", 255)\n    val content = text("content")\n    \n    override val primaryKey = PrimaryKey(id)\n}\n\n// Domain models\ndata class User(val id: Int, val name: String)\ndata class Post(val id: Int, val userId: Int, val title: String, val content: String)\ndata class UserWithPosts(val id: Int, val name: String, val posts: List<Post>)\n\n// Query with relationships\nval usersWithPosts = transaction {\n    Users.findAll<User>().map { user ->\n        val posts = Posts.findAll<Post> { Posts.userId eq user.id }\n        UserWithPosts(user.id, user.name, posts)\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed is designed for performance:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Connection pooling"})," reuses database connections efficiently"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch operations"})," minimize database roundtrips"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lazy loading"})," defers expensive operations until needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Caching"})," reduces redundant database queries"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For maximum performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Batch inserts for bulk operations\ntransaction {\n    Users.batchInsert(userList) {\n        it[name] = it.name\n        it[email] = it.email\n    }\n}\n\n// Targeted queries to minimize data transfer\nval userCount = transaction {\n    Users.selectAll().count()\n} \n\n// Using database-specific optimizations\ntransaction {\n    // PostgreSQL JSON functions for complex data\n    Users.select { Users.metadata.jsonPathExists("$.preferences") }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-snitch-features",children:"Integration with Snitch Features"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed integrates seamlessly with other Snitch features:"}),"\n",(0,a.jsx)(n.h3,{id:"validation-integration",children:"Validation Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'withTransaction {\n    POST("users") with validate<User>() isHandledBy {\n        // Validation runs before the transaction begins\n        // Database operations only happen for valid requests\n        val user = body\n        Users.insert(user)\n        "User created".ok\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"error-handling-integration",children:"Error Handling Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'withTransaction {\n    POST("users") with body<User>() isHandledBy {\n        try {\n            val user = body\n            Users.insert(user)\n            "User created".ok\n        } catch (e: Exception) {\n            // Transaction automatically rolls back\n            "Error: ${e.message}".serverError()\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"testing-integration",children:"Testing Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Test setup with in-memory database\n@BeforeEach\nfun setup() {\n    val config = h2ConnectionConfig()\n    ExposedModule.connection(config)\n    \n    transaction {\n        SchemaUtils.create(TestTable)\n    }\n}\n\n// Test endpoint with transaction\n@Test\nfun `test user creation`() {\n    given {\n        withTransaction {\n            POST("users") with body<User>() isHandledBy {\n                val user = body\n                Users.insert(user)\n                "User created".ok\n            }\n        }\n    } then {\n        POST("/users") withBody User("Test", "test@example.com") expect {\n            expect that it.statusCode() isEqualTo 200\n            \n            // Verify database state\n            transaction {\n                val count = Users.selectAll().count()\n                expect that count isEqualTo 1\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-domain-model-separation",children:"1. Domain Model Separation"}),"\n",(0,a.jsx)(n.p,{children:"Keep your domain models separate from your database entities:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Database table\nobject Users : Table("users") {\n    val id = integer("id").autoIncrement()\n    val name = varchar("name", 255)\n    val email = varchar("email", 255)\n    \n    override val primaryKey = PrimaryKey(id)\n}\n\n// Domain model (persistence)\ndata class UserEntity(val id: Int, val name: String, val email: String)\n\n// Domain model (business logic)\ndata class User(val id: Int, val name: String, val email: String, val isValid: Boolean)\n\n// API model\ndata class UserResponse(val id: Int, val name: String)\n'})}),"\n",(0,a.jsx)(n.p,{children:"This separation allows each model to evolve independently according to its concerns."}),"\n",(0,a.jsx)(n.h3,{id:"2-repository-pattern",children:"2. Repository Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Encapsulate database access in repository classes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class UserRepository {\n    fun findById(id: Int): User? = transaction {\n        Users.findOneOrNull<UserEntity> { Users.id eq id }\n            ?.let { mapToUser(it) }\n    }\n    \n    fun create(user: User): Int = transaction {\n        val entity = mapToEntity(user)\n        Users.insert(entity)[Users.id]\n    }\n    \n    private fun mapToUser(entity: UserEntity): User = // mapping logic\n    private fun mapToEntity(user: User): UserEntity = // mapping logic\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This approach:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Centralizes database access logic"}),"\n",(0,a.jsx)(n.li,{children:"Makes database operations more testable"}),"\n",(0,a.jsx)(n.li,{children:"Provides a clean API for business logic"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-transaction-management",children:"3. Transaction Management"}),"\n",(0,a.jsx)(n.p,{children:"Choose the right transaction boundaries:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Transaction per request (most common)\nwithTransaction {\n    // Multiple endpoint handlers here\n}\n\n// Transaction per operation (more granular)\nPOST("users") isHandledBy {\n    transaction {\n        // Single operation\n    }\n}\n\n// Transaction per unit of work (intermediate)\nPOST("complex-operation") isHandledBy {\n    transaction {\n        // Multiple related operations\n        // Either all succeed or all fail\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-error-handling",children:"4. Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"Implement robust error handling:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'withTransaction {\n    POST("users") with body<User>() isHandledBy {\n        try {\n            // Database operations\n        } catch (e: Exception) {\n            logger.error("Database error", e)\n            when (e) {\n                is UniqueConstraintException -> "User already exists".conflict()\n                is ReferenceConstraintException -> "Referenced entity not found".badRequest()\n                else -> "Internal server error".serverError()\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"5-testing-strategy",children:"5. Testing Strategy"}),"\n",(0,a.jsx)(n.p,{children:"Adopt a comprehensive testing strategy:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Unit tests"}),": Test your repositories in isolation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Integration tests"}),": Test endpoints with an in-memory H2 database"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Schema tests"}),": Verify your schema changes are compatible"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance tests"}),": Validate database performance under load"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Snitch Exposed offers a powerful, type-safe approach to database integration that eliminates boilerplate while maintaining the flexibility and performance needed for real-world applications. By leveraging Kotlin's type system and reflection capabilities, it provides a seamless bridge between your domain models and database schema."}),"\n",(0,a.jsx)(n.p,{children:"Whether you're building a simple application with H2 or a complex system with PostgreSQL, Snitch Exposed gives you the tools to work with databases efficiently and confidently."}),"\n",(0,a.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/JetBrains/Exposed/wiki",children:"Exposed Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://h2database.com/html/main.html",children:"H2 Database Engine"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.postgresql.org/docs/",children:"PostgreSQL Documentation"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var i=s(6540);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);