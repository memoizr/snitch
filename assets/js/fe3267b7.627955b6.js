"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[8455],{504:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"tutorials/Mastering-Snitch-Parameters","title":"Mastering Snitch Parameters","description":"Parameters are a fundamental part of HTTP communication, allowing clients to send data to your server. Snitch provides an expressive, type-safe approach to handling various types of parameters including path parameters, query parameters, headers, and request bodies.","source":"@site/docs/tutorials/Mastering-Snitch-Parameters.md","sourceDirName":"tutorials","slug":"/tutorials/Mastering-Snitch-Parameters","permalink":"/docs/tutorials/Mastering-Snitch-Parameters","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/Mastering-Snitch-Parameters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mastering Snitch Decorations","permalink":"/docs/tutorials/Mastering-Snitch-Decorations"},"next":{"title":"Mastering Snitch Validators","permalink":"/docs/tutorials/Mastering-Snitch-Validators"}}');var t=a(4848),s=a(8453);const i={},l="Mastering Snitch Parameters",o={},d=[{value:"Basic Parameter Types",id:"basic-parameter-types",level:2},{value:"Path Parameters",id:"path-parameters",level:2},{value:"Query Parameters",id:"query-parameters",level:2},{value:"Header Parameters",id:"header-parameters",level:2},{value:"Request Body",id:"request-body",level:2},{value:"Parameter Validation and Transformation",id:"parameter-validation-and-transformation",level:2},{value:"Optional Parameters",id:"optional-parameters",level:2},{value:"Custom Validators",id:"custom-validators",level:2},{value:"Creating Custom Validators",id:"creating-custom-validators",level:3},{value:"Domain Type Conversion",id:"domain-type-conversion",level:2},{value:"Parameter Naming",id:"parameter-naming",level:2},{value:"Advanced Parameter Handling",id:"advanced-parameter-handling",level:2},{value:"Handling Empty Values",id:"handling-empty-values",level:3},{value:"Parameter Visibility in Documentation",id:"parameter-visibility-in-documentation",level:3},{value:"Handling Multiple Values",id:"handling-multiple-values",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Complete Example",id:"complete-example",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mastering-snitch-parameters",children:"Mastering Snitch Parameters"})}),"\n",(0,t.jsx)(n.p,{children:"Parameters are a fundamental part of HTTP communication, allowing clients to send data to your server. Snitch provides an expressive, type-safe approach to handling various types of parameters including path parameters, query parameters, headers, and request bodies."}),"\n",(0,t.jsx)(n.p,{children:"This tutorial will guide you through the complete parameter system in Snitch, from basic usage to advanced validation and transformation techniques."}),"\n",(0,t.jsx)(n.h2,{id:"basic-parameter-types",children:"Basic Parameter Types"}),"\n",(0,t.jsx)(n.p,{children:"Snitch supports all common HTTP parameter types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Path parameters"}),": Values embedded in the URL path (e.g., ",(0,t.jsx)(n.code,{children:"/users/{userId}"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query parameters"}),": Key-value pairs appended to the URL (e.g., ",(0,t.jsx)(n.code,{children:"?page=1&limit=10"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Header parameters"}),": HTTP headers sent with the request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request body"}),": Data sent in the request payload"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's see how each is defined and accessed."}),"\n",(0,t.jsx)(n.h2,{id:"path-parameters",children:"Path Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Path parameters are defined using the ",(0,t.jsx)(n.code,{children:"path()"})," factory function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Define a path parameter\nval userId by path()\n"})}),"\n",(0,t.jsx)(n.p,{children:"Once defined, you can use it in route definitions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId) isHandledBy {\n    // Access the parameter value with request[userId]\n    val userIdValue = request[userId]\n    userRepository.findById(userIdValue).ok\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"You can also define paths with validation in one line:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Define a path parameter with validation\nval postId by path(ofNonEmptyString, description = "Post identifier")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"query-parameters",children:"Query Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Query parameters are defined using the ",(0,t.jsx)(n.code,{children:"query()"})," factory function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Define a required query parameter\nval searchTerm by query(description = "Term to search for")\n\n// With validation\nval limit by query(ofNonNegativeInt, description = "Maximum number of results")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Using query parameters in routes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("search") withQuery searchTerm withQuery limit isHandledBy {\n    // Access the parameters\n    val term = request[searchTerm] // String\n    val maxResults = request[limit] // Int\n    \n    searchService.search(term, maxResults).ok\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"header-parameters",children:"Header Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Header parameters are defined using the ",(0,t.jsx)(n.code,{children:"header()"})," factory function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Define a required header parameter\nval contentType by header(description = "Content type of the request")\n\n// With validation\nval apiVersion by header(ofNonEmptyString, description = "API version to use")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Using header parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'POST("data") withHeader contentType withHeader apiVersion isHandledBy {\n    // Access the headers\n    val type = request[contentType]\n    val version = request[apiVersion]\n    \n    // Use the header values\n    dataService.processData(request.body(), type, version).created\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"request-body",children:"Request Body"}),"\n",(0,t.jsx)(n.p,{children:"Request bodies are handled differently from other parameters. Instead of defining them separately, you declare them directly in the route definition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Define a route with a body parameter\nPOST("users") with body<CreateUserRequest>() isHandledBy {\n    // Access the body with the `body` property\n    val newUser = body\n    \n    userService.createUser(newUser.name, newUser.email).created\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For more complex scenarios, you can use the ",(0,t.jsx)(n.code,{children:"parsing"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val createUser by parsing<CreateUserRequest>() handling {\n    userService.createUser(body.name, body.email).created\n}\n\n// Use the handler\nPOST("users") with body<CreateUserRequest>() isHandledBy createUser\n'})}),"\n",(0,t.jsx)(n.h2,{id:"parameter-validation-and-transformation",children:"Parameter Validation and Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Snitch parameters are not just for accessing raw values - they also validate and transform the input data. The framework provides several built-in validators:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// String validation\nval name by query(ofNonEmptyString)\n\n// Numeric validation\nval age by query(ofPositiveInt)\nval price by query(ofNonNegativeDouble)\n\n// Boolean validation\nval enabled by query(ofBoolean)\n\n// Date validation\nval birthdate by query(ofIsoDate)\n"})}),"\n",(0,t.jsx)(n.p,{children:"These validators:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Check if the input matches expected format"}),"\n",(0,t.jsx)(n.li,{children:"Convert the input to the appropriate type"}),"\n",(0,t.jsx)(n.li,{children:"Return 400 Bad Request with descriptive error messages if validation fails"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Not all parameters are required. For optional parameters, use the ",(0,t.jsx)(n.code,{children:"optionalQuery()"})," and ",(0,t.jsx)(n.code,{children:"optionalHeader()"})," functions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Optional parameter without default (can be null)\nval sort by optionalQuery(ofNonEmptyString, description = "Sort direction")\n\n// Optional parameter with default value\nval page by optionalQuery(ofNonNegativeInt, default = 1, description = "Page number")\nval limit by optionalQuery(ofNonNegativeInt, default = 20, description = "Results per page")\n'})}),"\n",(0,t.jsx)(n.p,{children:"When using optional parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'GET("users") withQuery page withQuery limit withQuery sort isHandledBy {\n    // Access the parameters (with default values applied)\n    val pageNum = request[page]     // Int, defaults to 1 if not provided\n    val pageSize = request[limit]   // Int, defaults to 20 if not provided\n    val sortDir = request[sort]     // String or null if not provided\n    \n    userService.getUsers(pageNum, pageSize, sortDir).ok\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"custom-validators",children:"Custom Validators"}),"\n",(0,t.jsx)(n.p,{children:"While built-in validators cover many scenarios, you'll often need custom validation logic, especially when working with domain-specific types."}),"\n",(0,t.jsx)(n.h3,{id:"creating-custom-validators",children:"Creating Custom Validators"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"stringValidator"})," or ",(0,t.jsx)(n.code,{children:"validator"})," to create custom validators:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Simple custom validator for email format\nval ofEmail = stringValidator("valid email address", """^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}$""".toRegex()) { it }\n\n// Custom validator with transformation to domain type\nval ofUserId = stringValidator("valid UUID") { UserId(UUID.fromString(it)) }\n'})}),"\n",(0,t.jsx)(n.p,{children:"Using custom validators:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val email by query(ofEmail, description = "User email address")\nval userId by path(ofUserId, description = "User identifier")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"domain-type-conversion",children:"Domain Type Conversion"}),"\n",(0,t.jsx)(n.p,{children:"Converting raw parameter values to domain types is a best practice. Snitch makes this seamless:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Define domain types\ndata class UserId(val value: UUID)\ndata class OrderStatus(val value: String) {\n    init {\n        require(value in listOf("PENDING", "COMPLETED", "CANCELLED")) {\n            "Invalid order status: $value"\n        }\n    }\n}\n\n// Create validators for domain types\nval ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }\nval ofOrderStatus = stringValidator("order status") { OrderStatus(it.uppercase()) }\n\n// Use with parameters\nval userId by path(ofUserId)\nval status by query(ofOrderStatus)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"parameter-naming",children:"Parameter Naming"}),"\n",(0,t.jsx)(n.p,{children:"By default, parameter names in requests match their property names in code. You can customize this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Custom parameter name\nval searchQuery by query(name = "q", description = "Search query")\nval userIdentifier by path(name = "user_id", description = "User ID")\n'})}),"\n",(0,t.jsx)(n.p,{children:"With these definitions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The query parameter will be accessed as ",(0,t.jsx)(n.code,{children:"?q=search terms"})]}),"\n",(0,t.jsxs)(n.li,{children:["The path parameter will be defined as ",(0,t.jsx)(n.code,{children:"/users/{user_id}"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advanced-parameter-handling",children:"Advanced Parameter Handling"}),"\n",(0,t.jsx)(n.h3,{id:"handling-empty-values",children:"Handling Empty Values"}),"\n",(0,t.jsx)(n.p,{children:"Control how empty values are treated:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Empty values treated as missing\nval tag by query(emptyAsMissing = true)\n\n// Invalid values treated as missing (for optional parameters)\nval count by optionalQuery(ofNonNegativeInt, invalidAsMissing = true, default = 0)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameter-visibility-in-documentation",children:"Parameter Visibility in Documentation"}),"\n",(0,t.jsx)(n.p,{children:"Control whether parameters appear in public API documentation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Internal parameter not shown in public docs\nval debugMode by optionalQuery(ofBoolean, visibility = Visibility.INTERNAL)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"handling-multiple-values",children:"Handling Multiple Values"}),"\n",(0,t.jsx)(n.p,{children:"For parameters that may be provided multiple times:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Define a repeatable parameter\nval tags by query(ofStringSet)  // Will collect all values into a Set<String>\n\n// Custom repeatable validator\nval ofUserIds = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }\nval userIds by query(ofUserIds)  // Will collect all values into a Collection<UserId>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Domain Types"}),": Convert raw strings to meaningful domain types as early as possible."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Validate Thoroughly"}),": Define validation rules that catch all potential issues before they reach your business logic."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Provide Descriptive Error Messages"}),": Set clear validator descriptions so clients receive helpful error messages."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Set Sensible Defaults"}),": For optional parameters, choose default values that make sense for most use cases."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Document Parameters"}),": Always include a description for parameters to generate comprehensive API documentation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consistent Naming"}),": Use a consistent naming convention for parameter properties."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explicitly Register Parameters"}),": Always declare parameter usage with ",(0,t.jsx)(n.code,{children:"withQuery"}),", ",(0,t.jsx)(n.code,{children:"withHeader"}),", etc., even if the validation is done elsewhere."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Good practice\nGET("users") withQuery page withQuery limit isHandledBy { ... }\n\n// Not recommended (parameters not explicitly registered)\nGET("users") isHandledBy {\n    // Using parameters without registering them\n    val pageValue = request.queryParams("page")\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example demonstrating different parameter types together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Domain types\ndata class UserId(val value: UUID)\ndata class PostId(val value: String)\n\n// Validators\nval ofUserId = stringValidator("valid user ID") { UserId(UUID.fromString(it)) }\nval ofPostId = stringValidator("valid post ID") { PostId(it) }\n\n// Parameters\nval userId by path(ofUserId, description = "User identifier")\nval postId by path(ofPostId, description = "Post identifier")\nval includeComments by query(ofBoolean, description = "Whether to include comments")\nval limit by optionalQuery(ofNonNegativeInt, default = 10, description = "Maximum results")\nval apiVersion by header(ofNonEmptyString, description = "API version")\n\n// Routes\nval userController = routes {\n    GET("users" / userId) withHeader apiVersion isHandledBy getUser\n    \n    GET("users" / userId / "posts") withQuery limit isHandledBy getUserPosts\n    \n    GET("posts" / postId) withQuery includeComments isHandledBy getPost\n}\n\n// Handlers\nval getUser by handling {\n    val user = userService.getUser(request[userId])\n    user.ok\n}\n\nval getUserPosts by handling {\n    val posts = postService.getUserPosts(\n        userId = request[userId],\n        limit = request[limit]\n    )\n    posts.ok\n}\n\nval getPost by handling {\n    val post = postService.getPost(\n        postId = request[postId],\n        includeComments = request[includeComments]\n    )\n    post.ok\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"With Snitch's parameter system, you can build robust, type-safe APIs that validate input data before it reaches your business logic, resulting in cleaner code and better error handling."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var r=a(6540);const t={},s=r.createContext(t);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);