"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[5776],{5907:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorials/UsingShank","title":"Using Shank with Snitch","description":"Shank is a lightweight dependency injection (DI) library for Kotlin that integrates seamlessly with Snitch. This guide covers how to use Shank effectively in your Snitch applications.","source":"@site/docs/tutorials/UsingShank.md","sourceDirName":"tutorials","slug":"/tutorials/UsingShank","permalink":"/docs/tutorials/UsingShank","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/UsingShank.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Shank Design Patterns","permalink":"/docs/tutorials/ShankPatterns"}}');var r=i(4848),t=i(8453);const a={},o="Using Shank with Snitch",l={},d=[{value:"Introduction to Shank",id:"introduction-to-shank",level:2},{value:"Adding Shank to Your Project",id:"adding-shank-to-your-project",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"ShankModule",id:"shankmodule",level:3},{value:"Dependency Scopes",id:"dependency-scopes",level:3},{value:"Defining Dependencies",id:"defining-dependencies",level:2},{value:"Singleton Dependencies",id:"singleton-dependencies",level:3},{value:"Factory Dependencies (new instance each time)",id:"factory-dependencies-new-instance-each-time",level:3},{value:"Scoped Dependencies",id:"scoped-dependencies",level:3},{value:"Dependency Injection with Shank in Snitch",id:"dependency-injection-with-shank-in-snitch",level:2},{value:"Creating Modules",id:"creating-modules",level:3},{value:"Using Dependencies in Handlers",id:"using-dependencies-in-handlers",level:3},{value:"Advanced Shank Features",id:"advanced-shank-features",level:2},{value:"Parameterized Dependencies",id:"parameterized-dependencies",level:3},{value:"Type-bound Dependencies",id:"type-bound-dependencies",level:3},{value:"Testing with Shank",id:"testing-with-shank",level:3},{value:"Integrating with Snitch Middleware",id:"integrating-with-snitch-middleware",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Performance Advantages",id:"performance-advantages",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"using-shank-with-snitch",children:"Using Shank with Snitch"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/memoizr/shank",children:"Shank"})," is a lightweight dependency injection (DI) library for Kotlin that integrates seamlessly with Snitch. This guide covers how to use Shank effectively in your Snitch applications."]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-shank",children:"Introduction to Shank"}),"\n",(0,r.jsx)(n.p,{children:"Shank provides best-in-class performance among all dependency injection frameworks on the JVM, with a simple, strictly type-safe approach that eliminates common pitfalls. Its remarkable features include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Industry-leading performance"}),": Unmatched startup and runtime performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero reflection"}),": No runtime overhead or class scanning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cycle detection"}),": Built-in circular dependency detection using only the Kotlin compiler"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strict type safety"}),": Will never throw runtime exceptions related to types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime resolution"}),": All dependencies are resolved at runtime, supporting hot reloading"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Polymorphism support"}),": Interface-based dependency injection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scoped dependencies"}),": Context-aware dependency scoping"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameterized injection"}),": Dependencies can be scoped to injection parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing support"}),": Easy factory overriding for testing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lightweight"}),": Only 300kb, with virtually no startup overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy initialization"}),": Modules are objects initialized only when needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Infinite extensibility"}),": Supports any custom dependency resolution strategy"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"adding-shank-to-your-project",children:"Adding Shank to Your Project"}),"\n",(0,r.jsx)(n.p,{children:"The Shank library is included as a transitive dependency when you include Snitch, so no additional dependency is needed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'dependencies {\n    implementation("io.github.memoizr:snitch-bootstrap:2.0.0")\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"shankmodule",children:"ShankModule"}),"\n",(0,r.jsxs)(n.p,{children:["The primary building block in Shank is the ",(0,r.jsx)(n.code,{children:"ShankModule"})," interface. You create modules by implementing this interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"object ApplicationModule : ShankModule {\n    // Dependencies will be defined here\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dependency-scopes",children:"Dependency Scopes"}),"\n",(0,r.jsx)(n.p,{children:"Shank offers three main scopes for dependencies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Singleton"})," (",(0,r.jsx)(n.code,{children:"single"}),") - A single instance for the entire application's lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Factory"})," (",(0,r.jsx)(n.code,{children:"new"}),") - Creates a new instance each time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scoped"})," (",(0,r.jsx)(n.code,{children:"scoped"}),") - Instances are scoped to a specific context"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"defining-dependencies",children:"Defining Dependencies"}),"\n",(0,r.jsx)(n.h3,{id:"singleton-dependencies",children:"Singleton Dependencies"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"single"})," for dependencies that should have a single instance throughout the application's lifecycle:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"object ApplicationModule : ShankModule {\n    // Clock is provided as a singleton\n    val clock = single { -> Clock.systemUTC() }\n    \n    // Logger is a singleton with a typed interface\n    val logger = single<Logger> { -> LoggerImpl() }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"factory-dependencies-new-instance-each-time",children:"Factory Dependencies (new instance each time)"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"new"})," for dependencies that should be recreated each time they're requested:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"object ApplicationModule : ShankModule {\n    // Returns a new Instant every time it's called\n    val now = new { -> Instant.now(clock()) }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scoped-dependencies",children:"Scoped Dependencies"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"scoped"})," for dependencies that are tied to a specific context or lifecycle:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"object SessionModule : ShankModule {\n    // User context scoped to a session\n    val userContext = scoped { sessionId: String -> UserContext(sessionId) }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dependency-injection-with-shank-in-snitch",children:"Dependency Injection with Shank in Snitch"}),"\n",(0,r.jsx)(n.h3,{id:"creating-modules",children:"Creating Modules"}),"\n",(0,r.jsx)(n.p,{children:"In a Snitch application, you typically organize dependencies by creating modules for different parts of your application:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// Database-related dependencies\nobject DBModule : ShankModule {\n    val connection = single { ->\n        Database.connect(\n            "jdbc:postgresql://localhost:5432/postgres",\n            driver = "org.postgresql.Driver",\n            user = "postgres",\n            password = "postgres"\n        )\n    }\n    \n    val database = single { -> PostgresDatabase(connection()) }\n}\n\n// Repositories\nobject RepositoriesModule : ShankModule {\n    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }\n    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }\n}\n\n// Security-related dependencies\nobject SecurityModule : ShankModule {\n    val keyPair = single { ->\n        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")\n        keyPairGenerator.initialize(2048)\n        keyPairGenerator.genKeyPair()\n    }\n    \n    val privateKey = single { -> keyPair().private as RSAPrivateCrtKey }\n    val publicKey = single { -> keyPair().public }\n    val hasher = single<IPasswordHasher> { -> PasswordHasher(argon()) }\n    val argon = single { -> Argon2Factory.create() }\n    val jwt = single { -> JWTManager() }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-dependencies-in-handlers",children:"Using Dependencies in Handlers"}),"\n",(0,r.jsx)(n.p,{children:"Once you've defined your dependencies, you can use them in your Snitch handlers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"// User repository is injected\nval usersRepository = RepositoriesModule.usersRepository()\n\nval createUser by parsing<CreateUserRequest>() handling {\n    // jwt manager is injected\n    val jwt = SecurityModule.jwt()\n    \n    // passwordHasher is injected\n    val hasher = SecurityModule.hasher()\n    \n    // Hash the password\n    val hashedPassword = hasher.hash(body.password)\n    \n    // Save the user\n    val user = usersRepository.createUser(body.username, hashedPassword)\n    \n    // Generate a token\n    val token = jwt.createToken(user.id)\n    \n    // Return the response\n    CreateUserResponse(user.id, token).created\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-shank-features",children:"Advanced Shank Features"}),"\n",(0,r.jsx)(n.h3,{id:"parameterized-dependencies",children:"Parameterized Dependencies"}),"\n",(0,r.jsx)(n.p,{children:"Shank supports dependencies with parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'object CacheModule : ShankModule {\n    val cache = single { region: String -> Cache(region) }\n}\n\n// Usage\nval userCache = CacheModule.cache("users")\nval postCache = CacheModule.cache("posts")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-bound-dependencies",children:"Type-bound Dependencies"}),"\n",(0,r.jsx)(n.p,{children:"You can bind an implementation to an interface:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"object RepositoriesModule : ShankModule {\n    // Bind PostgresUsersRepository to UsersRepository interface\n    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }\n}\n\n// Usage\nval repo: UsersRepository = RepositoriesModule.usersRepository()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"testing-with-shank",children:"Testing with Shank"}),"\n",(0,r.jsx)(n.p,{children:"Shank makes testing easier by allowing you to override dependencies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"@BeforeEach\nfun setup() {\n    // Override real implementation with mock\n    RepositoriesModule.usersRepository.overrideFactory { -> mockUsersRepository }\n}\n\n@AfterEach\nfun tearDown() {\n    // Restore original implementation\n    RepositoriesModule.usersRepository.restore()\n    \n    // Or reset all overrides\n    resetShank()\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integrating-with-snitch-middleware",children:"Integrating with Snitch Middleware"}),"\n",(0,r.jsx)(n.p,{children:"You can create middleware that injects dependencies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'val Router.withTransaction get() = decorateWith {\n    val database = DBModule.postgresDatabase()\n    database.transaction {\n        next()\n    }\n}\n\n// Usage\nroutes {\n    withTransaction {\n        POST("users") with body<CreateUserRequest>() isHandledBy createUser\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Organize by Module"}),": Group related dependencies in modules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interface-based Design"}),": Bind implementations to interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Responsibility"}),": Keep modules focused on a specific area"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy Initialization"}),": Dependencies are only created when needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Use overrides for test mocks"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example of using Shank with Snitch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'import snitch.dsl.*\nimport snitch.gson.GsonJsonParser\nimport snitch.shank.ShankModule\nimport snitch.shank.single\n\n// Define modules\nobject AppModule : ShankModule {\n    val logger = single { -> Logger() }\n}\n\nobject UserModule : ShankModule {\n    val userRepository = single { -> UserRepositoryImpl() }\n    val userService = single { -> UserService(userRepository()) }\n}\n\n// Define handlers using dependencies\nval getUserById by handling {\n    val userService = UserModule.userService()\n    val logger = AppModule.logger()\n    \n    logger.info("Getting user with ID: ${request[userId]}")\n    \n    val user = userService.getUser(request[userId])\n    user?.ok ?: "User not found".notFound()\n}\n\n// Define parameters\nval userId by path()\n\n// Configure routes\nfun main() {\n    snitch(GsonJsonParser)\n        .onRoutes {\n            GET("users" / userId) isHandledBy getUserById\n        }\n        .start()\n        .serveDocumenation()\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-advantages",children:"Performance Advantages"}),"\n",(0,r.jsx)(n.p,{children:"Shank's performance advantages come from several key design decisions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero reflection"}),": Unlike Spring or Guice which rely on runtime reflection, Shank uses pure Kotlin function references and type inference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No proxy generation"}),": Dependencies are direct instances, not proxies, eliminating overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No annotation processing"}),": No compile-time code generation or annotation scanning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy evaluation"}),": Dependencies are only instantiated when needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal dependency graph traversal"}),": Optimized dependency resolution algorithm"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These advantages result in:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Faster application startup times"}),"\n",(0,r.jsx)(n.li,{children:"Lower memory consumption"}),"\n",(0,r.jsx)(n.li,{children:"Reduced CPU overhead"}),"\n",(0,r.jsx)(n.li,{children:"Smaller deployment artifacts"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Shank provides the highest-performing, most type-safe dependency injection solution available for Kotlin applications, with unmatched integration with Snitch. By organizing dependencies into modules and leveraging Shank's powerful yet simple API, you can create maintainable, testable applications with minimal boilerplate and maximum performance."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);