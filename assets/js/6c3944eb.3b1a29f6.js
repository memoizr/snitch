"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[5303],{5957:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorials/Anatomy-of-Endpoints","title":"Anatomy of the Snitch Endpoint DSL","description":"Endpoints are the fundamental building blocks of your API in Snitch. This guide explores the internal structure of the Endpoint DSL, explaining how endpoints are defined, configured, and composed to create expressive, type-safe APIs.","source":"@site/docs/tutorials/Anatomy-of-Endpoints.md","sourceDirName":"tutorials","slug":"/tutorials/Anatomy-of-Endpoints","permalink":"/docs/tutorials/Anatomy-of-Endpoints","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/Anatomy-of-Endpoints.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Snitch","permalink":"/docs/Docs"},"next":{"title":"Anatomy of the Snitch Handler DSL","permalink":"/docs/tutorials/Anatomy-of-Handlers"}}');var i=t(4848),r=t(8453);const o={},a="Anatomy of the Snitch Endpoint DSL",d={},l=[{value:"The Endpoint Data Class",id:"the-endpoint-data-class",level:2},{value:"Creating Endpoints",id:"creating-endpoints",level:2},{value:"HTTP Method Functions",id:"http-method-functions",level:3},{value:"Path Construction",id:"path-construction",level:3},{value:"Route Nesting",id:"route-nesting",level:3},{value:"Configuring Endpoints",id:"configuring-endpoints",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Conditions",id:"conditions",level:3},{value:"Decorations",id:"decorations",level:3},{value:"Before and After Actions",id:"before-and-after-actions",level:3},{value:"Endpoint Handlers",id:"endpoint-handlers",level:2},{value:"The Router Interface",id:"the-router-interface",level:2},{value:"Extension and Customization",id:"extension-and-customization",level:2},{value:"Extending Endpoint with New Capabilities",id:"extending-endpoint-with-new-capabilities",level:3},{value:"Creating DSL Extensions",id:"creating-dsl-extensions",level:3},{value:"Type Safety Aspects",id:"type-safety-aspects",level:2},{value:"Under the Hood: Request Processing",id:"under-the-hood-request-processing",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"anatomy-of-the-snitch-endpoint-dsl",children:"Anatomy of the Snitch Endpoint DSL"})}),"\n",(0,i.jsx)(n.p,{children:"Endpoints are the fundamental building blocks of your API in Snitch. This guide explores the internal structure of the Endpoint DSL, explaining how endpoints are defined, configured, and composed to create expressive, type-safe APIs."}),"\n",(0,i.jsx)(n.h2,{id:"the-endpoint-data-class",children:"The Endpoint Data Class"}),"\n",(0,i.jsxs)(n.p,{children:["At the core of Snitch's routing system is the ",(0,i.jsx)(n.code,{children:"Endpoint"})," data class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Endpoint<T: Any>(\n    val method: Method,\n    val path: String,\n    val parameters: List<Parameter<*, *>> = emptyList(),\n    val conditions: List<Condition> = emptyList(),\n    val decorations: List<Decoration> = emptyList(),\n    val beforeActions: List<RequestWrapper.() -> Response?> = emptyList(),\n    val afterActions: List<RequestWrapper.() -> Unit> = emptyList(),\n    val handler: (RequestWrapper.() -> T)? = null\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's examine each component:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Parameter"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"T"}),": The return type of the handler function, which determines the response type"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"method"}),": The HTTP method (GET, POST, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"path"}),": The URL path, potentially including parameter placeholders"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parameters"}),": List of parameters (path, query, header, body) this endpoint uses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"conditions"}),": List of conditions that must be satisfied for the endpoint to execute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"decorations"}),": List of decorations that modify the endpoint's behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"beforeActions"}),": Actions executed before the handler runs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"afterActions"}),": Actions executed after the handler completes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"handler"}),": The function that processes the request and produces a response"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The data class design is crucial for Snitch's flexibility and composability. Since endpoints are immutable data objects, they can be transformed and combined in powerful ways without side effects."}),"\n",(0,i.jsx)(n.h2,{id:"creating-endpoints",children:"Creating Endpoints"}),"\n",(0,i.jsx)(n.p,{children:"Endpoints are typically created through the HTTP method functions and then configured with additional features."}),"\n",(0,i.jsx)(n.h3,{id:"http-method-functions",children:"HTTP Method Functions"}),"\n",(0,i.jsx)(n.p,{children:"Snitch provides functions for each HTTP method:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun GET(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.GET, path = ensureLeadingSlash(path))\n\nfun POST(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.POST, path = ensureLeadingSlash(path))\n\nfun PUT(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.PUT, path = ensureLeadingSlash(path))\n\nfun DELETE(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.DELETE, path = ensureLeadingSlash(path))\n\nfun PATCH(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.PATCH, path = ensureLeadingSlash(path))\n\nfun OPTIONS(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.OPTIONS, path = ensureLeadingSlash(path))\n\nfun HEAD(path: String = ""): Endpoint<Any> = \n    Endpoint(method = Method.HEAD, path = ensureLeadingSlash(path))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Each function creates an ",(0,i.jsx)(n.code,{children:"Endpoint"})," with the specified HTTP method and path, returning a fresh ",(0,i.jsx)(n.code,{children:"Endpoint"})," instance ready for further configuration."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users")       // Creates a GET endpoint for /users\nPOST("users")      // Creates a POST endpoint for /users\nPUT("users/123")   // Creates a PUT endpoint for /users/123\n'})}),"\n",(0,i.jsx)(n.h3,{id:"path-construction",children:"Path Construction"}),"\n",(0,i.jsx)(n.p,{children:"Paths can be constructed in several ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"String literals"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users/profile")\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Path parameters"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val userId by path()\nGET("users" / userId)\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Path composition with the ",(0,i.jsx)(n.code,{children:"/"})," operator"]}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId / "posts" / postId)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"/"})," operator is an extension function on ",(0,i.jsx)(n.code,{children:"String"})," that concatenates path segments:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'operator fun String.div(other: String): String = \n    "$this/$other".replace("//", "/")\n\noperator fun String.div(param: Parameter<*, *>): String = \n    "$this/{${param.name}}".replace("//", "/")\n'})}),"\n",(0,i.jsx)(n.p,{children:"This elegant approach allows paths to be constructed in a readable, composable way."}),"\n",(0,i.jsx)(n.h3,{id:"route-nesting",children:"Route Nesting"}),"\n",(0,i.jsx)(n.p,{children:"Snitch supports route nesting through a DSL that allows hierarchical organization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'routes {\n    "api" / {\n        "v1" / {\n            "users" / {\n                GET() isHandledBy getUsersHandler\n                POST() with body<CreateUserRequest>() isHandledBy createUserHandler\n                \n                userId / {\n                    GET() isHandledBy getUserHandler\n                    PUT() with body<UpdateUserRequest>() isHandledBy updateUserHandler\n                    DELETE() isHandledBy deleteUserHandler\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Behind the scenes, this is implemented using a hierarchical context that tracks the current path prefix:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class RouterContext(private val pathPrefix: String = "") {\n    fun String.div(block: RouterContext.() -> Unit) {\n        val newContext = RouterContext("$pathPrefix/$this".replace("//", "/"))\n        newContext.block()\n    }\n    \n    fun GET(path: String = ""): Endpoint<Any> = \n        Endpoint(Method.GET, "$pathPrefix/$path".replace("//", "/"))\n    \n    // Other HTTP method functions...\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This approach allows you to organize routes according to your API's logical structure."}),"\n",(0,i.jsx)(n.h2,{id:"configuring-endpoints",children:"Configuring Endpoints"}),"\n",(0,i.jsxs)(n.p,{children:["Once an endpoint is created, it can be configured with various features. These configurations are applied through extension functions that return new ",(0,i.jsx)(n.code,{children:"Endpoint"})," instances with the desired modifications."]}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Parameters are added using the ",(0,i.jsx)(n.code,{children:"with"})," function and its variants:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun <T: Any> Endpoint<T>.with(vararg params: Parameter<*, *>): Endpoint<T> =\n    copy(parameters = parameters + params)\n\nfun <T: Any> Endpoint<T>.withQueries(vararg params: Parameter<*, *>): Endpoint<T> =\n    with(*params)\n\nfun <T: Any> Endpoint<T>.withHeaders(vararg params: Parameter<*, *>): Endpoint<T> =\n    with(*params)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val limit by query(ofIntRange(1, 100), default = 20)\nval offset by query(ofNonNegativeInt, default = 0)\nval apiKey by header(ofNonEmptyString)\n\nGET("users")\n    .withQueries(limit, offset)\n    .withHeaders(apiKey)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Internally, these functions simply add the parameters to the endpoint's parameter list, making them available for validation and access in the handler."}),"\n",(0,i.jsx)(n.h3,{id:"conditions",children:"Conditions"}),"\n",(0,i.jsxs)(n.p,{children:["Conditions are added using the ",(0,i.jsx)(n.code,{children:"onlyIf"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"infix fun <T: Any> Endpoint<T>.onlyIf(condition: Condition): Endpoint<T> =\n    copy(conditions = conditions + condition)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val hasAdminRole = condition("hasAdminRole") { /* implementation */ }\n\nGET("admin/dashboard") onlyIf hasAdminRole\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"onlyIf"})," function appends the condition to the endpoint's conditions list. During request processing, all conditions are evaluated before the handler executes."]}),"\n",(0,i.jsx)(n.h3,{id:"decorations",children:"Decorations"}),"\n",(0,i.jsxs)(n.p,{children:["Decorations are added using the ",(0,i.jsx)(n.code,{children:"decorated"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"infix fun <T: Any> Endpoint<T>.decorated(with: Decoration): Endpoint<T> =\n    copy(decorations = decorations + with)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val withLogging = decoration { /* implementation */ }\n\nGET("users") decorated withLogging\n'})}),"\n",(0,i.jsx)(n.p,{children:"Decorations provide a way to wrap handler execution with custom logic, similar to middleware in other frameworks."}),"\n",(0,i.jsx)(n.h3,{id:"before-and-after-actions",children:"Before and After Actions"}),"\n",(0,i.jsx)(n.p,{children:"Before and after actions allow executing code before and after the handler:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun <T: Any> Endpoint<T>.doBefore(action: RequestWrapper.() -> Response?): Endpoint<T> =\n    copy(beforeActions = beforeActions + action)\n\nfun <T: Any> Endpoint<T>.doAfter(action: RequestWrapper.() -> Unit): Endpoint<T> =\n    copy(afterActions = afterActions + action)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users")\n    .doBefore { \n        logger.info("Accessing users endpoint")\n        // Optionally return a Response to short-circuit\n        null \n    }\n    .doAfter { \n        logger.info("Completed users endpoint request")\n    }\n'})}),"\n",(0,i.jsx)(n.p,{children:"These functions append actions to the respective lists in the endpoint. During request processing, before actions run in reverse declaration order (last declared, first executed), while after actions run in declaration order."}),"\n",(0,i.jsx)(n.h2,{id:"endpoint-handlers",children:"Endpoint Handlers"}),"\n",(0,i.jsx)(n.p,{children:"While we won't delve deeply into handlers here, it's worth understanding how they connect to endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"infix fun <T: Any> Endpoint<T>.isHandledBy(handler: RequestWrapper.() -> T): Endpoint<T> =\n    copy(handler = handler)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"isHandledBy"})," function associates a handler with an endpoint. The handler is a function that:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Receives a ",(0,i.jsx)(n.code,{children:"RequestWrapper"})," as its receiver"]}),"\n",(0,i.jsxs)(n.li,{children:["Returns a value of type ",(0,i.jsx)(n.code,{children:"T"}),", which determines the response type"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This type-safe design ensures that handlers return appropriate values that can be converted to HTTP responses."}),"\n",(0,i.jsx)(n.h2,{id:"the-router-interface",children:"The Router Interface"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Router"})," interface defines a collection of endpoints:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"interface Router {\n    val endpoints: List<Endpoint<*>>\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Routers can be composed and nested, allowing for modular API organization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun routes(block: RouterBuilder.() -> Unit): Router {\n    val builder = RouterBuilder()\n    builder.block()\n    return builder.build()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"RouterBuilder"})," class accumulates endpoints during DSL execution:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class RouterBuilder {\n    private val mutableEndpoints = mutableListOf<Endpoint<*>>()\n    \n    fun <T: Any> endpoint(endpoint: Endpoint<T>) {\n        mutableEndpoints.add(endpoint)\n    }\n    \n    fun build(): Router = object : Router {\n        override val endpoints = mutableEndpoints.toList()\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This builder-based approach allows for a clean DSL while maintaining immutability of the resulting routers."}),"\n",(0,i.jsx)(n.h2,{id:"extension-and-customization",children:"Extension and Customization"}),"\n",(0,i.jsx)(n.p,{children:"One of Snitch's most powerful features is its extensibility. Since endpoints are data classes and the DSL is built from extension functions, you can easily add new capabilities."}),"\n",(0,i.jsx)(n.h3,{id:"extending-endpoint-with-new-capabilities",children:"Extending Endpoint with New Capabilities"}),"\n",(0,i.jsx)(n.p,{children:"You can add new features to endpoints by defining extension functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun <T: Any> Endpoint<T>.withTimeout(milliseconds: Long): Endpoint<T> =\n    decorated(TimeoutDecoration(milliseconds))\n\n// Usage\nGET("slow-operation") withTimeout 5000\n'})}),"\n",(0,i.jsx)(n.p,{children:"This approach allows you to create domain-specific extensions tailored to your application's needs."}),"\n",(0,i.jsx)(n.h3,{id:"creating-dsl-extensions",children:"Creating DSL Extensions"}),"\n",(0,i.jsx)(n.p,{children:"You can even extend the DSL with new constructs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'infix fun <T: Any> Endpoint<T>.v(version: Int): Endpoint<T> =\n    copy(path = path.replace("/v1/", "/v$version/"))\n\n// Usage\nGET("v1/users") v 2 isHandledBy getUsersV2Handler\n'})}),"\n",(0,i.jsx)(n.p,{children:"This creates an expressive way to define versioned endpoints. Because endpoints are data classes, transformations like this are straightforward and composable."}),"\n",(0,i.jsx)(n.h2,{id:"type-safety-aspects",children:"Type Safety Aspects"}),"\n",(0,i.jsx)(n.p,{children:"Snitch's Endpoint DSL is designed with type safety as a primary consideration:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameter Type Safety"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val userId by path(ofLong)\n\n// In the handler:\nval id: Long = request[userId] // Type-safe access\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handler Return Types"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users") isHandledBy {\n    // Must return a value compatible with the endpoint type\n    listOf("user1", "user2").ok\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Condition Composition"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("resource") onlyIf (isAuthenticated and (isResourceOwner or hasAdminRole))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The boolean operators (",(0,i.jsx)(n.code,{children:"and"}),", ",(0,i.jsx)(n.code,{children:"or"}),", ",(0,i.jsx)(n.code,{children:"not"}),") are type-checked at compile time."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Method Chaining"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("users")\n    .withQueries(limit, offset)\n    .onlyIf(isAuthenticated)\n    .doBefore { /* ... */ }\n    .isHandledBy { /* ... */ }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Each method returns the appropriate endpoint type, ensuring the chain remains type-safe."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This comprehensive type safety catches many potential errors at compile time, dramatically reducing runtime issues."}),"\n",(0,i.jsx)(n.h2,{id:"under-the-hood-request-processing",children:"Under the Hood: Request Processing"}),"\n",(0,i.jsx)(n.p,{children:"When a request arrives, Snitch processes it through several stages:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Route Matching"}),": Snitch finds the endpoint that matches the HTTP method and path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter Extraction and Validation"}),": Parameters are extracted from the request and validated"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Condition Evaluation"}),": All conditions are evaluated; if any fail, the request is rejected"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoration Setup"}),": Decorations are arranged to wrap the handler execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Before Actions"}),": Before actions are executed in reverse order"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Handler Execution"}),": The handler processes the request"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"After Actions"}),": After actions are executed in declaration order"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This pipeline is reflected in the ",(0,i.jsx)(n.code,{children:"Endpoint"})," data class structure, with each component corresponding to a stage in request processing."]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"Based on the internal workings of endpoints, here are some best practices:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Organize by Resource"}),": Structure your routes around resources and sub-resources"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'"users" / {\n    GET() // List users\n    POST() // Create user\n    \n    userId / {\n        GET() // Get user\n        PUT() // Update user\n        DELETE() // Delete user\n        \n        "posts" / {\n            // User\'s posts resources\n        }\n    }\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Keep Endpoints Focused"}),": Each endpoint should handle a single responsibility"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Extract Shared Logic"}),": Use decorations and conditions to extract cross-cutting concerns"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val authenticated = decorateWith { /* authentication logic */ }\n\nauthenticated {\n    // All routes here require authentication\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Leverage Type-Safe Parameters"}),": Define all parameters with appropriate validators"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val limit by query(ofIntRange(1, 100), default = 20)\n\n// Better than:\nval limit by query() // String that needs manual validation\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Extension Methods for Common Patterns"}),": Create extension functions for frequent use cases"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun <T: Any> Endpoint<T>.withCache(durationSeconds: Int): Endpoint<T> =\n    decorated(CacheDecoration(durationSeconds))\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Modularize Routers"}),": Break large APIs into smaller, composable routers"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val userRoutes = routes { /* user endpoints */ }\nval postRoutes = routes { /* post endpoints */ }\n\nval apiRoutes = routes {\n    "api" / {\n        "users" / userRoutes\n        "posts" / postRoutes\n    }\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Follow RESTful Conventions"}),": Use appropriate HTTP methods for different operations"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"GET(resourceId)   // Read a resource\nPOST()            // Create a resource\nPUT(resourceId)   // Update a resource\nDELETE(resourceId) // Delete a resource\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The Endpoint DSL in Snitch provides a powerful, type-safe way to define and configure API endpoints. By understanding its internal structure and capabilities, you can create expressive, maintainable APIs that leverage Kotlin's type system for robust error checking."}),"\n",(0,i.jsx)(n.p,{children:"The data class foundation, combined with extension functions and builders, creates a DSL that is both flexible and type-safe, allowing for easy customization while catching errors at compile time."}),"\n",(0,i.jsx)(n.p,{children:"This design exemplifies how thoughtful API design can leverage language features to create expressive yet safe interfaces for complex functionality."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);