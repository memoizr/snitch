"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[9702],{3039:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"in depth/Anatomy-of-Handlers","title":"Handler DSL","description":"Handlers are the core of your API\'s business logic in Snitch. They process incoming requests, execute application code, and produce responses. This guide explores the inner workings of Snitch\'s Handler DSL, explaining how handlers are defined, composed, and integrated with the rest of the framework.","source":"@site/docs/in depth/Anatomy-of-Handlers.md","sourceDirName":"in depth","slug":"/in depth/Anatomy-of-Handlers","permalink":"/docs/in depth/Anatomy-of-Handlers","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/in depth/Anatomy-of-Handlers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Endpoint DSL","permalink":"/docs/in depth/Anatomy-of-Endpoints"},"next":{"title":"Validator DSL","permalink":"/docs/in depth/Anatomy-of-Validators"}}');var a=s(4848),t=s(8453);const i={},l="Handler DSL",o={},d=[{value:"Handler Fundamentals",id:"handler-fundamentals",level:2},{value:"The RequestWrapper",id:"the-requestwrapper",level:2},{value:"Response Creation",id:"response-creation",level:2},{value:"The HttpResponse Hierarchy",id:"the-httpresponse-hierarchy",level:3},{value:"Response Extensions",id:"response-extensions",level:3},{value:"Status Codes",id:"status-codes",level:3},{value:"Handler Definition Approaches",id:"handler-definition-approaches",level:2},{value:"Inline Handlers",id:"inline-handlers",level:3},{value:"Named Handlers",id:"named-handlers",level:3},{value:"Reusable Handlers",id:"reusable-handlers",level:3},{value:"Type-Safe Parameter Access",id:"type-safe-parameter-access",level:2},{value:"Body Handling",id:"body-handling",level:2},{value:"Error Handling in Handlers",id:"error-handling-in-handlers",level:2},{value:"1. Return explicit error responses:",id:"1-return-explicit-error-responses",level:3},{value:"2. Throw exceptions that are handled globally:",id:"2-throw-exceptions-that-are-handled-globally",level:3},{value:"Asynchronous Handlers",id:"asynchronous-handlers",level:2},{value:"The Handler Execution Pipeline",id:"the-handler-execution-pipeline",level:2},{value:"Testing Handlers",id:"testing-handlers",level:2},{value:"Handler Implementation Details",id:"handler-implementation-details",level:2},{value:"Handler Function Types",id:"handler-function-types",level:3},{value:"Handler References",id:"handler-references",level:3},{value:"Handler Execution",id:"handler-execution",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Handlers Focused",id:"1-keep-handlers-focused",level:3},{value:"2. Leverage Type Safety",id:"2-leverage-type-safety",level:3},{value:"3. Use Named Handlers for Complex Logic",id:"3-use-named-handlers-for-complex-logic",level:3},{value:"4. Structure Error Handling Appropriately",id:"4-structure-error-handling-appropriately",level:3},{value:"5. Use Coroutines for I/O-Bound Operations",id:"5-use-coroutines-for-io-bound-operations",level:3},{value:"6. Group Related Handlers",id:"6-group-related-handlers",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"handler-dsl",children:"Handler DSL"})}),"\n",(0,a.jsx)(n.p,{children:"Handlers are the core of your API's business logic in Snitch. They process incoming requests, execute application code, and produce responses. This guide explores the inner workings of Snitch's Handler DSL, explaining how handlers are defined, composed, and integrated with the rest of the framework."}),"\n",(0,a.jsx)(n.h2,{id:"handler-fundamentals",children:"Handler Fundamentals"}),"\n",(0,a.jsx)(n.p,{children:"At its core, a handler in Snitch is simply a function that:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Takes a ",(0,a.jsx)(n.code,{children:"RequestWrapper"})," as its receiver (via Kotlin's function literal with receiver syntax)"]}),"\n",(0,a.jsx)(n.li,{children:"Returns a value that can be converted to an HTTP response"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The basic signature looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"typealias Handler<T> = RequestWrapper.() -> T\n"})}),"\n",(0,a.jsx)(n.p,{children:"This simple design allows handlers to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Access request data through the ",(0,a.jsx)(n.code,{children:"RequestWrapper"})," receiver"]}),"\n",(0,a.jsx)(n.li,{children:"Return any type that can be serialized to a response"}),"\n",(0,a.jsx)(n.li,{children:"Leverage Kotlin's powerful type system"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Let's explore how this works in practice."}),"\n",(0,a.jsx)(n.h2,{id:"the-requestwrapper",children:"The RequestWrapper"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"RequestWrapper"})," is the handler's interface to the incoming request. It provides access to:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"interface RequestWrapper {\n    val method: Method\n    val path: String\n    val queryParams: Map<String, Collection<String>>\n    val headerParams: Map<String, Collection<String>>\n    val pathParams: Map<String, String>\n    val parser: Parser\n    val attributes: MutableMap<String, Any>\n    \n    operator fun <T> get(parameter: Parameter<*, T>): T\n    \n    // Additional utility methods...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The key components are:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Request metadata"}),": Method, path, and raw parameter maps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parser"}),": For converting strings to/from structured data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Attributes"}),": A mutable map for storing request-scoped data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter access"}),": Type-safe access to validated parameters via the ",(0,a.jsx)(n.code,{children:"get"})," operator"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"get"})," operator is particularly important, as it provides type-safe access to parameters:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val userId = request[userId] // Returns the validated parameter value with correct type\n"})}),"\n",(0,a.jsx)(n.p,{children:"Under the hood, this operator:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Looks up the parameter's value(s) from the appropriate source (path, query, header, body)"}),"\n",(0,a.jsx)(n.li,{children:"Validates the value(s) using the parameter's validator"}),"\n",(0,a.jsx)(n.li,{children:"Transforms the value(s) to the target type"}),"\n",(0,a.jsx)(n.li,{children:"Returns the strongly-typed result"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If validation fails, the framework automatically returns an appropriate error response."}),"\n",(0,a.jsx)(n.h2,{id:"response-creation",children:"Response Creation"}),"\n",(0,a.jsxs)(n.p,{children:["Snitch provides a rich DSL for creating HTTP responses. The core mechanism is extension properties and functions on any type, which create subclasses of the sealed ",(0,a.jsx)(n.code,{children:"HttpResponse"})," class."]}),"\n",(0,a.jsx)(n.h3,{id:"the-httpresponse-hierarchy",children:"The HttpResponse Hierarchy"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"HttpResponse"})," is a sealed class with three implementations:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"sealed class HttpResponse<T, out S : StatusCodes> {\n    abstract val statusCode: StatusCodes\n    abstract val headers: Map<String, String>\n    abstract val value: context(Parser) () -> Any?\n    abstract fun header(header: Pair<String, String>): HttpResponse<T, S>\n    \n    // Provides a way to transform responses based on their type\n    fun map(\n        failure: ErrorHttpResponse<T, *, S>.() -> HttpResponse<Any, *> = { this as HttpResponse<Any, *> },\n        success: SuccessfulHttpResponse<T, S>.() -> HttpResponse<Any, *>,\n    ): HttpResponse<Any, *> = when (this) {\n        is SuccessfulHttpResponse -> this.success()\n        is ErrorHttpResponse<T, *, S> -> this.failure()\n        is RawHttpResponse -> throw UnsupportedOperationException()\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The three implementations are:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"SuccessfulHttpResponse"}),": For 2xx status codes, with typed body content"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"data class SuccessfulHttpResponse<T, out S : StatusCodes>(\n    override val statusCode: S,\n    val body: T,\n    val _format: Format = Format.Json,\n    override val value: context(Parser) () -> Any? = { /* serialization logic */ },\n    override val headers: Map<String, String> = emptyMap(),\n) : HttpResponse<T, S>()\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ErrorHttpResponse"}),": For error status codes (4xx, 5xx), with typed error details"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"data class ErrorHttpResponse<T, E, out S : StatusCodes>(\n    override val statusCode: StatusCodes,\n    val details: E,\n    override val value: context(Parser) () -> Any? = { details?.serialized },\n    override val headers: Map<String, String> = emptyMap(),\n) : HttpResponse<T, S>()\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"RawHttpResponse"}),": For sending raw content with minimal processing"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"data class RawHttpResponse<T, out S : StatusCodes>(\n    override val statusCode: S,\n    val body: Any,\n    val _format: Format = Format.Json,\n    override val value: context(Parser) () -> Any? = { body },\n    override val headers: Map<String, String> = emptyMap(),\n) : HttpResponse<T, S>()\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"response-extensions",children:"Response Extensions"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CommonResponses"})," interface provides extension properties and functions to create responses with minimal syntax:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Success responses\nval <T> T.ok get() = SuccessfulHttpResponse(StatusCodes.OK, this)\nval <T> T.created get() = SuccessfulHttpResponse(StatusCodes.CREATED, this)\nval <T> T.accepted get() = SuccessfulHttpResponse(StatusCodes.ACCEPTED, this)\nval <T> T.noContent get() = SuccessfulHttpResponse(StatusCodes.NO_CONTENT, this)\n\n// Error responses\nfun <T, E, S: StatusCodes> E.badRequest() = ErrorHttpResponse<T, _, S>(StatusCodes.BAD_REQUEST, this)\nfun <T, E, S: StatusCodes> E.unauthorized() = ErrorHttpResponse<T, _,S>(StatusCodes.UNAUTHORIZED, this)\nfun <T, E, S: StatusCodes> E.forbidden() = ErrorHttpResponse<T, _, S>(StatusCodes.FORBIDDEN, this)\nfun <T, E, S: StatusCodes> E.notFound() = ErrorHttpResponse<T, _, S>(StatusCodes.NOT_FOUND, this)\nfun <T, E, S: StatusCodes> E.serverError() = ErrorHttpResponse<T, _, S>(StatusCodes.INTERNAL_SERVER_ERROR, this)\n\n// Format control\nfun <T, S : StatusCodes> HttpResponse<T, S>.format(newFormat: Format) = /* ... */\nval <T, S : StatusCodes> HttpResponse<T, S>.plainText get() = /* ... */\n"})}),"\n",(0,a.jsx)(n.p,{children:"This allows handlers to return responses in a concise, readable way:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val getUser by handling {\n    val user = userRepository.findById(request[userId])\n    if (user != null) user.ok\n    else "User not found".notFound()\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"status-codes",children:"Status Codes"}),"\n",(0,a.jsxs)(n.p,{children:["Status codes are modeled as singleton objects within the ",(0,a.jsx)(n.code,{children:"StatusCodes"})," abstract class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"abstract class StatusCodes(val code: Int = 200) {\n    object OK : StatusCodes(200)\n    object CREATED : StatusCodes(201)\n    object ACCEPTED : StatusCodes(202)\n    object NO_CONTENT : StatusCodes(204)\n    \n    object BAD_REQUEST : StatusCodes(400)\n    object UNAUTHORIZED : StatusCodes(401)\n    object FORBIDDEN : StatusCodes(403)\n    object NOT_FOUND : StatusCodes(404)\n    object TOO_MANY_REQUESTS : StatusCodes(429)\n    \n    object INTERNAL_SERVER_ERROR : StatusCodes(500)\n    object SERVICE_UNAVAILABLE : StatusCodes(503)\n    // Plus many other standard HTTP status codes\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When the response is rendered, the framework:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Sets the HTTP status code to ",(0,a.jsx)(n.code,{children:"statusCode.code"})]}),"\n",(0,a.jsx)(n.li,{children:"Serializes the body or details based on the response type and format"}),"\n",(0,a.jsx)(n.li,{children:"Adds any custom headers defined in the response"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This design provides several advantages:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Type safety through generics"}),"\n",(0,a.jsx)(n.li,{children:"Clear distinction between success and error responses"}),"\n",(0,a.jsx)(n.li,{children:"Flexible content format handling (JSON, plain text, etc.)"}),"\n",(0,a.jsxs)(n.li,{children:["Support for response transformation with the ",(0,a.jsx)(n.code,{children:"map"})," function"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"handler-definition-approaches",children:"Handler Definition Approaches"}),"\n",(0,a.jsx)(n.p,{children:"Snitch offers several ways to define handlers, each with its own use cases."}),"\n",(0,a.jsx)(n.h3,{id:"inline-handlers",children:"Inline Handlers"}),"\n",(0,a.jsx)(n.p,{children:"The simplest approach is defining handlers inline with routes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'GET("users" / userId) isHandledBy {\n    userRepository.findById(request[userId])\n        ?.ok\n        ?: "User not found".notFound()\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This works well for simple endpoints with minimal logic."}),"\n",(0,a.jsx)(n.h3,{id:"named-handlers",children:"Named Handlers"}),"\n",(0,a.jsx)(n.p,{children:"For more complex endpoints, you can define named handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val getUser by handling {\n    val id = request[userId]\n    val user = userRepository.findById(id)\n    if (user != null) user.ok\n    else "User not found".notFound()\n}\n\n// In routes\nGET("users" / userId) isHandledBy getUser\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"handling"})," function is defined as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun <T: Any> handling(handler: Handler<T>): HandlerReference<T> =\n    HandlerReference(handler)\n\nclass HandlerReference<T: Any>(val handler: Handler<T>)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This allows handlers to be:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reused across multiple routes"}),"\n",(0,a.jsx)(n.li,{children:"Tested independently"}),"\n",(0,a.jsx)(n.li,{children:"Named for better code organization"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"reusable-handlers",children:"Reusable Handlers"}),"\n",(0,a.jsx)(n.p,{children:"For handlers that need access to request body data, there's a specialized approach:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val createUser by parsing<CreateUserRequest>() handling {\n    // body is the parsed CreateUserRequest\n    val result = userService.createUser(body.name, body.email)\n    CreatedUser(result.id, result.name).created\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"parsing"})," function is:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"inline fun <reified B: Any> parsing(): BodyHandlerBuilder<B> =\n    BodyHandlerBuilder(B::class)\n\nclass BodyHandlerBuilder<B: Any>(private val bodyClass: KClass<B>) {\n    infix fun handling(handler: BodyHandler<B, *>): BodyHandlerReference<B, *> =\n        BodyHandlerReference(handler, bodyClass)\n}\n\ntypealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T\n"})}),"\n",(0,a.jsx)(n.p,{children:"This pattern provides:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Type-safe access to the request body"}),"\n",(0,a.jsx)(n.li,{children:"Automatic body parsing and validation"}),"\n",(0,a.jsx)(n.li,{children:"Clear separation of body handling from other request processing"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"type-safe-parameter-access",children:"Type-Safe Parameter Access"}),"\n",(0,a.jsx)(n.p,{children:"One of Snitch's core strengths is type-safe parameter access. When you define a parameter:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val userId by path(ofLong)\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can access it with the correct type in handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val getUser by handling {\n    val id: Long = request[userId] // Type is Long, not String\n    // ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Behind the scenes, this works through the interaction of:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"Parameter"})," class that captures the validator"]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"get"})," operator on ",(0,a.jsx)(n.code,{children:"RequestWrapper"})," that applies the validator"]}),"\n",(0,a.jsx)(n.li,{children:"Kotlin's type inference that understands the return type"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Let's explore how parameters are implemented:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class Parameter<From, To>(\n    val name: String,\n    val description: String,\n    val validator: Validator<From, To>,\n    val source: ParameterSource,\n    val required: Boolean = true,\n    val default: To? = null,\n    // Additional metadata...\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"When you access a parameter, the framework:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Extracts the raw value from the request based on ",(0,a.jsx)(n.code,{children:"source"})]}),"\n",(0,a.jsxs)(n.li,{children:["Validates and transforms it using ",(0,a.jsx)(n.code,{children:"validator"})]}),"\n",(0,a.jsxs)(n.li,{children:["Falls back to ",(0,a.jsx)(n.code,{children:"default"})," if the parameter is missing and not ",(0,a.jsx)(n.code,{children:"required"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This ensures that by the time your handler code executes, all parameters are valid and properly typed."}),"\n",(0,a.jsx)(n.h2,{id:"body-handling",children:"Body Handling"}),"\n",(0,a.jsx)(n.p,{children:"Request bodies require special treatment due to their potentially complex structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'data class CreateUserRequest(val name: String, val email: String)\n\nval userBody by body<CreateUserRequest>()\n\nPOST("users") with userBody isHandledBy {\n    val request: CreateUserRequest = request[userBody]\n    // Use typed request body\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"body"})," function creates a special parameter that:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Extracts the raw request body from the HTTP request"}),"\n",(0,a.jsx)(n.li,{children:"Uses the configured JSON parser to deserialize it to the target type"}),"\n",(0,a.jsxs)(n.li,{children:["Makes it available via ",(0,a.jsx)(n.code,{children:"request[bodyParam]"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For handlers that need frequent body access, the ",(0,a.jsx)(n.code,{children:"parsing"})," pattern simplifies this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val createUser by parsing<CreateUserRequest>() handling {\n    // Direct access to body without request[bodyParam]\n    val user = userService.createUser(body.name, body.email)\n    // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Under the hood, ",(0,a.jsx)(n.code,{children:"parsing"})," creates a specialized ",(0,a.jsx)(n.code,{children:"BodyRequestWrapper"})," that exposes the parsed body:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"interface BodyRequestWrapper<B> : RequestWrapper {\n    val body: B\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This provides a cleaner API for body-centric handlers."}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-in-handlers",children:"Error Handling in Handlers"}),"\n",(0,a.jsx)(n.p,{children:"Handlers can approach error handling in several ways:"}),"\n",(0,a.jsx)(n.h3,{id:"1-return-explicit-error-responses",children:"1. Return explicit error responses:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val getUser by handling {\n    try {\n        val user = userService.findById(request[userId])\n        if (user != null) user.ok\n        else "User not found".notFound()\n    } catch (e: DatabaseException) {\n        "Database error: ${e.message}".serverError()\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-throw-exceptions-that-are-handled-globally",children:"2. Throw exceptions that are handled globally:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// In application setup\nsnitch(parser)\n    .onRoutes(routes)\n    .handleException(ResourceNotFoundException::class) { ex ->\n        ErrorResponse(ex.message ?: "Resource not found").notFound()\n    }\n    .handleException(DatabaseException::class) { ex ->\n        ErrorResponse("Internal error").serverError()\n    }\n    .start()\n\n// In handler - let exceptions propagate\nval getUser by handling {\n    userService.findById(request[userId])?.ok\n        ?: throw ResourceNotFoundException("User not found")\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The exception handling is implemented by wrapping handler execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"try {\n    handler.invoke(requestWrapper)\n} catch (e: Exception) {\n    // Find appropriate exception handler\n    exceptionHandlers[e::class]?.invoke(e) ?: throw e\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This allows for centralized error handling while keeping handlers focused on the happy path."}),"\n",(0,a.jsx)(n.h2,{id:"asynchronous-handlers",children:"Asynchronous Handlers"}),"\n",(0,a.jsx)(n.p,{children:"Snitch supports asynchronous handlers through coroutines:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val getUser by coHandling {\n    // Suspend function call\n    val user = userRepository.findByIdAsync(request[userId])\n    user?.ok ?: "User not found".notFound()\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"coHandling"})," function is defined as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun <T: Any> coHandling(handler: suspend Handler<T>): CoHandlerReference<T> =\n    CoHandlerReference(handler)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This leverages Kotlin's coroutine support to allow non-blocking execution while maintaining the same expressive handler syntax."}),"\n",(0,a.jsx)(n.h2,{id:"the-handler-execution-pipeline",children:"The Handler Execution Pipeline"}),"\n",(0,a.jsx)(n.p,{children:"When a request is processed, handlers go through a specific execution pipeline:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Validation"}),": All required parameters are validated"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Condition Evaluation"}),": All conditions are checked"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Before Actions"}),": Before actions execute in reverse order"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Decoration Setup"}),": Decorations wrap the handler"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handler Execution"}),": The handler processes the request"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"After Actions"}),": After actions execute in declaration order"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This pipeline ensures that by the time your handler executes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"All parameters are validated and available"}),"\n",(0,a.jsx)(n.li,{children:"All conditions are satisfied"}),"\n",(0,a.jsx)(n.li,{children:"Any pre-processing logic has run"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The handler's result then flows through:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Any transformation logic in decorations"}),"\n",(0,a.jsx)(n.li,{children:"Serialization based on content negotiation"}),"\n",(0,a.jsx)(n.li,{children:"Response status code and header application"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This structured flow keeps handlers focused on business logic while the framework handles HTTP concerns."}),"\n",(0,a.jsx)(n.h2,{id:"testing-handlers",children:"Testing Handlers"}),"\n",(0,a.jsx)(n.p,{children:"Snitch's design makes handler testing straightforward:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'@Test\nfun `getUser returns user when found`() {\n    // Setup mock repository\n    val mockRepo = mockk<UserRepository>()\n    every { mockRepo.findById(1) } returns User(1, "Test User")\n    \n    // Create test request wrapper\n    val request = TestRequestWrapper().apply {\n        // Set up parameter for testing\n        setParameter(userId, 1L)\n    }\n    \n    // Execute handler directly\n    val handler = UserHandlers(mockRepo).getUser.handler\n    val response = handler.invoke(request)\n    \n    // Verify response\n    assertThat(response.statusCode).isEqualTo(StatusCode.OK)\n    assertThat(response.value).isInstanceOf(User::class.java)\n    assertThat((response.value as User).name).isEqualTo("Test User")\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"For more comprehensive testing, Snitch also provides a testing DSL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'@Test\nfun `getUser endpoint returns user when found`() {\n    // Setup mock repository\n    val mockRepo = mockk<UserRepository>()\n    every { mockRepo.findById(1) } returns User(1, "Test User")\n    \n    // Test the endpoint\n    testApp {\n        // Register routes with mock dependencies\n        registerRoutes(userRoutes(mockRepo))\n        \n        // Execute request\n        GET("/users/1")\n            .expectCode(200)\n            .expectJson {\n                it.path("id").asInt() shouldBe 1\n                it.path("name").asText() shouldBe "Test User"\n            }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This approach allows for both unit testing of individual handlers and integration testing of entire endpoints."}),"\n",(0,a.jsx)(n.h2,{id:"handler-implementation-details",children:"Handler Implementation Details"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at some of the key implementation details behind handlers:"}),"\n",(0,a.jsx)(n.h3,{id:"handler-function-types",children:"Handler Function Types"}),"\n",(0,a.jsx)(n.p,{children:"Snitch uses several function types for different handler scenarios:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Basic handler\ntypealias Handler<T> = RequestWrapper.() -> T\n\n// Body handler\ntypealias BodyHandler<B, T> = BodyRequestWrapper<B>.() -> T\n\n// Coroutine handler\ntypealias CoHandler<T> = suspend Handler<T>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"handler-references",children:"Handler References"}),"\n",(0,a.jsx)(n.p,{children:"Handler references wrap handler functions to make them usable with the DSL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class HandlerReference<T: Any>(val handler: Handler<T>)\n\nclass BodyHandlerReference<B: Any, T: Any>(\n    val handler: BodyHandler<B, T>,\n    val bodyClass: KClass<B>\n)\n\nclass CoHandlerReference<T: Any>(val handler: suspend Handler<T>)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"handler-execution",children:"Handler Execution"}),"\n",(0,a.jsx)(n.p,{children:"The endpoint processor executes handlers through a series of steps:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Simplified flow\nfun executeHandler(endpoint: Endpoint<*>, request: Request): Response {\n    // Create request wrapper\n    val wrapper = RequestWrapperImpl(request, parser)\n    \n    // Validate parameters\n    validateParameters(endpoint.parameters, wrapper)\n    \n    // Check conditions\n    evaluateConditions(endpoint.conditions, wrapper)\n    \n    // Execute before actions\n    for (action in endpoint.beforeActions.reversed()) {\n        val earlyResponse = action(wrapper)\n        if (earlyResponse != null) return earlyResponse\n    }\n    \n    // Execute handler with decorations\n    val result = applyDecorations(endpoint.decorations, endpoint.handler!!)(wrapper)\n    \n    // Convert result to response\n    val response = when (result) {\n        is Response -> result\n        else -> Response(result, OK)\n    }\n    \n    // Execute after actions\n    for (action in endpoint.afterActions) {\n        action(wrapper)\n    }\n    \n    return response\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This structured approach ensures consistent request handling while giving handlers access to all the information they need."}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.p,{children:"Based on the inner workings of handlers, here are some best practices:"}),"\n",(0,a.jsx)(n.h3,{id:"1-keep-handlers-focused",children:"1. Keep Handlers Focused"}),"\n",(0,a.jsx)(n.p,{children:"Handlers should focus on their primary responsibility:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Good: Focused on user retrieval\nval getUser by handling {\n    userRepository.findById(request[userId])\n        ?.ok\n        ?: "User not found".notFound()\n}\n\n// Avoid: Mixing concerns\nval getUser by handling {\n    // Authentication logic\n    if (!isAuthenticated()) return "Unauthorized".unauthorized()\n    \n    // Logging\n    logger.info("Getting user ${request[userId]}")\n    \n    // Business logic\n    val user = userRepository.findById(request[userId])\n    \n    // Response creation\n    if (user != null) user.ok\n    else "User not found".notFound()\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Use conditions, decorations, and actions for cross-cutting concerns."}),"\n",(0,a.jsx)(n.h3,{id:"2-leverage-type-safety",children:"2. Leverage Type Safety"}),"\n",(0,a.jsx)(n.p,{children:"Take advantage of Snitch's type safety features:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Define parameters with specific types\nval userId by path(ofLong)\nval userRole by query(ofEnum<UserRole>())\n\n// Use typed parameters in handlers\nval getUser by handling {\n    val id: Long = request[userId]\n    val role: UserRole = request[userRole]\n    // No need for manual parsing or validation\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-use-named-handlers-for-complex-logic",children:"3. Use Named Handlers for Complex Logic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'// Named handler for better organization\nval createUser by parsing<CreateUserRequest>() handling {\n    // Validation\n    if (!isValidEmail(body.email)) {\n        return ValidationError("Invalid email").badRequest()\n    }\n    \n    // Business logic\n    try {\n        val id = userService.createUser(body.name, body.email)\n        CreatedUser(id).created\n    } catch (e: DuplicateUserException) {\n        ValidationError("User already exists").badRequest()\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-structure-error-handling-appropriately",children:"4. Structure Error Handling Appropriately"}),"\n",(0,a.jsx)(n.p,{children:"For application-specific exceptions, use global handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'snitch(parser)\n    .handleException(ResourceNotFoundException::class) { ex ->\n        ErrorResponse(ex.message ?: "Resource not found").notFound()\n    }\n\n// Then throw from handlers\nval getUser by handling {\n    userRepository.findById(request[userId]) \n        ?: throw ResourceNotFoundException("User not found")\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"For business logic validation, return explicit responses:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val createUser by parsing<CreateUserRequest>() handling {\n    if (!isValidEmail(body.email)) {\n        return ValidationError("Invalid email").badRequest()\n    }\n    // Proceed with valid input\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"5-use-coroutines-for-io-bound-operations",children:"5. Use Coroutines for I/O-Bound Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val getUser by coHandling {\n    // Non-blocking database call\n    val user = userRepository.findByIdAsync(request[userId])\n    user?.ok ?: "User not found".notFound()\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"6-group-related-handlers",children:"6. Group Related Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class UserHandlers(private val userRepository: UserRepository) {\n    val getUser by handling {\n        // Implementation\n    }\n    \n    val createUser by parsing<CreateUserRequest>() handling {\n        // Implementation\n    }\n    \n    val updateUser by parsing<UpdateUserRequest>() handling {\n        // Implementation\n    }\n    \n    val deleteUser by handling {\n        // Implementation\n    }\n}\n\n// In routes\nval userHandlers = UserHandlers(userRepository)\n\n"users" / {\n    GET(userId) isHandledBy userHandlers.getUser\n    POST() with userBody isHandledBy userHandlers.createUser\n    PUT(userId) with userBody isHandledBy userHandlers.updateUser\n    DELETE(userId) isHandledBy userHandlers.deleteUser\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This approach:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Groups related functionality"}),"\n",(0,a.jsx)(n.li,{children:"Makes dependency injection straightforward"}),"\n",(0,a.jsx)(n.li,{children:"Improves code organization"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Snitch's Handler DSL provides a powerful, type-safe way to implement API business logic. By understanding its internal workings, you can leverage its full potential to create expressive, maintainable handlers."}),"\n",(0,a.jsx)(n.p,{children:"The combination of type-safe parameter access, flexible response creation, and structured execution pipeline allows you to focus on your business logic while the framework handles HTTP concerns."}),"\n",(0,a.jsx)(n.p,{children:"Whether you're writing simple endpoints or complex business processes, Snitch's Handler DSL offers the tools to express your intent clearly and safely."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var r=s(6540);const a={},t=r.createContext(a);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);