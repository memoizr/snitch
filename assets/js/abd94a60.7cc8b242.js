"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[8172],{3057:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorials/ShankPatterns","title":"Advanced Shank Design Patterns","description":"This document explores powerful design patterns and techniques for using Shank effectively in your applications. While Shank is intuitive and straightforward by design, these patterns can help you tackle more complex scenarios with elegance and maintainability.","source":"@site/docs/tutorials/ShankPatterns.md","sourceDirName":"tutorials","slug":"/tutorials/ShankPatterns","permalink":"/docs/tutorials/ShankPatterns","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/ShankPatterns.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Shank in Action: Building a Real-World Application","permalink":"/docs/tutorials/ShankInAction"},"next":{"title":"Using Shank with Snitch","permalink":"/docs/tutorials/UsingShank"}}');var t=a(4848),o=a(8453);const r={},s="Advanced Shank Design Patterns",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Module Organization Strategies",id:"module-organization-strategies",level:2},{value:"Domain Module Pattern",id:"domain-module-pattern",level:3},{value:"Feature Module Pattern",id:"feature-module-pattern",level:3},{value:"Dependency Layering",id:"dependency-layering",level:2},{value:"Testing Patterns",id:"testing-patterns",level:2},{value:"Test Double Pattern",id:"test-double-pattern",level:3},{value:"Component Testing Pattern",id:"component-testing-pattern",level:3},{value:"Domain-Driven Design with Shank",id:"domain-driven-design-with-shank",level:2},{value:"Feature Toggling",id:"feature-toggling",level:2},{value:"Lifecycle Management",id:"lifecycle-management",level:2},{value:"Configuration Injection",id:"configuration-injection",level:2},{value:"Conditional Dependencies",id:"conditional-dependencies",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"advanced-shank-design-patterns",children:"Advanced Shank Design Patterns"})}),"\n",(0,t.jsx)(n.p,{children:"This document explores powerful design patterns and techniques for using Shank effectively in your applications. While Shank is intuitive and straightforward by design, these patterns can help you tackle more complex scenarios with elegance and maintainability."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#module-organization-strategies",children:"Module Organization Strategies"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#dependency-layering",children:"Dependency Layering"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#testing-patterns",children:"Testing Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#domain-driven-design-with-shank",children:"Domain-Driven Design with Shank"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#feature-toggling",children:"Feature Toggling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#lifecycle-management",children:"Lifecycle Management"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#configuration-injection",children:"Configuration Injection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#conditional-dependencies",children:"Conditional Dependencies"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"module-organization-strategies",children:"Module Organization Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"domain-module-pattern",children:"Domain Module Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Organize your modules by domain context rather than technical layers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Instead of "RepositoryModule", "ServiceModule", etc.\nobject UserDomainModule : ShankModule {\n    // Domain-specific repositories\n    val userRepository = single<UserRepository> { -> UserRepositoryImpl() }\n    \n    // Domain-specific services\n    val userService = single<UserService> { -> UserServiceImpl(userRepository()) }\n    \n    // Domain-specific validation\n    val userValidator = single { -> UserValidator() }\n}\n\nobject PaymentDomainModule : ShankModule {\n    val paymentRepository = single<PaymentRepository> { -> PaymentRepositoryImpl() }\n    val paymentService = single<PaymentService> { -> PaymentServiceImpl(paymentRepository()) }\n    val paymentProcessor = single { -> PaymentProcessor() }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This approach aligns better with domain-driven design principles and improves cohesion, making each module more focused and self-contained."}),"\n",(0,t.jsx)(n.h3,{id:"feature-module-pattern",children:"Feature Module Pattern"}),"\n",(0,t.jsx)(n.p,{children:"For larger applications, organize modules by features that cut across domain boundaries:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"object AuthenticationModule : ShankModule {\n    val passwordEncoder = single { -> BCryptPasswordEncoder() }\n    val tokenService = single { -> JwtTokenService() }\n    val authenticationService = single { -> \n        AuthenticationServiceImpl(\n            UserDomainModule.userRepository(),\n            passwordEncoder(),\n            tokenService()\n        )\n    }\n}\n\nobject CheckoutModule : ShankModule {\n    val checkoutService = single { -> \n        CheckoutServiceImpl(\n            UserDomainModule.userService(),\n            PaymentDomainModule.paymentService(),\n            ShippingDomainModule.shippingService()\n        ) \n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This pattern maximizes code organization around user-facing features, making it clear which dependencies belong to which features."}),"\n",(0,t.jsx)(n.h2,{id:"dependency-layering",children:"Dependency Layering"}),"\n",(0,t.jsx)(n.p,{children:"Shank allows you to create clear architectural boundaries while maintaining explicit dependency relationships:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Infrastructure Layer\nobject InfrastructureModule : ShankModule {\n    val database = single { -> PostgresDatabase(connectionString()) }\n    val httpClient = single { -> OkHttpClient() }\n    val cache = single { -> RedisCache(redisConfig()) }\n}\n\n// Repository Layer\nobject RepositoryModule : ShankModule {\n    val userRepository = single<UserRepository> { -> \n        UserRepositoryImpl(InfrastructureModule.database())\n    }\n}\n\n// Service Layer\nobject ServiceModule : ShankModule {\n    val userService = single<UserService> { -> \n        UserServiceImpl(RepositoryModule.userRepository())\n    }\n}\n\n// Application Layer\nobject ApplicationModule : ShankModule {\n    val userController = single { -> \n        UserController(ServiceModule.userService())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This approach enforces the dependency rule (dependencies only point inward) while maintaining Shank's explicit dependency tracing."}),"\n",(0,t.jsx)(n.h2,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"test-double-pattern",children:"Test Double Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Create specialized modules for testing that override production dependencies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Production module\nobject PaymentModule : ShankModule {\n    val paymentGateway = single<PaymentGateway> { -> StripePaymentGateway() }\n    val paymentService = single { -> PaymentServiceImpl(paymentGateway()) }\n}\n\n// Test module\nobject TestPaymentModule : ShankModule {\n    val mockPaymentGateway = single<PaymentGateway> { -> MockPaymentGateway() }\n    \n    fun setupForTesting() {\n        // Override the real implementation with our mock\n        PaymentModule.paymentGateway.overrideFactory { -> mockPaymentGateway() }\n    }\n    \n    fun tearDown() {\n        // Restore the original implementation\n        PaymentModule.paymentGateway.restore()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then in your tests:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'class PaymentServiceTest {\n    @BeforeEach\n    fun setup() {\n        TestPaymentModule.setupForTesting()\n    }\n    \n    @AfterEach\n    fun tearDown() {\n        TestPaymentModule.tearDown()\n    }\n    \n    @Test\n    fun `test payment processing`() {\n        // This will use the mock gateway\n        val paymentService = PaymentModule.paymentService()\n        \n        // Configure the mock\n        val mockGateway = TestPaymentModule.mockPaymentGateway()\n        mockGateway.setupToReturnSuccessfulPayment()\n        \n        // Execute the test\n        val result = paymentService.processPayment(100.0, "USD")\n        \n        // Verify the result\n        assertEquals(PaymentStatus.SUCCESS, result.status)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This approach provides fine-grained control over which dependencies are mocked in tests while preserving the rest of the dependency tree."}),"\n",(0,t.jsx)(n.h3,{id:"component-testing-pattern",children:"Component Testing Pattern"}),"\n",(0,t.jsx)(n.p,{children:"For integration/component testing, create specialized test configurations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"object TestDatabaseModule : ShankModule {\n    val inMemoryDatabase = single { -> H2Database() }\n    \n    fun setupTestEnvironment() {\n        // Override production database with in-memory version\n        InfrastructureModule.database.overrideFactory { -> inMemoryDatabase() }\n    }\n}\n\nobject IntegrationTestModule : ShankModule {\n    val testHelper = single { -> IntegrationTestHelper() }\n    \n    fun prepareIntegrationTest() {\n        TestDatabaseModule.setupTestEnvironment()\n        // Additional test setup...\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"domain-driven-design-with-shank",children:"Domain-Driven Design with Shank"}),"\n",(0,t.jsx)(n.p,{children:"Shank works beautifully with Domain-Driven Design (DDD) principles:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Domain layer - contains pure domain logic\nobject DomainModule : ShankModule {\n    val userFactory = single { -> UserFactory() }\n    val paymentPolicy = single { -> BusinessPaymentPolicy() }\n}\n\n// Application layer - orchestrates use cases\nobject ApplicationModule : ShankModule {\n    val createUserUseCase = single { -> \n        CreateUserUseCase(\n            DomainModule.userFactory(),\n            RepositoryModule.userRepository()\n        )\n    }\n    \n    val processPaymentUseCase = single { -> \n        ProcessPaymentUseCase(\n            DomainModule.paymentPolicy(),\n            RepositoryModule.paymentRepository()\n        )\n    }\n}\n\n// Infrastructure layer - provides implementations\nobject InfrastructureModule : ShankModule {\n    val userRepositoryImpl = single<UserRepository> { -> \n        PostgresUserRepository(DatabaseModule.database())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This structure helps maintain a clean domain model while keeping infrastructure concerns separate. The domain module doesn't depend on any external modules, preserving the domain's purity."}),"\n",(0,t.jsx)(n.h2,{id:"feature-toggling",children:"Feature Toggling"}),"\n",(0,t.jsx)(n.p,{children:"Implement feature toggling with Shank:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'object FeatureToggleModule : ShankModule {\n    val featureManager = single { -> FeatureManager() }\n    \n    // Define toggleable implementations\n    val paymentProcessor = single<PaymentProcessor> { ->\n        val featureManager = featureManager()\n        if (featureManager.isEnabled("new-payment-processor")) {\n            NewPaymentProcessor()\n        } else {\n            LegacyPaymentProcessor()\n        }\n    }\n    \n    // Conditionally provide implementations\n    val betaFeatures = single { -> \n        val featureManager = featureManager()\n        if (featureManager.isEnabled("beta-features")) {\n            BetaFeaturesImpl() \n        } else {\n            EmptyBetaFeatures()\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This pattern allows you to toggle features at runtime while maintaining Shank's type safety and explicit dependency structure."}),"\n",(0,t.jsx)(n.h2,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,t.jsx)(n.p,{children:"For dependencies that need initialization or cleanup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"object ResourceModule : ShankModule {\n    val databaseClient = single { -> \n        DatabaseClient().also { client ->\n            // Register shutdown hook\n            Runtime.getRuntime().addShutdownHook(Thread {\n                client.close()\n            })\n        }\n    }\n    \n    // Auto-closeable resources\n    val httpClient = single { -> \n        OkHttpClient().also { client ->\n            registerForCleanup(client)\n        }\n    }\n    \n    // Track resources that need to be closed\n    private val managedResources = mutableListOf<AutoCloseable>()\n    \n    private fun registerForCleanup(resource: AutoCloseable) {\n        managedResources.add(resource)\n    }\n    \n    fun closeAll() {\n        managedResources.forEach { it.close() }\n        managedResources.clear()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"To use in your application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    try {\n        // Use your application...\n        val app = startApplication()\n        app.waitForShutdown()\n    } finally {\n        ResourceModule.closeAll()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-injection",children:"Configuration Injection"}),"\n",(0,t.jsx)(n.p,{children:"Manage configuration values through Shank modules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'object ConfigModule : ShankModule {\n    val config = single { -> \n        ConfigFactory.load() \n    }\n    \n    val databaseConfig = single { -> \n        val config = config()\n        DatabaseConfig(\n            url = config.getString("db.url"),\n            username = config.getString("db.username"),\n            password = config.getString("db.password")\n        )\n    }\n    \n    val apiConfig = single { -> \n        val config = config()\n        ApiConfig(\n            baseUrl = config.getString("api.baseUrl"),\n            timeout = config.getDuration("api.timeout")\n        )\n    }\n}\n\n// Usage in other modules\nobject DatabaseModule : ShankModule {\n    val database = single { -> \n        val config = ConfigModule.databaseConfig()\n        Database.connect(\n            url = config.url,\n            username = config.username,\n            password = config.password\n        )\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This pattern centralizes configuration while maintaining type safety."}),"\n",(0,t.jsx)(n.h2,{id:"conditional-dependencies",children:"Conditional Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"Provide different implementations based on environment or other conditions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"object NotificationModule : ShankModule {\n    val emailSender = single<EmailSender> { ->\n        when (Environment.current) {\n            Environment.PRODUCTION -> SmtpEmailSender(ConfigModule.emailConfig())\n            Environment.STAGING -> SmtpEmailSender(ConfigModule.emailConfig())\n            Environment.DEVELOPMENT -> ConsoleEmailSender()\n            Environment.TEST -> NoOpEmailSender()\n        }\n    }\n    \n    val pushNotificationService = single<PushNotificationService> { ->\n        if (Environment.isProduction()) {\n            FirebasePushService(ConfigModule.firebaseConfig())\n        } else {\n            LoggingPushService()\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This approach provides environment-specific implementations while maintaining the same dependency interface."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"These patterns demonstrate Shank's flexibility and power in handling complex dependency scenarios while maintaining its core advantages of explicitness, type safety, and performance. By applying these patterns, you can build well-structured, maintainable applications that scale with your needs."}),"\n",(0,t.jsx)(n.p,{children:"Shank's design philosophy emphasizes clarity and explicitness, making it not just a technical tool but a design aid that helps you think more clearly about your application's structure and dependencies."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>s});var i=a(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);