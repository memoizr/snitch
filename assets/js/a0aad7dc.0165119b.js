"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[5722],{6331:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Docs","title":"Snitch","description":"Introduction","source":"@site/docs/Docs.md","sourceDirName":".","slug":"/Docs","permalink":"/docs/Docs","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/Docs.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"Kotlin\'s Most Elegant HTTP Framework","permalink":"/docs/What is Snitch"}}');var i=t(4848),a=t(8453);const o={},r="Snitch",l={},d=[{value:"Introduction",id:"introduction",level:3},{value:"Features",id:"features",level:4},{value:"Getting started",id:"getting-started",level:3},{value:"Router",id:"router",level:3},{value:"Routing basics",id:"routing-basics",level:4},{value:"Route Nesting",id:"route-nesting",level:4},{value:"HTTP input parameters",id:"http-input-parameters",level:4},{value:"Input parameter validation and transformation",id:"input-parameter-validation-and-transformation",level:4},{value:"Custom validations",id:"custom-validations",level:4},{value:"Optional input parameters",id:"optional-input-parameters",level:4},{value:"Parameter naming",id:"parameter-naming",level:4},{value:"Unsafe, undocumented parameter parsing",id:"unsafe-undocumented-parameter-parsing",level:4},{value:"Repeated parameters",id:"repeated-parameters",level:4},{value:"Body parameter",id:"body-parameter",level:4},{value:"Middleware",id:"middleware",level:3},{value:"Order of execution",id:"order-of-execution",level:4},{value:"Security and access control",id:"security-and-access-control",level:3},{value:"Dependency Injection with Shank",id:"dependency-injection-with-shank",level:3},{value:"Setting Up Shank Modules",id:"setting-up-shank-modules",level:4},{value:"Using Dependencies in Handlers",id:"using-dependencies-in-handlers",level:4},{value:"Creating Middleware with Dependency Injection",id:"creating-middleware-with-dependency-injection",level:4},{value:"Database Integration",id:"database-integration",level:3},{value:"Guards",id:"guards",level:3},{value:"Composing conditions",id:"composing-conditions",level:4},{value:"Reusing conditions",id:"reusing-conditions",level:4},{value:"Error handling",id:"error-handling",level:3},{value:"Polymorphic error handling",id:"polymorphic-error-handling",level:4},{value:"Testing",id:"testing",level:3},{value:"Intellij integration",id:"intellij-integration",level:3},{value:"Showcase",id:"showcase",level:3},{value:"DSL extension usecase: API versioning",id:"dsl-extension-usecase-api-versioning",level:4},{value:"Coroutine support",id:"coroutine-support",level:3},{value:"FAQ",id:"faq",level:3},{value:"How does Snitch handle concurrency?",id:"how-does-snitch-handle-concurrency",level:4},{value:"Just how &quot;light&quot; and &quot;fast&quot; is Snitch?",id:"just-how-light-and-fast-is-snitch",level:4},{value:"How does the automatic OpenApi 3 documentation generation work?",id:"how-does-the-automatic-openapi-3-documentation-generation-work",level:4},{value:"Why is Snitch typesafe?",id:"why-is-snitch-typesafe",level:4},{value:"How does Snitch handle HTTP sessions and cookies?",id:"how-does-snitch-handle-http-sessions-and-cookies",level:4},{value:"Does Snitch support X database integration?",id:"does-snitch-support-x-database-integration",level:4},{value:"How does Snitch handle scalability?",id:"how-does-snitch-handle-scalability",level:4},{value:"How does Snitch handle security, particularly in terms of input validation?",id:"how-does-snitch-handle-security-particularly-in-terms-of-input-validation",level:4},{value:"How does Snitch compare to other Kotlin web frameworks like Ktor or Spring Boot in terms of performance and ease of use?",id:"how-does-snitch-compare-to-other-kotlin-web-frameworks-like-ktor-or-spring-boot-in-terms-of-performance-and-ease-of-use",level:4}];function c(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"snitch",children:"Snitch"})}),"\n",(0,i.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Snitch is a small and typesafe web framework for Kotlin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    snitch(GsonJsonParser).onRoutes {\n        GET("hello") isHandledBy { "world".ok }\n    }.start()\n} \n'})}),"\n",(0,i.jsx)(n.h4,{id:"features",children:"Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lightweight and fast."}),"\n",(0,i.jsx)(n.li,{children:"Functional approach"}),"\n",(0,i.jsx)(n.li,{children:"OpenAPI 3 support"}),"\n",(0,i.jsx)(n.li,{children:"Fully asynchronous execution"}),"\n",(0,i.jsx)(n.li,{children:"Plain Kotlin. No reflection, code generation, annotation processing."}),"\n",(0,i.jsx)(n.li,{children:"Kotlin compiler is enough. No Gradle plugins"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"getting-started",children:"Getting started"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Kotlin",children:'dependencies {\n    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"That's it, no need for command line tools, gradle plugins. It's just a simple library."}),"\n",(0,i.jsx)(n.h3,{id:"router",children:"Router"}),"\n",(0,i.jsx)(n.h4,{id:"routing-basics",children:"Routing basics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    GET("foo") isHandledBy {\n        "bar".ok\n    }\n    POST("foo") with body<FooRequest>() isHandledBy {\n        "fooValue: ${body.fooValue}".created\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The infix style is optional and a classic fluent approach is also supported."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    GET("foo").isHandledBy {\n        "bar".ok\n    }\n    POST("foo")\n        .with(body<FooRequest>())\n        .isHandledBy {\n        "fooValue: ${body.fooValue}".created\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:'GET("/foo")'})," and ",(0,i.jsx)(n.code,{children:'GET("foo")'})," are the same thing"]}),"\n",(0,i.jsxs)(n.p,{children:["You pass the router to the ",(0,i.jsx)(n.code,{children:"onRoutes"})," function"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    snitch(GsonJsonParser).onRoutes(root).start()\n} \n"})}),"\n",(0,i.jsx)(n.p,{children:"Of course in a real application you'd like to separate the route declarations from the endpoint implementations."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    GET("foo") isHandledBy getFoo\n    POST("foo") with body<FooRequest>() isHandledBy postFoo\n}\n\nval getFoo by handling {\n    "bar".ok\n}\n\nval postFoo by parsing<FooRequest>() handling {\n    "fooValue: ${body.fooValue}".created\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"route-nesting",children:"Route Nesting"}),"\n",(0,i.jsx)(n.p,{children:"Services often have hundreds of routes, organized hierarchically. This can be modeled in Snitch:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    "health" / healthController\n    "users" / usersController\n    "posts" / postsController\n    ...\n}\n\nval usersController = routes {\n    POST() with body<CreateUserRequest> isHandledBy createUser\n    \n    userId / {\n        GET() isHandledBy getUser\n        DELETE() isHandledBy deleteUser\n        \n        "posts" / {\n            GET() isHandledBy getPosts\n            POST() with body<CreatePostRequest> isHandledBy createPost\n            postId / {\n                GET() isHandledBy getPost\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This will define the following routes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"POST users\nGET users/{userId}\nDELETE users/{userId}\nGET users/{userId}/posts\nPOST users/{userId}/posts\nGET users/{userId}/posts/{postId}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Different teams however will have different styles that they endorse, so for those who would rather have a less DRY but more explicit route declaration, they can define the routes as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    healthController\n    usersController\n    postsController\n    ...\n}\nval usersController = routes {\n    POST("users") with body<CreateUserRequest> isHandledBy createUser\n    \n    GET("users" / userId) isHandledBy getUser\n    DELETE("users" / userId) isHandledBy deleteUser\n\n    GET("users" / userId / "posts") isHandledBy getPosts\n    POST("users" / userId / "posts") with body<CreatePostRequest> isHandledBy createPost\n    GET("users" / userId / "posts" / postId) isHandledBy getPost\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The DSL is flexible so for teams that would like a measured and hybrid approach they can define the routes howerver they wish. For example grouping by path for all the actions supported on it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val root = routes {\n    healthController\n    usersController\n    postsController\n    ...\n}\nval usersController = routes {\n    "users" / {\n        POST() with body<CreateUserRequest> isHandledBy createUser\n    }\n    "users" / userId / {\n        GET() isHandledBy getUser\n        DELETE() isHandledBy deleteUser\n    }\n\n    "users" / userId / "posts" / {\n        GET() isHandledBy getPosts\n        POST() with body<CreatePostRequest> isHandledBy createPost\n    }\n\n    "users" / userId / "posts" / postId / {\n        GET() isHandledBy getPost\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"http-input-parameters",children:"HTTP input parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val userId by path()\nval showDetails by query(ofBoolean)\n\nval root = routes {\n    GET("users" / userId / "profile")\n        .with(showDetails)\n        .isHandledBy {\n            val user = UserId(request[userId])\n            if (request[showDetails]) {\n                usersRepository().profileDetails(user)\n            } else {\n                usersRepository().profileSummary(user)\n            }.ok\n        }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"userId"})," and ",(0,i.jsx)(n.code,{children:"showDetails"})," are typed and validated. ",(0,i.jsx)(n.code,{children:"request[showDetails]"})," will return a ",(0,i.jsx)(n.code,{children:"Boolean"})," and ",(0,i.jsx)(n.code,{children:"request[userId]"})," will return a ",(0,i.jsx)(n.code,{children:"String"}),". If you don't pass a ",(0,i.jsx)(n.code,{children:"Validator"})," such as ",(0,i.jsx)(n.code,{children:"ofBoolean"}),", it defaults to ",(0,i.jsx)(n.code,{children:"ofNonEmptyString"}),".",(0,i.jsx)(n.br,{}),"\n","Note: you have to declare the usage of a certain parameter in order to use it."]}),"\n",(0,i.jsx)(n.h4,{id:"input-parameter-validation-and-transformation",children:"Input parameter validation and transformation"}),"\n",(0,i.jsx)(n.p,{children:"All parameters are validated and transformed to another type by default. Here's some more examples, let's add the type parameters explicitly so it's clear what's happening:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Kotlin",children:"val userId: String by path(nonEmptyString)  \nval filters: Set<String> by path(ofNonEmptySet)\nval showDetails: Boolean by path(ofBoolean)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"custom-validations",children:"Custom validations"}),"\n",(0,i.jsxs)(n.p,{children:["Although there are a few built in validator-transformers, they offer a relatively weak typing. Best practice involves transforming and validating raw platform types into domain types. For example a ",(0,i.jsx)(n.code,{children:"userId"})," is rarely actually just a string, for example it's unlikely the content of ",(0,i.jsx)(n.code,{children:"Shakespeare.txt"})," parsed as string could possibly be a valid ID for a user. You most likely have a ",(0,i.jsx)(n.code,{children:"value class UserId"})," defined somewhere. Likewise, a search filter is usually something like an ",(0,i.jsx)(n.code,{children:"Enum"})," where you have a set of pre-determined filter values."]}),"\n",(0,i.jsx)(n.p,{children:"Defining custom validator-transformers in snitch is simple:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"value class UserId(val id: UUID)\nenum class Filter { EXPIRED, ACTIVE, CANCELLED, PENDING }\n\nval ofUserId = validator<String, UserId> { UserId(UUID.fromString(it)) }\n\n// explicit types can be omitted for conciseness, here included for illustrative purposes\nval userId: UserId by path(ofUserId)\nval filters: Collection<Filter> by query(ofRepeatableEnum<Filter>())\nval filter: Filter by query(ofEnum<Filter>())\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Note:"})," Snitch is optimized for production code use cases, and in the spirit of Kotlin, it ",(0,i.jsx)(n.em,{children:"enforces"})," best practices. In production, you almost always need to validate and transfrom inputs consistently. Snitch lets you do this in only one line of code in most cases, leading to a more concise, explicit and consistent codebase, making it easier to maintain larger codebases and for new developers to quickly become productive."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"optional-input-parameters",children:"Optional input parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Declaring a parameter with ",(0,i.jsx)(n.code,{children:"query"})," or ",(0,i.jsx)(n.code,{children:"header"})," will make it required. If the parameter is not supplied a ",(0,i.jsx)(n.code,{children:"400"})," message will be returned specifying that that particular parameter was expected but not provided, as well as any other parameter that also does not pass validation. Optional parameters can be declared as such:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// request[sort] is nullable\nval sort: Sorting? by optionalQuery(ofEnum<Sorting>())\n"})}),"\n",(0,i.jsx)(n.p,{children:"The optionality functionality is quite powerful, offering a clear and consistent way of specifying default values as well as defining a behaviour for when these values are provided as empty as or as invalid inputs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// request[sort] is not nullable, NEW is the default value\nval sort: Sorting by optionalQuery(ofEnum<Sorting>(), default = NEW)\n\nval limit: Int by optionalQuery(ofNonNegativeInt, default = 20, emptyAsMissing = true, invalidAsMissing = true)\nval offset: Int by optionalQuery(ofNonNegativeInt, default = 0, emptyAsMissing = true, invalidAsMissing = true)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"parameter-naming",children:"Parameter naming"}),"\n",(0,i.jsxs)(n.p,{children:["Snitch aims at being as concise and as less verbose as possible while delivering a full feature set for production use-cases. In this spirit when you define an input parameter such as ",(0,i.jsx)(n.code,{children:"val q by query()"})," it will create a named query parameter that should be supplied as such for example:",(0,i.jsx)(n.code,{children:"?q=urlencodedquery"}),". Note that the name of the parameter ",(0,i.jsx)(n.code,{children:"val"})," in the codebase is by default the same name as in the API. If you want it to be different, it's simple:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val searchQuery by query(name = "searchQuery")\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"limit"})," and ",(0,i.jsx)(n.code,{children:"offset"}),' here are defined so that if these parameters were not provided, or provided incorrectly, a default value would be provided instead. This is in case a "fail quietly" behaviour is desired. By default, a ',(0,i.jsx)(n.code,{children:"fail explicitly"})," behaviour is supported, so empty or invalid inputs will return a 400 to inform the API user they're probably doing something wrong."]}),"\n",(0,i.jsx)(n.h4,{id:"unsafe-undocumented-parameter-parsing",children:"Unsafe, undocumented parameter parsing"}),"\n",(0,i.jsxs)(n.p,{children:["While Snitch ",(0,i.jsx)(n.em,{children:"enforces"})," best practices, leading to a less verbose and more consistent codebase that implements them, it also supports an ",(0,i.jsx)(n.em,{children:"unsafe"})," traditional approach. If you want to access a parameter sneakily, and you don't care for the parameter to be included in the documentation, you can do it very simply with the cowboy-friendly syntax:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val getCows by handling {\n    ...\n    request.queryParams("numberOfCows")\n    request.headerParams("ranch")\n    request.pathParams("ranchId")\n    ...\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Although this approach is supported for niche use cases, it is strongly discouraged that this be used for most production applications unless there is a good reason for it."}),"\n",(0,i.jsx)(n.h4,{id:"repeated-parameters",children:"Repeated parameters"}),"\n",(0,i.jsxs)(n.p,{children:["In HTTP one of the hidden challenges to creating a robust and production grade API is that of handling the edge case of query or header parameters provided repeatedly when exactly one or at most one is expected. By default ",(0,i.jsx)(n.code,{children:"val searchQuery by query()"})," expects exactly one value being provided and ",(0,i.jsx)(n.code,{children:"val searchQuery by optionalQuery()"})," provides at most one semantics, unexpected repetition will result in 400. Support for repeated parameters can be made explicity by using ",(0,i.jsx)(n.code,{children:"... by query(ofStringSet)"})," for example, which uses a repeatable validator. Custom validator for repeatable can be created in a very similar way to non-repeatable validators:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val ofUserId = repeatableValidator<String, UserId> { UserId(UUID.fromString(it)) }\n"})}),"\n",(0,i.jsx)(n.h4,{id:"body-parameter",children:"Body parameter"}),"\n",(0,i.jsxs)(n.p,{children:["Body parameters are treated differently than other input parameters as they are used in different ways. While it's common to share the same query parameters or headers between several endpoints (for example consider ",(0,i.jsx)(n.code,{children:"limit"}),", ",(0,i.jsx)(n.code,{children:"offset"}),", ",(0,i.jsx)(n.code,{children:"orderBy"}),", ",(0,i.jsx)(n.code,{children:"Access-Token"})," and so on), body parameters are often single use. Snitch aims at encouraging best  practices while reducing verbosity and clutter as much as possible, and in that spirit body parameter types are declared very simply:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'POST("mypath") with body<MyRequest>() isHandleBy {\n    // already parsed to MyRequest domain type\n    request.body\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This approach is typesafe, so if you were to omit the declaration of the body type, it would not be possible for you to access it within the handler:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'POST("mypath") isHandleBy {\n    // this resolves to Kotlin\'s Nothing special type and would not compile\n    request.body\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Binary path can also be supported inituitively by: ",(0,i.jsx)(n.code,{children:"with(body<ByteArray>())"})]}),"\n",(0,i.jsx)(n.h3,{id:"middleware",children:"Middleware"}),"\n",(0,i.jsx)(n.p,{children:"Snitch supports a very powerful and flexible middleware mechanism that can be used to implement a wide variety of features. Let's see how you can use it to create a simple logging behaviour applied to a route hierarchy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val Router.log get() = decorateWith {\n    logger().info("Begin Request: ${request.method.name} ${request.path}")\n    next().also {\n        logger().info("End Request: ${request.method.name} ${request.path} ${it.statusCode.code} ${it.value(parser)}")\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["here ",(0,i.jsx)(n.code,{children:"log"})," is a custom defined middleware logging behaviour. Its usage is very intuitive, and it's clear that such behaviour should be applied to any route defined within its block. Defining a new middleware is as straightforward as possible, here's the identity middleware, that simply calls the next action:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val Router.identity get() = decorateWith { next() }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["the code block provided to ",(0,i.jsx)(n.code,{children:"decorateWith"})," works similarly to the way handlers work, you can still access the request parameter in the same way with ",(0,i.jsx)(n.code,{children:"request[myParam]"})," and can return responses with ",(0,i.jsx)(n.code,{children:"ok"})," ",(0,i.jsx)(n.code,{children:"created"})," ",(0,i.jsx)(n.code,{children:"badRequest()"})," etc like in normal handlers."]}),"\n",(0,i.jsxs)(n.p,{children:["Calling ",(0,i.jsx)(n.code,{children:"next()"})," executes the code in the block of any nested middleware until it gets to the code block of the handler. ",(0,i.jsx)(n.code,{children:"next()"})," returns the response from the next layer of the middleware and as such it can be transformed as appropriate."]}),"\n",(0,i.jsx)(n.h4,{id:"order-of-execution",children:"Order of execution"}),"\n",(0,i.jsxs)(n.p,{children:["The order of execution, that is, what code is executed by the ",(0,i.jsx)(n.code,{children:"next()"})," call, is dependent on the order of declaration. It works as your intuition would expect, inside out, from most nested to least nested:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"//called second\nlog {\n    // called first\n    statistics {\n        GET() ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"security-and-access-control",children:"Security and access control"}),"\n",(0,i.jsx)(n.p,{children:"middleware allows for the implementation of powerful and granular access control systems. Here's a realistic example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val Router.authenticated\n    get() = transformEndpoints {\n        with(listof(accessToken)).decorate {\n            when (request[accessToken]) {\n                is Authentication.Authenticated -> next()\n                is Authentication.Unauthenticated -> UNAUTHORIZED()\n            }\n        }\n    }\n\nval accessToken: Authentication by header(validAccesstoken)\n\nval validAccesstoken = validator<String, Authentication> { jwt().validate(it) }\n\nsealed interface Authentication {\n    data class Authenticated(val claims: JwtClaims) : Authentication\n    interface Unauthenticated : Authentication\n    object InvalidToken : Unauthenticated\n    object ExpiredToken : Unauthenticated\n    object MissingToken : Unauthenticated\n    object InvalidClaims : Unauthenticated\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"and this is how this is used:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'authenticated {\n        ...\n        GET(userId / "posts") isHandledBy getPosts\n        ...\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"now, there's a lot to unpack in a few lines of code, let's break it down:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val Router.authenticated\n    get() = decorateEndpoints {\n        withHeader(accessToken).decorate {\n            when (request[accessToken]) {\n                is Authentication.Authenticated -> next()\n                is Authentication.Unauthenticated -> UNAUTHORIZED()\n            }\n        }\n    }\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"decorateEndpoints"})," will apply whatever transformation inside the block to any endpoint to which this will be applied. ",(0,i.jsx)(n.code,{children:"withHeader(accessToken)"})," is declaring and adding the ",(0,i.jsx)(n.code,{children:"accessToken"})," header parameter to the endpoints, documentation will reflect that. ",(0,i.jsx)(n.code,{children:"request[accessToken]"})," parses, validates and transforms the access token provided in the headers. It returns a domain type, and we can proceed to the next layer of middleware in case the token is valid, and return a 401 error in case it is not."]}),"\n",(0,i.jsx)(n.h3,{id:"dependency-injection-with-shank",children:"Dependency Injection with Shank"}),"\n",(0,i.jsxs)(n.p,{children:["Snitch integrates seamlessly with ",(0,i.jsx)(n.a,{href:"/docs/tutorials/UsingShank",children:"Shank"}),", the highest-performing dependency injection library available for the JVM. Shank provides best-in-class performance with strictly type-safe dependency management, built-in cycle detection, and zero reflection overhead - all in a lightweight 300kb package."]}),"\n",(0,i.jsx)(n.h4,{id:"setting-up-shank-modules",children:"Setting Up Shank Modules"}),"\n",(0,i.jsx)(n.p,{children:"Organize your dependencies by creating modules:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import snitch.shank.ShankModule\nimport snitch.shank.single\nimport snitch.shank.new\n\n// Application-wide dependencies\nobject ApplicationModule : ShankModule {\n    val clock = single { -> Clock.systemUTC() }\n    val logger = single { -> LoggerImpl() }\n    val now = new { -> Instant.now(clock()) }\n}\n\n// Database-related dependencies\nobject DatabaseModule : ShankModule {\n    val connection = single { ->\n        Database.connect(\n            "jdbc:postgresql://localhost:5432/postgres",\n            driver = "org.postgresql.Driver",\n            user = "postgres",\n            password = "postgres"\n        )\n    }\n    \n    val database = single { -> PostgresDatabase(connection()) }\n}\n\n// Repository dependencies\nobject RepositoryModule : ShankModule {\n    val usersRepository = single<UsersRepository> { -> PostgresUsersRepository() }\n    val postsRepository = single<PostsRepository> { -> PostgresPostsRepository() }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"using-dependencies-in-handlers",children:"Using Dependencies in Handlers"}),"\n",(0,i.jsx)(n.p,{children:"Inject dependencies into your handlers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val getUsers by handling {\n    val logger = ApplicationModule.logger()\n    val usersRepo = RepositoryModule.usersRepository()\n    \n    logger.info("Fetching all users")\n    usersRepo.getUsers().ok\n}\n\nval createUser by parsing<CreateUserRequest>() handling {\n    val usersRepo = RepositoryModule.usersRepository()\n    usersRepo.createUser(body.name, body.email).created\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"creating-middleware-with-dependency-injection",children:"Creating Middleware with Dependency Injection"}),"\n",(0,i.jsx)(n.p,{children:"Combine middleware with dependency injection for powerful patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val Router.withLogging get() = decorateWith {\n    val logger = ApplicationModule.logger()\n    logger.info("Request: ${request.method} ${request.path}")\n    next().also {\n        logger.info("Response: ${it.statusCode}")\n    }\n}\n\nval Router.withTransaction get() = decorateWith {\n    val db = DatabaseModule.database()\n    db.transaction {\n        next()\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then use these in your routes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'routes {\n    withLogging {\n        withTransaction {\n            "users" / {\n                GET() isHandledBy getUsers\n                POST() with body<CreateUserRequest>() isHandledBy createUser\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For a comprehensive guide to using Shank with Snitch, see the ",(0,i.jsx)(n.a,{href:"/docs/tutorials/UsingShank",children:"Using Shank with Snitch"})," guide."]}),"\n",(0,i.jsx)(n.h3,{id:"database-integration",children:"Database Integration"}),"\n",(0,i.jsxs)(n.p,{children:["Snitch is an HTTP focused tool, and as such it abstains from offering solutions to non-HTTP problems such as deeply integrating with databases. We believe it is better to leave that job to specialized tools such as Jooq or Exposed. That said what snitch does offer is an extremely easy way of integrating with such tools. For example, here's how simple it is to declare that endpoints within a given hierarchy should all execute the code within an ",(0,i.jsx)(n.code,{children:"Exposed"})," transaction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'withTransaction {\n    POST() with body<CreateUserRequest>() isHandledBy createUser\n    POST("login") with body<LoginRequest>() isHandledBy userLogin\n\n    userId / "posts" / {\n        authenticated {\n            GET() onlyIf principalEquals(userId) isHandledBy getPosts\n            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost\n\n            GET(postId) isHandledBy getPost\n            PUT(postId) with body<UpdatePostRequest>() onlyIf principalEquals(userId) isHandledBy updatePost\n            DELETE(postId) onlyif (principalEquals(userId) or hasAdminRole) isHandledBy deletePost\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"here's how withtransaction is implemented:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// transaction {} from Exposed framework\nval Router.withTransaction get() = decorateWith { transaction { next() } }\n"})}),"\n",(0,i.jsx)(n.p,{children:"The ease with which this feature can be implemented is a testament to the power and flexibility of middleware. This can also be done in a granular way, by endpoint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"GET() decorated withExposedTransaction onlyIf principalEquals(userId) isHandledBy getPosts\n"})}),"\n",(0,i.jsx)(n.p,{children:"and this is the declaration of this decoration, which can be reused across different endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val withExposedTransaction = decoration { transaction { next() } }\n"})}),"\n",(0,i.jsx)(n.p,{children:"this code hardly needs any explanation, in the spirit of Snitch philosophy."}),"\n",(0,i.jsx)(n.p,{children:"the transaction example was just one way of showing how the flexibility and power of the dsl makes it extremely convenient to integrate with purpose built tools for database and other purposes. Snitch focuses on HTTP, but it seamlessly integrates with other tools with other focuses."}),"\n",(0,i.jsx)(n.h3,{id:"guards",children:"Guards"}),"\n",(0,i.jsx)(n.p,{children:"Still on top of the same underlying mechanism we've built a powerful and granular guard mechanism, here's an example of it at work:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val requestWrapper.role: Role get() = (request[accessToken] as Authentication.Authenticated).claims.role\n\nval hasAdminRole = condition {\n    when (role) {\n        ADMIN -> Successful()\n        else -> Failed(FORBIDDEN())\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"and this is how it's used"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"DELETE(postId) onlyIf hasAdminRole isHandledBy deletePost\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onlIf"})," takes a condition which can be either ",(0,i.jsx)(n.code,{children:"Successful"})," or ",(0,i.jsx)(n.code,{children:"Failed"})," and will either proceed with the request or terminate early accordingly."]}),"\n",(0,i.jsx)(n.p,{children:"This offers a high degree of granularity when specifying access control as applied to individual routes."}),"\n",(0,i.jsx)(n.h4,{id:"composing-conditions",children:"Composing conditions"}),"\n",(0,i.jsx)(n.p,{children:"Conditions are composable and support basic boolean logic operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost\n"})}),"\n",(0,i.jsx)(n.p,{children:"The code above hardly needs an explanation for what it's doing, despite the fact that it's not trivial behaviour."}),"\n",(0,i.jsxs)(n.p,{children:["here's the definition of ",(0,i.jsx)(n.code,{children:"principalEquals"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun principalEquals(param: Parameter<out Any, *>) = condition {\n    if (principal.value == request[param]) Successful()\n    else Failed(FORBIDDEN())\n}\n\nval RequestWrapper.principal: UserId get() = (request[accessToken] as Authentication.Authenticated).claims.userId\n"})}),"\n",(0,i.jsx)(n.h4,{id:"reusing-conditions",children:"Reusing conditions"}),"\n",(0,i.jsx)(n.p,{children:"Although it's possible to customize each and every endpoint to lock it down to the exact security guarantees your business logic needs to enforce, it's often the case that you need to share the same guard logic across several endpoints. Snitch offers two ways of doing this, the first one is obvious:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val ownerOrAdmin = principalEquals(userId) or hasAdminRole\n\nDELETE(postId) onlyIf ownerOrAdmin isHandledBy deletePost\n"})}),"\n",(0,i.jsx)(n.p,{children:"The second one is even more generic, as it can be applied to an entire sub-hierarchy of routes. It works similarly to how middleware does:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"onlyIf(principalEquals(userId) or hasAdminRole) {\n    ...\n    DELETE(postId) isHandledBy deletePost\n    PATCH(postId) with body<UpdatePostRequest>() isHandledBy updatePost\n    ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'Note that this approach to Guards is in line with what we call "Snitch\'s way" or "Snitchy". Of course good old imperative checks inside the handler are still possible and supported, and in some cases that\'s the best thing to do. But sticking to Snitch\'s way allows for more consistent, readable and manageable codebases at any scale.'}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,i.jsx)(n.p,{children:"Although Snitch encourages a more functional approach to errors, it also supports global exception handling for both unexpected behaviour and for flow control."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"snitch(GsonJsonParser)\n    .onRoutes(root)\n    .handleException(MyException::class) { exception ->\n        MyCustomErroResponse(exception.reason)\n            .also { logger().error(it.toString()) }\n            .badRequest()\n    }\n    .start()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the body of the exception handler works like the normal handlers', with the only difference that it has a referfence to the exception being handled, thie ",(0,i.jsx)(n.code,{children:"it"})," of the lambda, which can be optionally named as in the example above. Note that it's not necessary to return an error response, it's possible to return an alternative successful response instead. You can see that there is a lot of functionality packed in a small amount of code, yet it still remains fairly intuitive and readable."]}),"\n",(0,i.jsx)(n.h4,{id:"polymorphic-error-handling",children:"Polymorphic error handling"}),"\n",(0,i.jsxs)(n.p,{children:["Note that error handling is polymorphic, so if ",(0,i.jsx)(n.code,{children:"MyException"})," extends ",(0,i.jsx)(n.code,{children:"MyBaseException"})," ",(0,i.jsx)(n.code,{children:".handleException(MyBaseException::class)..."})," would handle ",(0,i.jsx)(n.code,{children:"MyException"})," as well as any other subclass of ",(0,i.jsx)(n.code,{children:"MyBaseException"}),". For this reason, ordering of the declaration of exception handlers matters. You should always put the most specific handlers first, otherwise a more generic polymorphic handler would handle the exception instead. Note that this feature implementation relies on some reflection, and while it's relatively efficient, it's not as efficient as a more functional approach. For that reason this should not be used as a main flow control mechanism for performance critical applications."]}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.p,{children:"Snitch supports a fluent and concise integration testing DSL. In accordance with the rest of the library, it is designed with simplicity, intuitiveness and readability in mind. The expressiveness and simplicity is aimed at encouraging a TDD approach. Here is what simple tests would look like, including an example of the base class and application object:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class HealthTest : BaseTest() {\n    @Test\n    fun `foo does bar`() {\n        GET("/foo/bar")\n            .expectCode(200)\n            .expectBody("""{"status": "ok"}""")\n    }\n    \n    @Test\n    fun `post`() {\n        POST("/foo/bar")\n            .withBody(myRequestBody)\n            .expectCode(200)\n            .expectBody("""{"status": "ok"}""")\n    }\n}\n\n@TestInstance(Testinstance.Lifecycle.PER_CLASS)\nabstract class BaseTest : SnitchTest({ Application.setup(it) }) {\n    @BeforeAll\n    fun beforeAll() = super.before()\n\n    @AfterAll\n    fun afterAll() = super.after()\n}\n\nobject Application {\n    fun setup(port: Int): RoutedService =\n        snitch(GsonJsonParser, snitchConfig(Service(port = port)))\n            .onRoutes(rootRouter)\n            .handleExceptions()\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["please refer to the ",(0,i.jsx)(n.code,{children:"example"})," module in the repository source code for more in-depth examples involving real-world use cases complete with database setup and access, dependency injection and more."]}),"\n",(0,i.jsx)(n.h3,{id:"intellij-integration",children:"Intellij integration"}),"\n",(0,i.jsx)(n.p,{children:"Snitch has the best in class IntelliJ integration plugin and it ships by default with the IDE: Jetbrain's Kotlin plugin. that's all that's needed to unleash the full power of snitch and have autocompletion, syntax higlighting and so on. because snitch aims at being plain kotlin only, without reflection or annotation processing or code generation, the kotlin compiler is fully capable of understanding each aspect of the library and its uses. Snitch usage errors are more often than not resolved at compile time. One of the leading design principles of Snitch is that the user of the library should always be able to use the IDE to navigate to middleware definitions, follow the nesting of routes upsream and downstream, and so on. A user should never be in the position of not knowing what some code does. They might not necessarily understand every aspect of how the internals work, but they should at the very least be able to see the internals, and explore them with their IDE. The pure kotlin approach makes this easy."}),"\n",(0,i.jsx)(n.h3,{id:"showcase",children:"Showcase"}),"\n",(0,i.jsx)(n.h4,{id:"dsl-extension-usecase-api-versioning",children:"DSL extension usecase: API versioning"}),"\n",(0,i.jsx)(n.p,{children:"It is often the case that your API will need versioning for backwards compatibility with deployed clients. There are several approaches to versioning. A common and annoying problem is handling relatively minor version differences on only a subset of endpoints. Setting up a whole separate path hierarchy may be an overkill in such cases. E.g you want to have these routes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"GET /v1/hey/there/foo\nGET /v2/hey/there/foo\nGET /v1/hey/all/bar\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is how easy it is to extend Snitch's DSL to support this type of versioning:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val baseVersion = "v1"\n\nbaseVersion / {\n    "hey" / {\n        "there" / {\n            GET("foo") isHandledBy { "this is foo v1".ok }\n            GET("foo").v2 isHandledBy { "this is foo v2".ok }\n        }\n        "all" / {\n            GET("bar") isHandledBy { "this is bar v1".ok }\n        }\n    }\n}\n\n// demo only, use a more robust path editing logic for production\nval <T : Any> Endpoint<T>.v2 get() = copy(path = path.replace("/$baseVersion/", "/v2/"))\n'})}),"\n",(0,i.jsx)(n.p,{children:"And that's it. Endpoints are data classes and can be customized like any other data class in Kotlin."}),"\n",(0,i.jsx)(n.p,{children:"This style is also supported, if you prefer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'GET("foo") v 2 isHandledBy { "this is foo v2".ok }\n'})}),"\n",(0,i.jsx)(n.p,{children:"This uses an extension function instead of an extension property."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// demo only, use a more robust path editing logic for production\ninfix fun <T: Any> Endpoint<T>.v(version: Int) = copy(\n    path = path.replace("/$baseVersion/", "/v$version/")\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"coroutine-support",children:"Coroutine support"}),"\n",(0,i.jsxs)(n.p,{children:["Snitch is asynchronous by default, and as such it works well with coroutines. You can use your suspend functions just like normal code, just use a ",(0,i.jsx)(n.code,{children:"coHandling"})," or ",(0,i.jsx)(n.code,{children:"isCoHandledBy"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val getUsers by coHandling {\n    usersRepository().getUsersAsync().ok\n}\n\nGET("users") isHandledBy getUsers\nGET("posts") isCoHandledBy { postsRepository().getPostsAsync().ok }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Coroutine support are not included by default, so you need to add this to your gradle build file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'dependencies {\n    implementation("io.github.memoizr:snitch-coroutines:1.0.0")\n}\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions {\n        freeCompilerArgs = freeCompilerArgs + "-Xcontext-receivers"\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Depending on usage patterns we might include coroutines as part of the main API and thus remove the need for the ",(0,i.jsx)(n.code,{children:"coHandling"})," and ",(0,i.jsx)(n.code,{children:"isCoHandledBy"})," functions and extra gradle code."]}),"\n",(0,i.jsx)(n.h3,{id:"faq",children:"FAQ"}),"\n",(0,i.jsx)(n.h4,{id:"how-does-snitch-handle-concurrency",children:"How does Snitch handle concurrency?"}),"\n",(0,i.jsx)(n.p,{children:"Snitch is a thin layer on top of the underlying HTTP server. By default, that's Undertow, so Snitch will handle concurrency in the samw way Undertow does."}),"\n",(0,i.jsx)(n.h4,{id:"just-how-light-and-fast-is-snitch",children:'Just how "light" and "fast" is Snitch?'}),"\n",(0,i.jsx)(n.p,{children:"Snitch is a small library with very little overhead on top of the HTTP server. By default that's Undertow, and multiple benchmarks have put Undertow consistently in the top 3 servers in the JVM for years. Undertow is also one of the lightest embedded HTTP servers. In short, Snitch is in practice as fast and as lightweight as Undertow is."}),"\n",(0,i.jsx)(n.h4,{id:"how-does-the-automatic-openapi-3-documentation-generation-work",children:"How does the automatic OpenApi 3 documentation generation work?"}),"\n",(0,i.jsx)(n.p,{children:"Snitch uses information from the type system to know everything there is to know about an endpoint and its inputs and outputs."}),"\n",(0,i.jsx)(n.h4,{id:"why-is-snitch-typesafe",children:"Why is Snitch typesafe?"}),"\n",(0,i.jsx)(n.p,{children:"Snitch enforces explicit declarations on any inputs and outputs for each endpoint, and these declarations include type information. This way when the inputs are used inside the handlers, they are already verified and transformed, and any unexpected inputs automatically and consistently dealt with."}),"\n",(0,i.jsx)(n.h4,{id:"how-does-snitch-handle-http-sessions-and-cookies",children:"How does Snitch handle HTTP sessions and cookies?"}),"\n",(0,i.jsx)(n.p,{children:"It doesn't and it won't. Snitch is designed for highly scalable stateless applications. Session management, caching and any other stateful solution, can and should be implemented at the infrastructure layer."}),"\n",(0,i.jsx)(n.h4,{id:"does-snitch-support-x-database-integration",children:"Does Snitch support X database integration?"}),"\n",(0,i.jsx)(n.p,{children:"Yes it does as long as X has a Java api. The middleware system's flexibility makes it easy to add support for X. No Snitch does not ship with X support by default because your needs are most likely than not unique and you'd rather have an easy way of doing it your way than a default that won't suit you."}),"\n",(0,i.jsx)(n.h4,{id:"how-does-snitch-handle-scalability",children:"How does Snitch handle scalability?"}),"\n",(0,i.jsx)(n.p,{children:"Snitch is a low overhead, fast execution framework. It is stateless by default, and it's designed for deployment in clusters. Snitch once containerized and deployed in Kubernetes, ECS or analogous clusters will scale to fit any requirement. Most likely your limiting factor will be your database system."}),"\n",(0,i.jsx)(n.h4,{id:"how-does-snitch-handle-security-particularly-in-terms-of-input-validation",children:"How does Snitch handle security, particularly in terms of input validation?"}),"\n",(0,i.jsx)(n.p,{children:"Snitch offers both Validators, Guards and Middleware as powerful tools to implement granular and effective security. Used in combination, these features will greatly enhance the security of your endpoints. Refer to the documentation to learn how to use these features. Do keep in mind security is a multi-layer issue, so do not rely exclusively on application layer security for your critical use cases."}),"\n",(0,i.jsx)(n.h4,{id:"how-does-snitch-compare-to-other-kotlin-web-frameworks-like-ktor-or-spring-boot-in-terms-of-performance-and-ease-of-use",children:"How does Snitch compare to other Kotlin web frameworks like Ktor or Spring Boot in terms of performance and ease of use?"}),"\n",(0,i.jsx)(n.p,{children:'Snitch was developed keeping a variety of other frameworks in mind, shamelessly taking inspiration from them. As such it is aimed at improving the development experience over those frameworks too. In the case of Spring, we believe that framework is overly complicated for most use cases. The "convention over configuration" approach most often than not shifts the burden from the explicit, to the implicit, greatly aggravating cognitive load. KTor is somewhat better in that regard, but we believe it does not go far enough and does not exploit Kotlin\'s full potential, despite its pedigree. Snitch is aimed at being the most powerful simple tool you can use while retaining excellent readability qualities and a minimal API.'})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);