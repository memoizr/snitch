"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[7709],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},9203:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorials/QuickStart","title":"Snitch Quick Start Guide","description":"This guide will help you quickly set up a basic web service using Snitch.","source":"@site/docs/tutorials/QuickStart.md","sourceDirName":"tutorials","slug":"/tutorials/QuickStart","permalink":"/docs/tutorials/QuickStart","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/tutorials/QuickStart.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Property-Based Testing with Kofix","permalink":"/docs/tutorials/PropertyBasedTesting"},"next":{"title":"Shank in Action: Building a Real-World Application","permalink":"/docs/tutorials/ShankInAction"}}');var i=t(4848),a=t(8453);const o={},r="Snitch Quick Start Guide",l={},d=[{value:"Installation",id:"installation",level:2},{value:"Hello World Example",id:"hello-world-example",level:2},{value:"Creating a RESTful API",id:"creating-a-restful-api",level:2},{value:"Parameter Validation",id:"parameter-validation",level:2},{value:"Adding Middleware",id:"adding-middleware",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Using Conditions",id:"using-conditions",level:2},{value:"Handler Functions",id:"handler-functions",level:2},{value:"Testing Your API",id:"testing-your-api",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"snitch-quick-start-guide",children:"Snitch Quick Start Guide"})}),"\n",(0,i.jsx)(n.p,{children:"This guide will help you quickly set up a basic web service using Snitch."}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.p,{children:"Add Snitch to your project dependencies:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'dependencies {\n    implementation("io.github.memoizr:snitch-bootstrap:1.0.0")\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"hello-world-example",children:"Hello World Example"}),"\n",(0,i.jsx)(n.p,{children:'Create a simple "Hello World" service:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import snitch.gson.GsonJsonParser\nimport snitch.dsl.snitch\nimport snitch.dsl.routes\nimport snitch.dsl.response.ok\n\nfun main() {\n    snitch(GsonJsonParser)\n        .onRoutes {\n            GET("hello") isHandledBy { "world".ok }\n        }\n        .start()\n        .serveDocumenation()\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This creates a service that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['Responds with "world" when you make a GET request to ',(0,i.jsx)(n.code,{children:"/hello"})]}),"\n",(0,i.jsxs)(n.li,{children:["Automatically generates API documentation available at ",(0,i.jsx)(n.code,{children:"/docs"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-restful-api",children:"Creating a RESTful API"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a more realistic example with multiple endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import snitch.gson.GsonJsonParser\nimport snitch.dsl.*\nimport snitch.dsl.response.*\n\n// Define our data classes\ndata class User(val id: String, val name: String, val email: String)\ndata class CreateUserRequest(val name: String, val email: String)\n\n// In-memory storage for this example\nval users = mutableMapOf<String, User>()\n\nfun main() {\n    snitch(GsonJsonParser)\n        .onRoutes {\n            "users" / {\n                // GET /users - List all users\n                GET() isHandledBy { \n                    users.values.toList().ok \n                }\n                \n                // POST /users - Create a new user\n                POST() with body<CreateUserRequest>() isHandledBy { \n                    val id = java.util.UUID.randomUUID().toString()\n                    val user = User(id, body.name, body.email)\n                    users[id] = user\n                    user.created\n                }\n                \n                // GET /users/{userId} - Get a specific user\n                userId / {\n                    GET() isHandledBy {\n                        val id = request[userId]\n                        users[id]?.ok ?: "User not found".notFound()\n                    }\n                    \n                    // DELETE /users/{userId} - Delete a user\n                    DELETE() isHandledBy {\n                        val id = request[userId]\n                        if (users.containsKey(id)) {\n                            users.remove(id)\n                            "User deleted".ok\n                        } else {\n                            "User not found".notFound()\n                        }\n                    }\n                }\n            }\n        }\n        .start()\n        .serveDocumenation()\n}\n\n// Define a path parameter\nval userId by path()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"parameter-validation",children:"Parameter Validation"}),"\n",(0,i.jsx)(n.p,{children:"Let's enhance our API with parameter validation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// Define validated parameters\nval limit by query(ofNonNegativeInt(max = 30, default = 10))\nval offset by query(ofNonNegativeInt(default = 0))\nval email by query(ofEmail)\n\n// Define our own custom validator\nval ofEmail = stringValidator("valid email") { \n    it.contains("@") && it.contains(".") \n}\n\n// Use in routes\n"users" / {\n    // GET /users?limit=10&offset=0\n    GET() with listOf(limit, offset) isHandledBy {\n        users.values\n            .toList()\n            .drop(request[offset])\n            .take(request[limit])\n            .ok\n    }\n    \n    // GET /users/search?email=user@example.com\n    "search" / {\n        GET() with email isHandledBy {\n            val searchEmail = request[email]\n            users.values\n                .filter { it.email == searchEmail }\n                .toList()\n                .ok\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"adding-middleware",children:"Adding Middleware"}),"\n",(0,i.jsx)(n.p,{children:"Implement a simple logging middleware:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// Simple logging middleware that doesn\'t require parameters\nval Router.log get() = decorateWith {\n    println("\u27a1\ufe0f ${request.method} ${request.path} - Request started")\n    val response = next()\n    println("\u2b05\ufe0f ${request.method} ${request.path} - Response: ${response.statusCode}")\n    response\n}\n\n// Apply middleware to routes\nroutes {\n    log {\n        "users" / {\n            // All user routes will be logged\n            GET() isHandledBy { users.values.toList().ok }\n            // ...\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.p,{children:"Implement a basic authentication system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// Define the header parameter for authentication\nval accessToken by header(\n    condition = validAccessToken,\n    name = "Authorization",\n    description = "Bearer token for authentication"\n)\n\n// Validator for access token\nval validAccessToken = stringValidator { token ->\n    if (token.startsWith("Bearer ")) {\n        val actualToken = token.substring(7)\n        if (isValidToken(actualToken)) {\n            Authentication.Authenticated(JWTClaims(getUserId(actualToken), getRole(actualToken)))\n        } else {\n            Authentication.InvalidToken\n        }\n    } else {\n        Authentication.MissingToken\n    }\n}\n\n// Authentication result model\nsealed interface Authentication {\n    data class Authenticated(val claims: JWTClaims) : Authentication\n    interface Unauthenticated : Authentication\n    object InvalidToken : Unauthenticated\n    object MissingToken : Unauthenticated\n}\n\n// Data class for JWT claims\ndata class JWTClaims(val userId: UserId, val role: Role)\ndata class UserId(val value: String)\nenum class Role { USER, ADMIN }\n\n// Authentication middleware with proper parameter declaration\nval Router.authenticated get() = decorateWith(accessToken) {\n    when (val auth = request[accessToken]) {\n        is Authentication.Authenticated -> {\n            next() // Proceed to the handler\n        }\n        is Authentication.Unauthenticated -> "Authentication required".unauthorized()\n    }\n}\n\n// Extension properties to access authentication data\nval RequestWrapper.principal: UserId get() = \n    (request[accessToken] as Authentication.Authenticated).claims.userId\nval RequestWrapper.role: Role get() = \n    (request[accessToken] as Authentication.Authenticated).claims.role\n\n// Apply to protected routes\nroutes {\n    "public" / {\n        // Public endpoints...\n    }\n    \n    "api" / {\n        authenticated {\n            // Protected endpoints...\n            "profile" / {\n                GET() isHandledBy { \n                    getUserProfile(request.principal).ok \n                }\n            }\n            \n            // Example of using principal in a handler\n            "posts" / {\n                GET() isHandledBy { \n                    getPostsByUser(request.principal).ok \n                }\n                \n                POST() with body<CreatePostRequest>() isHandledBy {\n                    createPost(request.principal, body.title, body.content).created\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"using-conditions",children:"Using Conditions"}),"\n",(0,i.jsx)(n.p,{children:"Implement access control with conditions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// Define conditions\nval isAdmin = condition("isAdmin") {\n    if (request.role == Role.ADMIN) {\n        ConditionResult.Successful\n    } else {\n        ConditionResult.Failed("Admin access required".forbidden())\n    }\n}\n\n// Condition to check if the user is the owner of a resource\nfun isOwner(resourceIdParam: Parameter<String, *>) = condition("isOwner") {\n    val resourceId = request[resourceIdParam]\n    val resource = getResourceById(resourceId)\n    \n    if (resource?.ownerId == request.principal.value) {\n        ConditionResult.Successful\n    } else {\n        ConditionResult.Failed("You don\'t have permission to access this resource".forbidden())\n    }\n}\n\n// Apply conditions to endpoints\nroutes {\n    authenticated {\n        // Admin-only endpoint\n        "admin" / {\n            GET("dashboard") onlyIf isAdmin isHandledBy { \n                getAdminDashboard().ok \n            }\n        }\n        \n        // User can only access their own posts\n        "posts" / postId / {\n            GET() onlyIf isOwner(postId) isHandledBy { getPost() }\n            PUT() onlyIf isOwner(postId) with body<UpdatePostRequest>() isHandledBy { updatePost() }\n            DELETE() onlyIf isOwner(postId) isHandledBy { deletePost() }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"handler-functions",children:"Handler Functions"}),"\n",(0,i.jsx)(n.p,{children:"Snitch provides a clean way to define handler functions that can access the request context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// Define a path parameter\nval postId by path()\n\n// Handler for getting a post\nprivate val getPost by handling {\n    postsRepository().getPost(PostId(request[postId]))\n        ?.toResponse?.ok\n        ?: "Post not found".notFound()\n}\n\n// Handler for deleting a post\nprivate val deletePost by handling {\n    postsRepository().deletePost(request.principal, PostId(request[postId]))\n        .noContent\n}\n\n// Handler for getting all posts for the current user\nprivate val getPosts by handling {\n    postsRepository().getPosts(request.principal)\n        .toResponse.ok\n}\n\n// Handler with request body parsing\nprivate val createPost by parsing<CreatePostRequest>() handling {\n    postsRepository().putPost(\n        CreatePostAction(\n            request.principal,\n            PostTitle(body.title),\n            PostContent(body.content),\n        )\n    ).mapSuccess {\n        SuccessfulCreation(value).created\n    }.mapFailure {\n        FailedCreation().badRequest()\n    }\n}\n\n// Usage in routes\nroutes {\n    authenticated {\n        "posts" / {\n            GET() isHandledBy getPosts\n            POST() with body<CreatePostRequest>() isHandledBy createPost\n            \n            postId / {\n                GET() isHandledBy getPost\n                DELETE() isHandledBy deletePost\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"testing-your-api",children:"Testing Your API"}),"\n",(0,i.jsx)(n.p,{children:"Test your endpoints with the built-in testing DSL:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class UserApiTest : SnitchTest({ port -> setupApp(port) }) {\n    \n    @Test\n    fun `get all users returns 200`() {\n        GET("/users")\n            .expectCode(200)\n            .expectBodyContains("[]") // Initially empty\n    }\n    \n    @Test\n    fun `create user returns 201`() {\n        POST("/users")\n            .withBody("""{"name":"John","email":"john@example.com"}""")\n            .expectCode(201)\n            .expectBodyContains("John")\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you have a basic understanding of Snitch, explore:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation Generation"}),": Learn how to enhance your API documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Implement global exception handlers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom Validators"}),": Create complex validation rules"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Coroutines"}),": Use Kotlin coroutines for asynchronous operations"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For more details, check out:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/Docs",children:"Snitch Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"../in%20depth/",children:"In Depth Guides"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);