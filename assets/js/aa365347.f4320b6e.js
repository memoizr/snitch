"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[5849],{454:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"in depth/Mastering-Snitch-Validators","title":"Validators","description":"Validators are a core feature of Snitch that ensure your HTTP inputs are properly validated, transformed, and documented. This guide will walk you through everything you need to know about validators, from basic usage to advanced customization.","source":"@site/docs/in depth/Mastering-Snitch-Validators.md","sourceDirName":"in depth","slug":"/in depth/Mastering-Snitch-Validators","permalink":"/docs/in depth/Mastering-Snitch-Validators","draft":false,"unlisted":false,"editUrl":"https://github.com/memoizr/snitch/tree/master/guides/docs/in depth/Mastering-Snitch-Validators.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Parameters","permalink":"/docs/in depth/Mastering-Snitch-Parameters"},"next":{"title":"Snitch Artifacts","permalink":"/docs/resources/Artifacts"}}');var t=n(4848),r=n(8453);const l={},s="Validators",o={},d=[{value:"Introduction to Validators",id:"introduction-to-validators",level:2},{value:"Built-in Validators",id:"built-in-validators",level:2},{value:"Numeric Validators",id:"numeric-validators",level:3},{value:"String Validators",id:"string-validators",level:3},{value:"Special Format Validators",id:"special-format-validators",level:3},{value:"Date/Time Validators",id:"datetime-validators",level:3},{value:"Collection Validators",id:"collection-validators",level:3},{value:"Boolean Validators",id:"boolean-validators",level:3},{value:"ID Validators",id:"id-validators",level:3},{value:"Enum Validators",id:"enum-validators",level:3},{value:"Using Validators with Parameters",id:"using-validators-with-parameters",level:2},{value:"Creating Custom Validators",id:"creating-custom-validators",level:2},{value:"Basic Custom Validator",id:"basic-custom-validator",level:3},{value:"Full Custom Validator Implementation",id:"full-custom-validator-implementation",level:3},{value:"Factory Functions",id:"factory-functions",level:3},{value:"Advanced Validator Patterns",id:"advanced-validator-patterns",level:2},{value:"Combining Validation and Business Logic",id:"combining-validation-and-business-logic",level:3},{value:"Chaining Validations",id:"chaining-validations",level:3},{value:"JWT Validators",id:"jwt-validators",level:3},{value:"Handling Collections and Optional Values",id:"handling-collections-and-optional-values",level:2},{value:"Multiple Values",id:"multiple-values",level:3},{value:"Optional Parameters",id:"optional-parameters",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Domain Types",id:"1-use-domain-types",level:3},{value:"2. Provide Clear Error Messages",id:"2-provide-clear-error-messages",level:3},{value:"3. Keep Validators Reusable",id:"3-keep-validators-reusable",level:3},{value:"4. Validate at the Edge",id:"4-validate-at-the-edge",level:3},{value:"5. Test Your Validators",id:"5-test-your-validators",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"validators",children:"Validators"})}),"\n",(0,t.jsx)(a.p,{children:"Validators are a core feature of Snitch that ensure your HTTP inputs are properly validated, transformed, and documented. This guide will walk you through everything you need to know about validators, from basic usage to advanced customization."}),"\n",(0,t.jsx)(a.h2,{id:"introduction-to-validators",children:"Introduction to Validators"}),"\n",(0,t.jsx)(a.p,{children:"In HTTP applications, inputs from requests (path parameters, query parameters, headers, body) are always strings or collections of strings. However, your business logic typically requires strongly-typed values with guaranteed validity. Validators are the bridge that transforms these raw inputs into safe, typed values."}),"\n",(0,t.jsx)(a.p,{children:"At their core, validators in Snitch serve three main purposes:"}),"\n",(0,t.jsxs)(a.ol,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Validation"}),": Ensuring inputs meet specific criteria"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Transformation"}),": Converting strings to appropriate target types"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Documentation"}),": Providing clear descriptions for API documentation"]}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:["The ",(0,t.jsx)(a.code,{children:"Validator<T, R>"})," interface is defined with two type parameters:"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"T"}),": The input type (usually ",(0,t.jsx)(a.code,{children:"String"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"R"}),": The output type (the type you want to work with in your code)"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"And three main components:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"regex"}),": A regular expression pattern for basic string validation"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"description"}),": A human-readable description for documentation"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"parse"}),": A function that transforms validated input into the output type"]}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"built-in-validators",children:"Built-in Validators"}),"\n",(0,t.jsx)(a.p,{children:"Snitch comes with a comprehensive set of built-in validators for common use cases:"}),"\n",(0,t.jsx)(a.h3,{id:"numeric-validators",children:"Numeric Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Integer validators\nval ofInt: Validator<Int, Int>\nval ofNonNegativeInt: Validator<Int, Int>\nval ofPositiveInt: Validator<Int, Int>\nfun ofIntRange(min: Int, max: Int): Validator<Int, Int>\n\n// Decimal validators\nval ofDouble: Validator<Double, Double>\nfun ofDoubleRange(min: Double, max: Double): Validator<Double, Double>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"string-validators",children:"String Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofNonEmptyString: Validator<String, String>\nval ofNonEmptySingleLineString: Validator<String, String>\nfun ofStringLength(minLength: Int, maxLength: Int): Validator<String, String>\nval ofAlphanumeric: Validator<String, String>\nfun ofRegexPattern(pattern: String, description: String): Validator<String, String>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"special-format-validators",children:"Special Format Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofEmail: Validator<String, String>\nval ofUrl: Validator<String, URI>\nval ofIpv4: Validator<String, String>\nval ofPhoneNumber: Validator<String, String>\nval ofJson: Validator<String, String>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"datetime-validators",children:"Date/Time Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofDate: Validator<String, LocalDate>\nval ofDateTime: Validator<String, LocalDateTime>\nfun ofDateFormat(format: String): Validator<String, LocalDate>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"collection-validators",children:"Collection Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofStringSet: Validator<String, Set<String>>\nval ofNonEmptyStringSet: Validator<String, Set<String>>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"boolean-validators",children:"Boolean Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofBoolean: Validator<Boolean, Boolean>  // Handles true/false, yes/no, 1/0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"id-validators",children:"ID Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val ofUuid: Validator<String, UUID>\n"})}),"\n",(0,t.jsx)(a.h3,{id:"enum-validators",children:"Enum Validators"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"inline fun <reified E : Enum<*>> ofEnum(): Validator<String, E>\ninline fun <reified E : Enum<*>> ofRepeatableEnum(): Validator<String, Collection<E>>\n"})}),"\n",(0,t.jsx)(a.h2,{id:"using-validators-with-parameters",children:"Using Validators with Parameters"}),"\n",(0,t.jsx)(a.p,{children:"Validators are typically used when defining parameters:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Path parameters\nval userId by path(ofNonNegativeInt)\nval username by path(ofAlphanumeric)\n\n// Query parameters\nval limit by query(ofIntRange(1, 100))\nval sortBy by query(ofEnum<SortField>())\nval email by query(ofEmail)\n\n// Header parameters\nval apiKey by header(ofUuid)\nval contentType by header(ofNonEmptyString)\n"})}),"\n",(0,t.jsx)(a.p,{children:"When used in routes, parameters are automatically validated:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'GET("users" / userId) withQuery limit isHandledBy {\n    // Access validated parameters\n    val id: Int = request[userId]      // Already validated and parsed\n    val maxItems: Int = request[limit] // Already validated and parsed\n    \n    usersRepository.getUsers(id, maxItems).ok\n}\n'})}),"\n",(0,t.jsx)(a.h2,{id:"creating-custom-validators",children:"Creating Custom Validators"}),"\n",(0,t.jsx)(a.p,{children:"While built-in validators cover many common cases, you'll often need custom validators for domain-specific types. Snitch makes this straightforward:"}),"\n",(0,t.jsx)(a.h3,{id:"basic-custom-validator",children:"Basic Custom Validator"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'// Define a domain type\ndata class UserId(val value: String)\n\n// Create a validator\nval ofUserId = validator<String, UserId>(\n    "valid user ID",\n    """^[a-zA-Z0-9]{8,12}$""".toRegex()\n) {\n    UserId(it)\n}\n\n// Use it with a parameter\nval userId by path(ofUserId)\n'})}),"\n",(0,t.jsx)(a.h3,{id:"full-custom-validator-implementation",children:"Full Custom Validator Implementation"}),"\n",(0,t.jsx)(a.p,{children:"For more complex validation logic:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'object UserIdValidator : Validator<String, UserId> {\n    override val description = "Valid user ID (8-12 alphanumeric characters)"\n    override val regex = """^[a-zA-Z0-9]{8,12}$""".toRegex()\n    override val parse: Parser.(Collection<String>) -> UserId = { collection ->\n        val value = collection.first()\n        if (userRepository.exists(value)) {\n            UserId(value)\n        } else {\n            throw IllegalArgumentException("User ID does not exist")\n        }\n    }\n}\n\n// Use it with a parameter\nval userId by path(UserIdValidator)\n'})}),"\n",(0,t.jsx)(a.h3,{id:"factory-functions",children:"Factory Functions"}),"\n",(0,t.jsx)(a.p,{children:"Snitch provides several factory functions to create validators:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'// For generic validators\nfun <From, To> validator(\n    description: String,\n    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),\n    mapper: Parser.(String) -> To\n): Validator<From, To>\n\n// For string validators\nfun <To> stringValidator(\n    description: String,\n    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),\n    mapper: Parser.(String) -> To\n): Validator<String, To>\n\n// For multi-value validators\nfun <From, To> validatorMulti(\n    description: String,\n    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),\n    mapper: Parser.(Collection<String>) -> To\n): Validator<From, To>\n\n// For string collection validators\nfun <To> stringValidatorMulti(\n    description: String,\n    regex: Regex = """^.+$""".toRegex(RegexOption.DOT_MATCHES_ALL),\n    mapper: Parser.(Collection<String>) -> To\n): Validator<String, To>\n'})}),"\n",(0,t.jsx)(a.h2,{id:"advanced-validator-patterns",children:"Advanced Validator Patterns"}),"\n",(0,t.jsx)(a.h3,{id:"combining-validation-and-business-logic",children:"Combining Validation and Business Logic"}),"\n",(0,t.jsx)(a.p,{children:"Sometimes validation involves checking against business rules:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'val ofActiveUser = validator<String, User>(\n    "active user ID",\n    """^[a-zA-Z0-9]{8,12}$""".toRegex()\n) {\n    val user = userRepository.findById(it) \n        ?: throw IllegalArgumentException("User not found")\n        \n    if (!user.isActive) {\n        throw IllegalArgumentException("User is not active")\n    }\n    \n    user\n}\n'})}),"\n",(0,t.jsx)(a.h3,{id:"chaining-validations",children:"Chaining Validations"}),"\n",(0,t.jsx)(a.p,{children:"You can chain validations by creating validators that build on others:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'val ofEmail = validator<String, String>(\n    "email address",\n    """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$""".toRegex()\n) { it }\n\nval ofCorporateEmail = validator<String, String>(\n    "corporate email address",\n    """^[a-zA-Z0-9._%+-]+@company\\.com$""".toRegex()\n) { \n    // First validate it\'s an email\n    ofEmail.regex.matchEntire(it) ?: throw IllegalArgumentException("Invalid email format")\n    \n    // Then check for specific domain\n    if (!it.endsWith("@company.com")) {\n        throw IllegalArgumentException("Must be a company.com email")\n    }\n    \n    it\n}\n'})}),"\n",(0,t.jsx)(a.h3,{id:"jwt-validators",children:"JWT Validators"}),"\n",(0,t.jsx)(a.p,{children:"Here's an example of a JWT validator:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'data class JwtClaims(val userId: String, val roles: List<String>)\n\nsealed interface Authentication {\n    data class Authenticated(val claims: JwtClaims) : Authentication\n    sealed interface Unauthenticated : Authentication\n    object InvalidToken : Unauthenticated\n    object ExpiredToken : Unauthenticated\n    object MissingToken : Unauthenticated\n}\n\nval validAccessToken = stringValidator<Authentication>("valid JWT") { jwt ->\n    try {\n        val jwtVerifier = JWT.require(Algorithm.HMAC256(secretKey))\n            .withIssuer("auth-service")\n            .build()\n            \n        val decodedJWT = jwtVerifier.verify(jwt)\n        val userId = decodedJWT.getClaim("userId").asString()\n        val roles = decodedJWT.getClaim("roles").asList(String::class.java)\n        \n        Authentication.Authenticated(JwtClaims(userId, roles))\n    } catch (e: TokenExpiredException) {\n        Authentication.ExpiredToken\n    } catch (e: Exception) {\n        Authentication.InvalidToken\n    }\n}\n\n// Use it with a parameter\nval accessToken by header(validAccessToken, name = "Authorization")\n'})}),"\n",(0,t.jsx)(a.h2,{id:"handling-collections-and-optional-values",children:"Handling Collections and Optional Values"}),"\n",(0,t.jsx)(a.h3,{id:"multiple-values",children:"Multiple Values"}),"\n",(0,t.jsx)(a.p,{children:"For parameters that accept multiple values:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val tags by query(ofStringSet)\nval roles by query(ofRepeatableEnum<UserRole>())\n\n// In the handler\nval userTags: Set<String> = request[tags]\nval userRoles: Collection<UserRole> = request[roles]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,t.jsx)(a.p,{children:"For optional parameters:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Nullable parameter\nval search by optionalQuery(ofNonEmptyString)\n\n// Parameter with default value\nval limit by optionalQuery(ofIntRange(1, 100), default = 20)\n\n// Control empty and invalid handling\nval page by optionalQuery(\n    ofNonNegativeInt, \n    default = 1, \n    emptyAsMissing = true,  // Treat empty string as missing\n    invalidAsMissing = true // Use default if parsing fails\n)\n\n// In the handler\nval searchTerm: String? = request[search] // Nullable\nval maxItems: Int = request[limit]       // Always has value (default if missing)\nval pageNumber: Int = request[page]      // Has default if empty or invalid\n"})}),"\n",(0,t.jsx)(a.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(a.h3,{id:"1-use-domain-types",children:"1. Use Domain Types"}),"\n",(0,t.jsx)(a.p,{children:"Instead of primitives, use domain-specific types with validators:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'// Bad\nval userId by path(ofNonEmptyString)\n\n// Good\ndata class UserId(val value: String)\nval ofUserId = validator<String, UserId>("user ID") { UserId(it) }\nval userId by path(ofUserId)\n'})}),"\n",(0,t.jsx)(a.h3,{id:"2-provide-clear-error-messages",children:"2. Provide Clear Error Messages"}),"\n",(0,t.jsx)(a.p,{children:"When validation fails, provide clear, actionable error messages:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'val ofWeekday = validator<String, DayOfWeek>(\n    "weekday name (Monday-Friday)",\n    """^[A-Za-z]+$""".toRegex()\n) {\n    try {\n        DayOfWeek.valueOf(it.uppercase())\n    } catch (e: IllegalArgumentException) {\n        throw IllegalArgumentException("\'$it\' is not a valid weekday (Monday-Friday)")\n    }\n}\n'})}),"\n",(0,t.jsx)(a.h3,{id:"3-keep-validators-reusable",children:"3. Keep Validators Reusable"}),"\n",(0,t.jsx)(a.p,{children:"If a validation logic is used in multiple places, define it once and reuse:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'// Shared across multiple endpoints/controllers\nobject Validators {\n    val ofEmail = validator<String, String>(\n        "email address",\n        """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$""".toRegex()\n    ) { it }\n    \n    val ofZipCode = validator<String, String>(\n        "ZIP code",\n        """^\\d{5}(-\\d{4})?$""".toRegex()\n    ) { it }\n}\n'})}),"\n",(0,t.jsx)(a.h3,{id:"4-validate-at-the-edge",children:"4. Validate at the Edge"}),"\n",(0,t.jsx)(a.p,{children:"Catch invalid inputs at the HTTP layer rather than deep in business logic:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Let Snitch handle validation\nval email by query(ofEmail)\n\n// In the handler - already validated and safe to use\nval emailAddress = request[email]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"5-test-your-validators",children:"5. Test Your Validators"}),"\n",(0,t.jsx)(a.p,{children:"Create unit tests for your validators, especially custom ones:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'@Test\nfun `ofEmail validator should accept valid email addresses`() {\n    val validEmails = listOf(\n        "user@example.com",\n        "firstname.lastname@example.com",\n        "user+tag@example.com"\n    )\n    \n    validEmails.forEach { email ->\n        assertTrue(ofEmail.regex.matches(email))\n    }\n}\n\n@Test\nfun `ofEmail validator should reject invalid email addresses`() {\n    val invalidEmails = listOf(\n        "",\n        "user@",\n        "@example.com",\n        "user@example"\n    )\n    \n    invalidEmails.forEach { email ->\n        assertFalse(ofEmail.regex.matches(email))\n    }\n}\n'})}),"\n",(0,t.jsx)(a.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(a.p,{children:"Validators are a powerful feature of Snitch that ensure your HTTP inputs are properly validated and transformed. By using validators effectively, you can:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Create more robust APIs with clear, consistent validation"}),"\n",(0,t.jsx)(a.li,{children:"Transform raw HTTP inputs into domain-specific types"}),"\n",(0,t.jsx)(a.li,{children:"Generate accurate API documentation automatically"}),"\n",(0,t.jsx)(a.li,{children:"Reduce boilerplate validation code in your handlers"}),"\n",(0,t.jsx)(a.li,{children:"Enforce validation at the edge of your application"}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Remember that validators are not just for validation but also for transformation. Using them effectively enables you to work with strongly typed values throughout your codebase, making your application more maintainable and less error-prone."})]})}function u(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>l,x:()=>s});var i=n(6540);const t={},r=i.createContext(t);function l(e){const a=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:a},e.children)}}}]);