"use strict";(self.webpackChunkguides=self.webpackChunkguides||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"automatic-api-docs-with-snitch","metadata":{"permalink":"/blog/automatic-api-docs-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2024-11-22-automatic-api-docs-with-snitch.md","source":"@site/blog/2024-11-22-automatic-api-docs-with-snitch.md","title":"Never Write API Docs Again: Snitch\'s Zero-Effort Documentation","description":"Documentation is crucial for API adoption and maintenance, yet it\'s often treated as an afterthought. Frameworks typically require extensive annotation or separate configuration files to generate documentation, leading to documentation that quickly becomes outdated. Snitch takes a radical approach: what if your code could generate complete, accurate documentation with zero additional effort?","date":"2024-11-22T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Documentation","permalink":"/blog/tags/documentation","description":"Content about API documentation and technical writing"},{"inline":false,"label":"OpenAPI","permalink":"/blog/tags/openapi","description":"Articles related to OpenAPI specification and tools"},{"inline":false,"label":"Developer Experience","permalink":"/blog/tags/developer-experience","description":"Content about improving the experience for developers"}],"readingTime":3.765,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"automatic-api-docs-with-snitch","title":"Never Write API Docs Again: Snitch\'s Zero-Effort Documentation","authors":["snitch-team"],"tags":["snitch","documentation","openapi","developer-experience"]},"unlisted":false,"nextItem":{"title":"Spring Boot vs Snitch: A Comprehensive Comparison for Modern API Development","permalink":"/blog/spring-boot-vs-snitch"}},"content":"Documentation is crucial for API adoption and maintenance, yet it\'s often treated as an afterthought. Frameworks typically require extensive annotation or separate configuration files to generate documentation, leading to documentation that quickly becomes outdated. Snitch takes a radical approach: what if your code could generate complete, accurate documentation with zero additional effort?\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Documentation Problem\\n\\nMost developers are familiar with the documentation dilemma:\\n\\n1. **Manual documentation** is time-consuming and quickly becomes outdated\\n2. **Annotation-based documentation** creates clutter and requires constant maintenance\\n3. **Separate documentation files** drift from the actual implementation\\n4. **Incomplete documentation** leads to trial-and-error API usage\\n\\nThe result is frustration for both API developers and consumers, wasted time, and buggy integrations.\\n\\n## Snitch\'s Zero-Effort Documentation Approach\\n\\nSnitch\'s approach is radical in its simplicity: your code is your documentation. With a single line, you can generate and serve complete OpenAPI 3.0 documentation:\\n\\n```kotlin\\nsnitch(GsonJsonParser)\\n    .onRoutes(routes)\\n    .generateDocumentation()\\n    .servePublicDocumentation()\\n    .start()\\n```\\n\\nThis automatically creates interactive Swagger UI documentation available at `/docs`, with no additional code or configuration required.\\n\\n## What Gets Documented Automatically\\n\\nSnitch\'s documentation includes everything API consumers need to know:\\n\\n### 1. Routes and Methods\\n\\nThe complete API structure is documented, with all paths and supported HTTP methods:\\n\\n```kotlin\\nroutes {\\n    \\"api\\" / \\"users\\" / {\\n        GET() isHandledBy getAllUsers          // GET /api/users\\n        POST() with userBody isHandledBy createUser  // POST /api/users\\n        \\n        userId / {\\n            GET() isHandledBy getUser          // GET /api/users/{userId}\\n            PUT() with userBody isHandledBy updateUser  // PUT /api/users/{userId}\\n        }\\n    }\\n}\\n```\\n\\n### 2. Parameters with Validation Rules\\n\\nAll parameters are documented with their validation rules:\\n\\n```kotlin\\nval userId by path(ofUUID, description = \\"Unique user identifier\\")\\nval limit by query(ofIntRange(1, 100), default = 20, description = \\"Maximum number of results\\")\\nval orderBy by query(ofEnum<SortField>(), description = \\"Field to sort results by\\")\\n```\\n\\nThe generated documentation shows:\\n- Parameter name, location (path, query, header)\\n- Data type and format (string, integer, UUID, etc.)\\n- Validation constraints (min/max, pattern, enum values)\\n- Default values for optional parameters\\n- Custom descriptions if provided\\n\\n### 3. Request Bodies\\n\\nRequest body schemas are automatically generated from your Kotlin classes:\\n\\n```kotlin\\ndata class CreateUserRequest(\\n    val name: String,\\n    val email: String,\\n    val age: Int\\n)\\n\\nval userBody by body<CreateUserRequest>()\\n```\\n\\nThe documentation includes the complete JSON schema with all properties, types, and optional custom descriptions.\\n\\n### 4. Response Types and Status Codes\\n\\nResponse types are inferred from your handler code:\\n\\n```kotlin\\nGET(userId) isHandledBy {\\n    val user = userRepository.findById(request[userId])\\n    if (user != null) user.ok\\n    else \\"User not found\\".notFound()\\n}\\n```\\n\\nThis documents:\\n- 200 OK response with the User schema\\n- 404 Not Found response with a string message\\n\\n### 5. Authorization Requirements\\n\\nSecurity requirements are documented based on your conditions:\\n\\n```kotlin\\nGET(\\"admin/dashboard\\") onlyIf hasAdminRole isHandledBy { getDashboard() }\\n```\\n\\nThe documentation will show that this endpoint requires admin role authorization.\\n\\n## Enhancing the Documentation\\n\\nWhile zero-effort documentation is powerful, Snitch also allows for enhancements:\\n\\n```kotlin\\ndata class User(\\n    @Description(\\"Unique identifier\\") val id: UUID,\\n    @Description(\\"User\'s full name\\") val name: String,\\n    @Description(\\"User\'s email address\\") val email: String,\\n    @Example(\\"true\\") val active: Boolean\\n)\\n\\nval userId by path(\\n    ofUUID,\\n    description = \\"User\'s unique identifier\\",\\n    example = \\"123e4567-e89b-12d3-a456-426614174000\\"\\n)\\n```\\n\\nThese annotations and parameters don\'t affect the functionality but enhance the documentation with additional context and examples.\\n\\n## Documentation as a Living Artifact\\n\\nThe most powerful aspect of Snitch\'s approach is that documentation becomes a living artifact that automatically stays in sync with your code:\\n\\n1. **Add a new endpoint?** It appears in the docs immediately.\\n2. **Change a parameter type?** The documentation updates automatically.\\n3. **Add a new response status?** It\'s reflected in the docs with no extra work.\\n\\nThis ensures your documentation is always complete and accurate, eliminating the \\"documentation drift\\" that plagues many APIs.\\n\\n## Real World Impact\\n\\nThe impact of automatic documentation extends beyond convenience:\\n\\n- **Faster onboarding** for new team members and API consumers\\n- **Reduced support burden** as API behavior is clearly documented\\n- **More consistent APIs** as documentation highlights inconsistencies\\n- **Better developer experience** for API consumers\\n- **Documentation-driven development** becomes effortless\\n\\n## Conclusion\\n\\nSnitch\'s zero-effort documentation approach challenges the conventional wisdom that comprehensive API documentation requires significant additional work. By deriving documentation directly from your code, Snitch ensures your documentation is always complete, accurate, and up-to-date.\\n\\nNext time you\'re manually updating API documentation or adding yet another annotation to describe your endpoints, remember that there\'s an alternative approach where documentation simply happens automatically.\\n\\nGive your API consumers the gift of always-accurate, comprehensive documentation - without spending a minute of your time maintaining it."},{"id":"spring-boot-vs-snitch","metadata":{"permalink":"/blog/spring-boot-vs-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2024-03-09-spring-boot-vs-snitch.md","source":"@site/blog/2024-03-09-spring-boot-vs-snitch.md","title":"Spring Boot vs Snitch: A Comprehensive Comparison for Modern API Development","description":"When choosing a framework for your next API project, the options can be overwhelming. Spring Boot has long been the industry standard for Java-based web services, offering a mature ecosystem and comprehensive feature set. However, Snitch has emerged as a compelling alternative for Kotlin developers seeking a more modern, lightweight approach.","date":"2024-03-09T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Spring Boot","permalink":"/blog/tags/spring-boot","description":"Articles related to the Spring Boot framework"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison","description":"Posts comparing different technologies or approaches"},{"inline":false,"label":"Performance","permalink":"/blog/tags/performance","description":"Articles focusing on application performance and optimization"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Articles related to Java programming language and ecosystem"}],"readingTime":15.095,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"spring-boot-vs-snitch","title":"Spring Boot vs Snitch: A Comprehensive Comparison for Modern API Development","authors":["snitch-team"],"tags":["snitch","spring-boot","comparison","performance","kotlin","java"]},"unlisted":false,"prevItem":{"title":"Never Write API Docs Again: Snitch\'s Zero-Effort Documentation","permalink":"/blog/automatic-api-docs-with-snitch"},"nextItem":{"title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","permalink":"/blog/typesafe-validation-with-snitch"}},"content":"When choosing a framework for your next API project, the options can be overwhelming. Spring Boot has long been the industry standard for Java-based web services, offering a mature ecosystem and comprehensive feature set. However, Snitch has emerged as a compelling alternative for Kotlin developers seeking a more modern, lightweight approach. \\n\\nIn this detailed comparison, we\'ll explore how these two frameworks stack up across several critical dimensions, helping you make an informed decision for your next project.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Background: Two Different Philosophies\\n\\nBefore diving into specific comparisons, it\'s worth understanding the underlying philosophies that drive each framework.\\n\\n**Spring Boot** evolved from the Spring Framework, which was created to address the complexity of Java EE. It embraces the principle of \\"convention over configuration\\" and provides a comprehensive solution for enterprise applications. Spring Boot\'s primary goal is to make it easy to create stand-alone, production-grade applications with minimal setup.\\n\\n**Snitch**, on the other hand, was built from the ground up for Kotlin, focusing on expressivity, type safety, and minimal overhead. Its philosophy centers around creating the most readable and maintainable API for web services, with a strong emphasis on performance and automated documentation. Snitch aims to make the HTTP layer both easy to work with and easy to reason about, without sacrificing power or flexibility.\\n\\nNow, let\'s examine how these philosophical differences manifest in practical ways.\\n\\n## Code Structure and Expressivity\\n\\nHow code is organized and expressed has a profound impact on development speed, maintainability, and onboarding new team members.\\n\\n### Spring Boot Approach\\n\\nSpring Boot relies heavily on annotations to define routes, request mappings, and validation:\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/api/users\\")\\npublic class UserController {\\n    @Autowired\\n    private UserService userService;\\n    \\n    @GetMapping(\\"/{id}\\")\\n    public ResponseEntity<User> getUser(@PathVariable(\\"id\\") @Valid Long id) {\\n        return userService.findById(id)\\n            .map(ResponseEntity::ok)\\n            .orElse(ResponseEntity.notFound().build());\\n    }\\n    \\n    @PostMapping\\n    @PreAuthorize(\\"hasRole(\'ADMIN\')\\")\\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO userDTO) {\\n        User user = userService.create(userDTO);\\n        URI location = ServletUriComponentsBuilder\\n            .fromCurrentRequest()\\n            .path(\\"/{id}\\")\\n            .buildAndExpand(user.getId())\\n            .toUri();\\n        return ResponseEntity.created(location).body(user);\\n    }\\n}\\n```\\n\\n### Snitch Approach\\n\\nSnitch uses a DSL that makes routes and their handlers immediately clear:\\n\\n```kotlin\\nval userId by path(ofLong)\\nval userDTO by body<UserDTO>()\\n\\nval usersRouter = routes {\\n    \\"api\\" / \\"users\\" / {\\n        GET(userId) isHandledBy {\\n            userService.findById(request[userId])?.ok\\n                ?: \\"User not found\\".notFound()\\n        }\\n        \\n        POST() with userDTO onlyIf hasAdminRole isHandledBy {\\n            val user = userService.create(request[userDTO])\\n            user.created\\n        }\\n    }\\n}\\n```\\n\\n### Key Differences\\n\\n1. **Route Hierarchy Visibility**: Snitch\'s nested structure makes the API hierarchy immediately visible, while Spring Boot\'s flat annotation approach can obscure it.\\n\\n2. **Parameter Handling**: Spring Boot mixes parameter declarations with route definitions via annotations, while Snitch separates them, reducing repetition and improving readability.\\n\\n3. **Response Creation**: Snitch provides a concise DSL for creating responses (`user.ok`, `\\"error\\".notFound()`), while Spring Boot requires more verbose `ResponseEntity` creation.\\n\\n4. **Authorization Logic**: Spring Boot uses string expressions in annotations for authorization, while Snitch employs composable conditions with the `onlyIf` keyword.\\n\\n5. **Infix Notation**: Snitch leverages Kotlin\'s infix functions to create a more natural language-like syntax, making the code approachable even to non-developers.\\n\\n## Type Safety and Compile-Time Checks\\n\\nModern development practices emphasize catching errors as early as possible in the development cycle.\\n\\n### Spring Boot Approach\\n\\nSpring Boot provides some compile-time checks through Java\'s type system, but many issues are only caught at runtime:\\n\\n- Incorrect URL path references in `@RequestMapping` aren\'t caught at compile time\\n- Typos in SpEL expressions for authorization aren\'t caught until runtime\\n- Request parameter binding errors are discovered at runtime\\n- Bean injection failures occur at application startup\\n\\nFor example, this Spring Boot code has an error that won\'t be caught until runtime:\\n\\n```java\\n@GetMapping(\\"/{id}\\")\\npublic User getUser(@PathVariable(\\"userId\\") Long id) { // Mismatched path variable name\\n    return userRepository.findById(id)\\n        .orElseThrow(() -> new ResourceNotFoundException(\\"User not found\\"));\\n}\\n```\\n\\n### Snitch Approach\\n\\nSnitch leverages Kotlin\'s type system to catch many errors at compile time:\\n\\n- Path parameters must be defined before use\\n- Parameter types are checked at compile time\\n- Handler access to undefined parameters results in compile errors\\n- Condition composition is type-checked\\n\\nThe equivalent code with a similar error in Snitch would not compile:\\n\\n```kotlin\\nval userId by path(ofLong)\\n\\nGET(id) isHandledBy { // Error: \'id\' is not defined\\n    userRepository.findById(request[userId]) \\n        ?: throw ResourceNotFoundException(\\"User not found\\")\\n}\\n```\\n\\n### Key Differences\\n\\n1. **Parameter Safety**: Snitch ensures all parameters are defined and of the correct type at compile time, while Spring Boot defers many of these checks to runtime.\\n\\n2. **Handler Type Safety**: Snitch handlers can only access defined parameters, providing compile-time safety, while Spring Boot relies on runtime binding.\\n\\n3. **Path Consistency**: Snitch path definitions are checked at compile time, ensuring consistency throughout the codebase.\\n\\n4. **Null Safety**: Kotlin\'s null safety features, fully leveraged by Snitch, provide additional protection against NullPointerExceptions.\\n\\n5. **Exhaustive Pattern Matching**: Snitch can use Kotlin\'s `when` expressions with exhaustive pattern matching for more robust conditional logic.\\n\\n## Performance and Resource Efficiency\\n\\nIn production environments, performance and resource usage are critical considerations.\\n\\n### Spring Boot Metrics\\n\\nSpring Boot is known for:\\n- Higher memory usage due to a large number of dependencies\\n- Longer startup times (often 5-15 seconds for simple applications)\\n- Some runtime overhead from reflection and proxies\\n- Good but not exceptional request throughput\\n- Higher JAR file sizes (typically 15-40MB)\\n\\nFor example, a simple \\"Hello World\\" Spring Boot application:\\n- JAR size: ~18MB\\n- Startup time: ~2-5 seconds\\n- Memory usage: ~350-500MB\\n- Max throughput: ~15-25k requests/second (varies by hardware)\\n\\n### Snitch Metrics\\n\\nSnitch emphasizes lightweight design:\\n- Minimal memory footprint (as low as 12MB RAM on top of JVM)\\n- Fast startup times (typically under 1 second)\\n- Minimal overhead through inline functions and no reflection\\n- High throughput leveraging Undertow\'s performance\\n- Small JAR file sizes (typically 2-5MB)\\n\\nA comparable \\"Hello World\\" Snitch application:\\n- JAR size: ~3MB\\n- Startup time: ~200-500ms\\n- Memory usage: ~80-150MB\\n- Max throughput: ~30-40k requests/second (varies by hardware)\\n\\n### Key Differences\\n\\n1. **Startup Time**: Snitch applications start significantly faster, making them more suitable for serverless and container environments.\\n\\n2. **Memory Usage**: Snitch requires substantially less memory, allowing for higher density in containerized deployments.\\n\\n3. **Throughput**: Snitch\'s minimal overhead translates to higher maximum throughput for comparable endpoints.\\n\\n4. **Cold Starts**: The smaller footprint and faster startup make Snitch better suited for environments with cold starts.\\n\\n5. **Runtime Overhead**: Snitch avoids reflection for request handling, resulting in more consistent performance under load.\\n\\n## Documentation Generation\\n\\nAPI documentation is often an afterthought but can significantly impact adoption and maintenance.\\n\\n### Spring Boot Approach\\n\\nSpring Boot typically relies on external tools like Springfox or SpringDoc to generate OpenAPI documentation:\\n\\n```java\\n@Operation(summary = \\"Get a user by ID\\", description = \\"Returns a user when ID is found\\")\\n@ApiResponses(value = {\\n    @ApiResponse(responseCode = \\"200\\", description = \\"Successful operation\\",\\n                 content = @Content(schema = @Schema(implementation = User.class))),\\n    @ApiResponse(responseCode = \\"404\\", description = \\"User not found\\")\\n})\\n@GetMapping(\\"/{id}\\")\\npublic ResponseEntity<User> getUser(@Parameter(description = \\"ID of user to return\\")\\n                                   @PathVariable Long id) {\\n    // Implementation\\n}\\n```\\n\\nThis approach requires:\\n- Additional dependencies\\n- Extensive annotation use\\n- Manual maintenance to keep docs in sync with code\\n- Extra build steps to generate documentation\\n\\n### Snitch Approach\\n\\nSnitch generates OpenAPI 3.0 documentation automatically from your code:\\n\\n```kotlin\\n// No annotations needed - documentation is derived from code structure\\nval userId by path(ofLong, description = \\"ID of user to return\\")\\n\\nGET(\\"users\\" / userId) isHandledBy {\\n    val user = userRepository.findById(request[userId])\\n    if (user != null) user.ok\\n    else \\"User not found\\".notFound()\\n}\\n```\\n\\nWith Snitch:\\n- Documentation is generated automatically\\n- No annotations required\\n- Docs always stay in sync with code\\n- Interactive Swagger UI available with one line of code\\n\\n```kotlin\\nsnitch(GsonJsonParser)\\n    .onRoutes(routes)\\n    .generateDocumentation()\\n    .servePublicDocumentation()\\n    .start()\\n```\\n\\n### Key Differences\\n\\n1. **Zero-Configuration**: Snitch requires no special annotations or setup for complete documentation.\\n\\n2. **Accuracy**: Snitch\'s documentation is always in sync with code since it\'s derived directly from it.\\n\\n3. **Maintenance Burden**: Spring Boot documentation requires ongoing maintenance to stay accurate, while Snitch\'s updates automatically.\\n\\n4. **Parameter Information**: Snitch documentation includes validation rules automatically based on the validators used.\\n\\n5. **Response Types**: Snitch infers response types from handler return values, making documentation more accurate.\\n\\n## Middleware and Request Processing\\n\\nHow a framework handles cross-cutting concerns like logging, authentication, and error handling significantly impacts code organization.\\n\\n### Spring Boot Approach\\n\\nSpring Boot uses several mechanisms for cross-cutting concerns:\\n\\n- Filters for HTTP request/response manipulation\\n- Interceptors for handler interception\\n- AOP for method interception\\n- `@ControllerAdvice` for global error handling\\n\\n```java\\n@Component\\npublic class RequestLoggingFilter implements Filter {\\n    @Override\\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) \\n            throws IOException, ServletException {\\n        HttpServletRequest req = (HttpServletRequest) request;\\n        log.info(\\"Request: {} {}\\", req.getMethod(), req.getRequestURI());\\n        long startTime = System.currentTimeMillis();\\n        \\n        chain.doFilter(request, response);\\n        \\n        long duration = System.currentTimeMillis() - startTime;\\n        log.info(\\"Response time: {}ms\\", duration);\\n    }\\n}\\n```\\n\\n### Snitch Approach\\n\\nSnitch provides a unified middleware system through decorations:\\n\\n```kotlin\\nval Router.withLogging get() = decorateWith {\\n    logger.info(\\"Begin: ${request.method} ${request.path}\\")\\n    val startTime = System.currentTimeMillis()\\n    \\n    next().also {\\n        val duration = System.currentTimeMillis() - startTime\\n        logger.info(\\"End: ${request.method} ${request.path} ${it.statusCode} (${duration}ms)\\")\\n    }\\n}\\n\\nroutes {\\n    withLogging {\\n        // Routes here\\n    }\\n}\\n```\\n\\nFor before/after actions on specific routes:\\n\\n```kotlin\\nGET(\\"users\\" / userId)\\n    .doBefore { authenticate() }\\n    .doAfter { logAccess() }\\n    .isHandledBy { \\n        // Handler code\\n    }\\n```\\n\\n### Key Differences\\n\\n1. **Unified Model**: Snitch provides a single, consistent model for middleware through decorations and before/after actions, while Spring Boot has multiple mechanisms.\\n\\n2. **Scoping**: Snitch middleware can be applied at different levels of granularity, from global to route-specific.\\n\\n3. **Composition**: Snitch middleware is naturally composable through extension properties and method chaining.\\n\\n4. **Clarity**: The execution flow in Snitch middleware is more explicit and readable than Spring Boot\'s filter chains.\\n\\n5. **Access to Context**: Snitch middleware has full access to the typed request context, including validated parameters.\\n\\n## Authorization and Access Control\\n\\nControlling access to resources is a fundamental requirement for most APIs.\\n\\n### Spring Boot Approach\\n\\nSpring Boot uses Spring Security with annotations and SpEL expressions:\\n\\n```java\\n@PreAuthorize(\\"hasRole(\'ADMIN\') or #userId == authentication.principal.id\\")\\n@GetMapping(\\"/users/{userId}\\")\\npublic User getUser(@PathVariable Long userId) {\\n    return userRepository.findById(userId)\\n        .orElseThrow(() -> new ResourceNotFoundException(\\"User not found\\"));\\n}\\n```\\n\\nThis approach:\\n- Uses string expressions evaluated at runtime\\n- Relies on a global security configuration\\n- Cannot be easily composed for complex rules\\n- Separates authorization logic from route definition\\n\\n### Snitch Approach\\n\\nSnitch uses a condition system with boolean logic:\\n\\n```kotlin\\nval hasAdminRole = condition(\\"hasAdminRole\\") {\\n    when (role) {\\n        ADMIN -> ConditionResult.Successful\\n        else -> ConditionResult.Failed(\\"Not an admin\\".forbidden())\\n    }\\n}\\n\\nval isResourceOwner = condition(\\"isResourceOwner\\") {\\n    if (principal.id == request[userId]) ConditionResult.Successful\\n    else ConditionResult.Failed(\\"Not the resource owner\\".forbidden())\\n}\\n\\nGET(\\"users\\" / userId) onlyIf (isResourceOwner or hasAdminRole) isHandledBy { \\n    getUser() \\n}\\n```\\n\\nThis approach:\\n- Uses type-safe conditions defined in Kotlin\\n- Makes authorization logic directly visible in route definitions\\n- Supports natural boolean composition (`and`, `or`, `not`)\\n- Provides custom error responses for each condition\\n\\n### Key Differences\\n\\n1. **Visibility**: Snitch authorization rules are visible directly in route definitions, while Spring Boot\'s are in annotations separate from the route.\\n\\n2. **Composition**: Snitch conditions can be composed with natural boolean operators, while Spring Boot requires complex SpEL expressions.\\n\\n3. **Type Safety**: Snitch conditions are type-safe Kotlin code, while Spring Boot uses string expressions evaluated at runtime.\\n\\n4. **Granular Error Responses**: Each Snitch condition can provide a specific error response, while Spring Boot typically returns a generic 403 Forbidden.\\n\\n5. **Testing**: Snitch conditions are easier to unit test as regular Kotlin functions.\\n\\n## Validation and Parameter Handling\\n\\nHow a framework handles input validation and parameter binding affects both code safety and developer experience.\\n\\n### Spring Boot Approach\\n\\nSpring Boot uses Bean Validation (JSR-380) with annotations:\\n\\n```java\\npublic class UserDTO {\\n    @NotBlank(message = \\"Name is required\\")\\n    private String name;\\n    \\n    @Email(message = \\"Email should be valid\\")\\n    @NotBlank(message = \\"Email is required\\")\\n    private String email;\\n    \\n    @Min(value = 18, message = \\"Age should be at least 18\\")\\n    private int age;\\n    \\n    // Getters and setters\\n}\\n\\n@PostMapping\\npublic ResponseEntity<User> createUser(@Valid @RequestBody UserDTO userDTO) {\\n    // Implementation\\n}\\n```\\n\\n### Snitch Approach\\n\\nSnitch uses a validator system that combines validation and transformation:\\n\\n```kotlin\\ndata class UserDTO(val name: String, val email: String, val age: Int)\\n\\nval ofUserDTO = validator<String, UserDTO>(\\"valid user data\\") { json ->\\n    val dto = parser.fromJson<UserDTO>(json)\\n    \\n    when {\\n        dto.name.isBlank() -> throw ValidationException(\\"Name is required\\")\\n        !isValidEmail(dto.email) -> throw ValidationException(\\"Email should be valid\\")\\n        dto.age < 18 -> throw ValidationException(\\"Age should be at least 18\\")\\n        else -> dto\\n    }\\n}\\n\\nval userBody by body(ofUserDTO)\\n\\nPOST(\\"users\\") with userBody isHandledBy {\\n    val dto = request[userBody]\\n    // Implementation\\n}\\n```\\n\\n### Key Differences\\n\\n1. **Validation and Transformation**: Snitch validators both validate and transform data, while Spring Boot separates these concerns.\\n\\n2. **Expressiveness**: Snitch validation can use the full power of Kotlin, while Spring Boot is limited to annotation capabilities.\\n\\n3. **Parameter Access**: Snitch provides type-safe access to validated parameters, while Spring Boot binds directly to method parameters.\\n\\n4. **Custom Validation Logic**: Complex validation in Snitch is natural Kotlin code, while Spring Boot requires custom validator classes.\\n\\n5. **Documentation**: Snitch automatically documents validation rules in OpenAPI, while Spring Boot requires additional annotations.\\n\\n## Testing\\n\\nThe ease of testing a framework significantly impacts development speed and code quality.\\n\\n### Spring Boot Approach\\n\\nSpring Boot provides `@SpringBootTest` for integration tests and `MockMvc` for controller tests:\\n\\n```java\\n@SpringBootTest\\n@AutoConfigureMockMvc\\nclass UserControllerTest {\\n    @Autowired\\n    private MockMvc mockMvc;\\n    \\n    @MockBean\\n    private UserService userService;\\n    \\n    @Test\\n    void getUserShouldReturnUser() throws Exception {\\n        User user = new User(1L, \\"Test User\\", \\"test@example.com\\");\\n        when(userService.findById(1L)).thenReturn(Optional.of(user));\\n        \\n        mockMvc.perform(get(\\"/api/users/1\\"))\\n            .andExpect(status().isOk())\\n            .andExpect(jsonPath(\\"$.id\\").value(1))\\n            .andExpect(jsonPath(\\"$.name\\").value(\\"Test User\\"));\\n    }\\n}\\n```\\n\\n### Snitch Approach\\n\\nSnitch provides a concise testing DSL:\\n\\n```kotlin\\nclass UserRoutesTest : SnitchTest({ Application.setup(it) }) {\\n    @Test\\n    fun `get user returns user when found`() {\\n        // Setup\\n        val user = User(1, \\"Test User\\", \\"test@example.com\\")\\n        every { userService.findById(1) } returns user\\n        \\n        // Test\\n        GET(\\"/api/users/1\\")\\n            .expectCode(200)\\n            .expectJsonBody(\\"\\"\\"{\\"id\\":1,\\"name\\":\\"Test User\\",\\"email\\":\\"test@example.com\\"}\\"\\"\\")\\n    }\\n}\\n```\\n\\n### Key Differences\\n\\n1. **Conciseness**: Snitch tests are typically more concise and focused on the HTTP interaction.\\n\\n2. **Setup Complexity**: Spring Boot tests require more configuration and annotation setup.\\n\\n3. **Readability**: Snitch\'s testing DSL closely mirrors the actual HTTP requests clients would make.\\n\\n4. **Performance**: Snitch tests start faster due to the lightweight framework.\\n\\n5. **Integration with Mocking**: Both frameworks work well with mocking libraries, but Snitch\'s explicit dependency injection makes mocking more straightforward.\\n\\n## Extensibility and Customization\\n\\nA framework\'s ability to adapt to unique requirements is essential for long-term viability.\\n\\n### Spring Boot Approach\\n\\nSpring Boot provides several extension points:\\n- Custom auto-configurations\\n- Conditional beans\\n- ApplicationListeners\\n- Custom annotations\\n- Bean post-processors\\n\\nThese mechanisms are powerful but often complex, requiring deep understanding of Spring\'s internals.\\n\\n### Snitch Approach\\n\\nSnitch prioritizes straightforward extension mechanisms:\\n- Extension functions and properties\\n- Lambda composition\\n- DSL builders\\n- Direct access to underlying server\\n\\nFor example, extending the routing DSL:\\n\\n```kotlin\\n// Add a version-specific endpoint\\ninfix fun <T: Any> Endpoint<T>.v(version: Int): Endpoint<T> = \\n    copy(path = path.replace(\\"/v1/\\", \\"/v$version/\\"))\\n\\n// Usage\\nGET(\\"v1/users\\") v 2 isHandledBy { getUsers() }\\n```\\n\\n### Key Differences\\n\\n1. **Learning Curve**: Snitch\'s extension mechanisms leverage standard Kotlin features, while Spring Boot\'s often require framework-specific knowledge.\\n\\n2. **Verbosity**: Extending Snitch typically requires less code than extending Spring Boot.\\n\\n3. **Discoverability**: Snitch extensions appear as normal IDE suggestions due to Kotlin\'s extension functions.\\n\\n4. **Composability**: Snitch extensions naturally compose through standard function composition.\\n\\n5. **Access to Internals**: Snitch provides more direct access to underlying components, avoiding abstraction leaks.\\n\\n## Development Experience\\n\\nThe day-to-day experience of working with a framework significantly impacts developer satisfaction and productivity.\\n\\n### Spring Boot Experience\\n\\nSpring Boot offers:\\n- Mature ecosystem with extensive documentation\\n- Large community and abundant examples\\n- Many IDE plugins and integrations\\n- Spring Initializr for easy project setup\\n- Actuator for production monitoring\\n- But: heavy reliance on annotations and \\"magic\\"\\n- But: long startup times during development\\n- But: complex stack traces and error messages\\n\\n### Snitch Experience\\n\\nSnitch provides:\\n- Concise, readable DSL\\n- Fast startup times for quick feedback\\n- Minimal \\"magic\\" - code does what it looks like\\n- Clear, predictable behavior\\n- Built-in documentation generation\\n- But: smaller community and fewer examples\\n- But: newer framework with evolving API\\n- But: fewer integrations with third-party libraries\\n\\n### Key Differences\\n\\n1. **Feedback Loop**: Snitch\'s fast startup time creates a tighter feedback loop during development.\\n\\n2. **Code Navigation**: In Snitch, \\"go to definition\\" in the IDE shows actual implementation rather than annotations and interfaces.\\n\\n3. **Learning Curve**: Spring Boot has a steeper initial learning curve but more resources available.\\n\\n4. **Error Messages**: Snitch provides more straightforward error messages tied directly to code locations.\\n\\n5. **Readability**: Snitch code tends to be more self-documenting and easier to understand at a glance.\\n\\n## When to Choose Each Framework\\n\\nBased on this comparison, here are some guidelines for choosing between Spring Boot and Snitch:\\n\\n### Choose Spring Boot When:\\n\\n- You\'re working in a Java-centric environment\\n- You need the extensive Spring ecosystem (Spring Data, Spring Security, Spring Cloud)\\n- Your team has significant Spring experience\\n- You require numerous integrations with enterprise systems\\n- You need the mature tooling and extensive community resources\\n- You\'re building a complex enterprise application with many cross-cutting concerns\\n\\n### Choose Snitch When:\\n\\n- You\'re working primarily with Kotlin\\n- You prioritize code readability and expressiveness\\n- Performance and resource efficiency are critical\\n- You want automatic, accurate API documentation\\n- You value compile-time safety and robust type checking\\n- You\'re building services that need to scale both technically and in terms of codebase maintainability\\n- You want a lightweight approach with minimal overhead\\n- You prefer explicit, visible behavior over convention and magic\\n\\n## Conclusion: The Right Tool for Your Context\\n\\nBoth Spring Boot and Snitch are excellent frameworks with different strengths and philosophies. Spring Boot shines in enterprise environments with its comprehensive ecosystem and mature tooling. Snitch excels in modern Kotlin-based projects where expressivity, performance, and type safety are priorities.\\n\\nThe choice ultimately depends on your specific context, team, and requirements. If you\'re starting a new Kotlin project and value clean, maintainable code with excellent performance characteristics, Snitch offers a compelling alternative to the traditional Spring Boot approach.\\n\\nRegardless of which framework you choose, understanding these differences helps you make an informed decision aligned with your project\'s needs and your team\'s preferences. As the industry continues to evolve, we\'re fortunate to have options that cater to different development philosophies and requirements."},{"id":"typesafe-validation-with-snitch","metadata":{"permalink":"/blog/typesafe-validation-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2023-10-17-typesafe-validation-with-snitch.md","source":"@site/blog/2023-10-17-typesafe-validation-with-snitch.md","title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","description":"One of the most common sources of bugs in web applications is improper handling of user input. Traditional frameworks often leave validation as an afterthought, resulting in runtime errors that could have been caught earlier. Snitch takes a different approach, making validation a first-class concern with compile-time safety.","date":"2023-10-17T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Validation","permalink":"/blog/tags/validation","description":"Content about data validation and input processing"},{"inline":false,"label":"Type Safety","permalink":"/blog/tags/type-safety","description":"Articles about type systems and compile-time safety"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"}],"readingTime":3.145,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"typesafe-validation-with-snitch","title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","authors":["snitch-team"],"tags":["snitch","validation","type-safety","kotlin"]},"unlisted":false,"prevItem":{"title":"Spring Boot vs Snitch: A Comprehensive Comparison for Modern API Development","permalink":"/blog/spring-boot-vs-snitch"},"nextItem":{"title":"Expressive Code at Scale: How Snitch Transforms API Development","permalink":"/blog/expressivity-and-scaling-with-snitch"}},"content":"One of the most common sources of bugs in web applications is improper handling of user input. Traditional frameworks often leave validation as an afterthought, resulting in runtime errors that could have been caught earlier. Snitch takes a different approach, making validation a first-class concern with compile-time safety.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem with Traditional Validation\\n\\nMost web frameworks handle validation in ways that delay error detection:\\n\\n1. **Runtime validation** that only fails when code executes\\n2. **String-based configurations** that aren\'t checked by the compiler\\n3. **Separate validation layers** disconnected from handler code\\n4. **Type erasure** that loses information about what\'s being validated\\n\\nThese approaches lead to a familiar pattern: write code, run application, discover validation errors, fix them, repeat. This cycle is not only inefficient but can let bugs slip through to production.\\n\\n## Snitch\'s Type-Safe Validation Approach\\n\\nSnitch addresses these issues through its validator system:\\n\\n```kotlin\\n// Define a domain type\\ndata class UserId(val value: String)\\n\\n// Create a validator that both validates and transforms\\nval ofUserId = validator<String, UserId>(\\n    \\"valid user ID\\",\\n    \\"\\"\\"^[a-zA-Z0-9]{8,12}$\\"\\"\\".toRegex()\\n) {\\n    UserId(it)\\n}\\n\\n// Use it with a parameter\\nval userId by path(ofUserId)\\n\\n// Access the validated parameter\\nval getUser by handling {\\n    val id: UserId = request[userId] // Already validated and transformed\\n    userRepository.findById(id)\\n}\\n```\\n\\nThis approach offers several immediate benefits:\\n\\n1. **Combined validation and transformation** - The validator both checks input and converts it to your domain type\\n2. **Type safety throughout** - Your handler code works with properly typed values, not raw strings\\n3. **Early validation failures** - Invalid inputs are rejected before reaching your business logic\\n4. **Self-documenting code** - The validation requirements are clear from the validator definition\\n\\n## Extending to Complex Validation\\n\\nSnitch\'s validator system scales elegantly to more complex scenarios:\\n\\n```kotlin\\n// Advanced email validator with domain restrictions\\nval ofCorporateEmail = validator<String, Email>(\\n    \\"corporate email address\\",\\n    \\"\\"\\"^[a-zA-Z0-9._%+-]+@company\\\\.com$\\"\\"\\".toRegex()\\n) { \\n    if (!it.endsWith(\\"@company.com\\")) {\\n        throw ValidationException(\\"Must be a company.com email\\")\\n    }\\n    \\n    Email(it)\\n}\\n\\n// Combined validators for a request body\\ndata class SignupRequest(val name: String, val email: String, val age: Int)\\n\\nval ofSignupRequest = bodyValidator<SignupRequest>(\\"valid signup\\") { body ->\\n    // Validate all fields\\n    if (body.name.isEmpty()) throw ValidationException(\\"Name cannot be empty\\")\\n    if (!isValidEmail(body.email)) throw ValidationException(\\"Invalid email format\\")\\n    if (body.age < 18) throw ValidationException(\\"Must be 18 or older\\")\\n    \\n    // Return validated object\\n    body\\n}\\n```\\n\\n## Automatic Error Responses\\n\\nWhen validation fails, Snitch automatically generates appropriate error responses:\\n\\n```\\nHTTP/1.1 400 Bad Request\\nContent-Type: application/json\\n\\n{\\n  \\"error\\": \\"Validation failed\\",\\n  \\"details\\": {\\n    \\"email\\": \\"Invalid email format\\",\\n    \\"age\\": \\"Must be 18 or older\\"\\n  }\\n}\\n```\\n\\nNo need to write custom error handling code for each validator - the framework handles this for you, producing consistent, informative error messages for API consumers.\\n\\n## From Strings to Domain Types\\n\\nPerhaps the most powerful aspect of Snitch\'s validator system is how it bridges the gap between raw HTTP inputs (which are always strings) and your domain model:\\n\\n```kotlin\\n// Transform path parameter strings into domain types\\nval orderId by path(ofOrderId)\\nval status by query(ofOrderStatus)\\n\\nGET(\\"orders\\" / orderId) withQuery status isHandledBy {\\n    // Work with domain types directly\\n    val id: OrderId = request[orderId]\\n    val orderStatus: OrderStatus = request[status]\\n    \\n    orderRepository.findOrder(id, orderStatus)\\n}\\n```\\n\\nThis type-safe approach eliminates an entire category of bugs and makes your code more readable and maintainable.\\n\\n## Conclusion\\n\\nBy making validation type-safe and integrated into the parameter definition process, Snitch transforms what is traditionally a source of runtime errors into compile-time safety. This shift not only catches issues earlier in the development process but also leads to more robust, self-documenting code that\'s easier to maintain and evolve over time.\\n\\nThe next time you find yourself chasing down an \\"Invalid input\\" error in production, remember that with the right framework, that bug could have been caught before your code even compiled."},{"id":"expressivity-and-scaling-with-snitch","metadata":{"permalink":"/blog/expressivity-and-scaling-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2023-05-28-expressivity-and-scaling-with-snitch.md","source":"@site/blog/2023-05-28-expressivity-and-scaling-with-snitch.md","title":"Expressive Code at Scale: How Snitch Transforms API Development","description":"In the world of software development, there\'s a persistent myth that we must choose between code that is pleasant to write and code that scales well technically. Many believe that as systems grow, elegance must give way to verbosity, and expressivity must be sacrificed for safety and performance.","date":"2023-05-28T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Expressivity","permalink":"/blog/tags/expressivity","description":"Articles about expressive code and API design"},{"inline":false,"label":"Code Quality","permalink":"/blog/tags/code-quality","description":"Articles about improving code readability, maintainability, and quality"},{"inline":false,"label":"Scaling","permalink":"/blog/tags/scaling","description":"Content about scaling applications and architecture"},{"inline":false,"label":"DSL","permalink":"/blog/tags/dsl","description":"Articles about Domain Specific Languages and their applications"},{"inline":false,"label":"Type Safety","permalink":"/blog/tags/type-safety","description":"Articles about type systems and compile-time safety"}],"readingTime":8.475,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"expressivity-and-scaling-with-snitch","title":"Expressive Code at Scale: How Snitch Transforms API Development","authors":["snitch-team"],"tags":["snitch","expressivity","code-quality","scaling","dsl","type-safety"]},"unlisted":false,"prevItem":{"title":"Type-Safe Validation: Turning Runtime Errors into Compile-Time Safety","permalink":"/blog/typesafe-validation-with-snitch"},"nextItem":{"title":"Migration Guide: From Spring Boot to Snitch","permalink":"/blog/migrating-from-spring-to-snitch"}},"content":"In the world of software development, there\'s a persistent myth that we must choose between code that is pleasant to write and code that scales well technically. Many believe that as systems grow, elegance must give way to verbosity, and expressivity must be sacrificed for safety and performance.\\n\\nSnitch challenges this false dichotomy by combining the best of both worlds: an incredibly expressive DSL with the rigorous type safety of Kotlin. Let\'s explore why expressivity matters at scale, and how Snitch pushes the boundaries of what\'s possible.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Hidden Costs of Unexpressive Code\\n\\nWhen we talk about \\"scaling\\" software, we usually focus on technical metrics: requests per second, response times, resource utilization. But there\'s another crucial scaling dimension that gets less attention: human scaling.\\n\\n**Human scaling refers to how well your codebase can grow while remaining comprehensible and maintainable by a team of developers.**\\n\\nUnexpressive code creates an enormous tax on human scaling:\\n\\n1. **Cognitive load**: Developers must mentally translate between what the code says and what it means\\n2. **Onboarding friction**: New team members take longer to become productive\\n3. **Maintenance burdens**: Bug fixes and feature additions require more careful analysis\\n4. **Knowledge silos**: Implementation details become specialized knowledge\\n5. **Refactoring hesitancy**: Complex code discourages necessary evolution\\n\\nThese costs compound as systems grow larger, often leading to what\'s colloquially known as \\"technical debt\\" - a debt that\'s paid through slower development cycles, more bugs, and ultimately, competitive disadvantage.\\n\\n## Expressivity\'s Evolution: From Ruby on Rails to Kotlin DSLs\\n\\nThe software industry has long recognized the value of expressive code. Ruby on Rails, which emerged in 2004, built much of its success on prioritizing \\"developer happiness\\" and the principle of convention over configuration.\\n\\n### Ruby on Rails: The Expressivity Pioneer\\n\\nRuby on Rails showed that a framework could be both powerful and a joy to use:\\n\\n```ruby\\nclass UsersController < ApplicationController\\n  before_action :require_login\\n  \\n  def index\\n    @users = User.all\\n  end\\n  \\n  def show\\n    @user = User.find(params[:id])\\n  end\\nend\\n```\\n\\nThis code is remarkably readable - almost English-like in its clarity. But as Rails applications grew, they often encountered challenges:\\n\\n1. **Runtime errors**: The lack of compile-time type checking meant many errors weren\'t caught until execution\\n2. **Performance challenges**: The very features that made Rails expressive often came with performance costs\\n3. **Magic**: Rails\' \\"convention over configuration\\" sometimes felt like \\"magic\\" that was hard to debug\\n4. **Testing burden**: Without type checks, comprehensive test coverage became absolutely essential\\n\\n### The Rise of Typed Functional Languages\\n\\nThe pendulum then swung in the other direction. Languages like Scala, Haskell, and later TypeScript gained popularity partly as a reaction to the perceived \\"unsafety\\" of dynamic languages like Ruby.\\n\\nConsider this Scala example using the Play Framework:\\n\\n```scala\\ndef getUser(id: Long) = Action { \\n  userRepository.findById(id) match {\\n    case Some(user) => Ok(Json.toJson(user))\\n    case None => NotFound(\\"User not found\\")\\n  }\\n}\\n```\\n\\nThis code benefits from strong typing and pattern matching, but loses some of the immediate readability that made Rails so appealing.\\n\\n## The Best of Both Worlds: Kotlin DSLs\\n\\nKotlin emerged as a language that could provide the safety of static typing with the expressiveness of a modern language. Its support for DSLs (Domain Specific Languages) opened up new possibilities for frameworks.\\n\\nHere\'s a simple example using Kotlin\'s built-in HTML DSL:\\n\\n```kotlin\\nhtml {\\n    head {\\n        title(\\"My Page\\")\\n    }\\n    body {\\n        h1 { +\\"Welcome\\" }\\n        p { +\\"This is a paragraph\\" }\\n    }\\n}\\n```\\n\\nThis code is both expressive and type-safe. Errors like misspelling a tag name or using the wrong nesting structure would be caught at compile time.\\n\\n## Snitch: Pushing the Boundaries of Expressive, Type-Safe Code\\n\\nSnitch takes the concept of expressive, type-safe DSLs to a new level for HTTP APIs. Let\'s compare a typical REST endpoint in some popular frameworks to see the evolution:\\n\\n### Spring Boot (Java)\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/api/users\\")\\npublic class UserController {\\n    @Autowired\\n    private UserRepository userRepository;\\n    \\n    @GetMapping(\\"/{id}\\")\\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\\n        return userRepository.findById(id)\\n            .map(user -> ResponseEntity.ok(user))\\n            .orElse(ResponseEntity.notFound().build());\\n    }\\n    \\n    @PostMapping\\n    @PreAuthorize(\\"hasRole(\'ADMIN\')\\")\\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO userDTO) {\\n        User user = new User(userDTO.getName(), userDTO.getEmail());\\n        User savedUser = userRepository.save(user);\\n        return ResponseEntity.created(URI.create(\\"/api/users/\\" + savedUser.getId()))\\n            .body(savedUser);\\n    }\\n}\\n```\\n\\n### Ktor (Kotlin)\\n\\n```kotlin\\nrouting {\\n    route(\\"/api/users\\") {\\n        get(\\"/{id}\\") {\\n            val id = call.parameters[\\"id\\"]?.toLongOrNull()\\n            if (id == null) {\\n                call.respond(HttpStatusCode.BadRequest, \\"Invalid ID format\\")\\n                return@get\\n            }\\n            \\n            val user = userRepository.findById(id)\\n            if (user != null) {\\n                call.respond(user)\\n            } else {\\n                call.respond(HttpStatusCode.NotFound, \\"User not found\\")\\n            }\\n        }\\n        \\n        authenticate {\\n            post {\\n                val userDTO = call.receive<UserDTO>()\\n                if (!isAdmin(call.principal)) {\\n                    call.respond(HttpStatusCode.Forbidden)\\n                    return@post\\n                }\\n                \\n                val user = User(userDTO.name, userDTO.email)\\n                val savedUser = userRepository.save(user)\\n                call.respond(HttpStatusCode.Created, savedUser)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n### Snitch (Kotlin)\\n\\n```kotlin\\nval userId by path(ofLong)\\nval userDTO by body<UserDTO>()\\n\\nval usersRouter = routes {\\n    \\"api\\" / \\"users\\" / {\\n        GET(userId) isHandledBy {\\n            userRepository.findById(request[userId])\\n                ?.ok\\n                ?: \\"User not found\\".notFound()\\n        }\\n        \\n        POST() with userDTO onlyIf hasAdminRole isHandledBy {\\n            val user = User(request[userDTO].name, request[userDTO].email)\\n            val savedUser = userRepository.save(user)\\n            savedUser.created\\n        }\\n    }\\n}\\n```\\n\\nSnitch\'s approach offers several distinctive advantages for expressivity while maintaining type safety:\\n\\n1. **Declarative path definition**: Routes are defined hierarchically and read naturally from left to right\\n2. **Parameter declaration separation**: Parameters are defined once and reused, reducing repetition\\n3. **Infix notation**: `isHandledBy`, `with`, and `onlyIf` create an almost English-like readability\\n4. **Result DSL**: `.ok`, `.notFound()`, and `.created` make response codes clear and concise\\n5. **Type safety throughout**: From parameter parsing to handler execution, everything is type-checked\\n6. **No annotations**: Logic flows naturally without being broken up by annotations\\n7. **Composability**: Routes can be modularized and composed easily\\n\\n## Expressivity and Scaling: An Unexpected Synergy\\n\\nHere\'s where Snitch truly shines - as your API grows more complex, Snitch\'s expressivity becomes even more valuable, not less.\\n\\nConsider a more complex API with nested resources, multiple role-based permissions, and sophisticated validation:\\n\\n```kotlin\\nval userId by path(ofLong)\\nval postId by path(ofLong)\\nval commentId by path(ofLong)\\nval limit by query(ofIntRange(1, 100), default = 20)\\nval offset by query(ofNonNegativeInt, default = 0)\\nval postBody by body<CreatePostRequest>()\\nval commentBody by body<CreateCommentRequest>()\\n\\nval apiRoutes = routes {\\n    \\"api\\" / \\"v1\\" / {\\n        \\"users\\" / userId / {\\n            GET() onlyIf (isResourceOwner(userId) or hasAdminRole) isHandledBy { \\n                getUserProfile() \\n            }\\n            \\n            \\"posts\\" / {\\n                GET() withQueries(limit, offset) isHandledBy { \\n                    getUserPosts() \\n                }\\n                \\n                POST() with postBody onlyIf isResourceOwner(userId) isHandledBy { \\n                    createPost() \\n                }\\n                \\n                postId / {\\n                    GET() isHandledBy { \\n                        getPost() \\n                    }\\n                    \\n                    PUT() with postBody onlyIf (\\n                        isResourceOwner(userId) and isPostOwner(postId)\\n                    ) isHandledBy { \\n                        updatePost() \\n                    }\\n                    \\n                    \\"comments\\" / {\\n                        GET() withQueries(limit, offset) isHandledBy { \\n                            getPostComments() \\n                        }\\n                        \\n                        POST() with commentBody onlyIf isAuthenticated isHandledBy {\\n                            createComment() \\n                        }\\n                        \\n                        commentId / {\\n                            DELETE() onlyIf (\\n                                isCommentAuthor(commentId) or \\n                                isPostOwner(postId) or \\n                                hasModeratorRole\\n                            ) isHandledBy { \\n                                deleteComment() \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nDespite the complexity of this API, the code remains remarkably readable. You can trace the URL structure visually through the nesting, see the HTTP methods at a glance, and understand the authorization rules directly in the route definitions.\\n\\nThis is where the true value proposition of Snitch emerges: **as complexity increases, the code doesn\'t degrade into an unreadable mess - it maintains its clarity and expressiveness.**\\n\\n## The Unfair Advantage: Type Safety + Expressivity\\n\\nMost frameworks force you to choose between expressivity and type safety. Snitch gives you both, creating what we might call an \\"unfair advantage\\" in three key areas:\\n\\n### 1. Error Prevention\\n\\nTraditional expressive frameworks like Rails and Express catch errors at runtime. Snitch catches them at compile time:\\n\\n```kotlin\\n// This would not compile - userId is not defined\\nGET(userId) isHandledBy { getUserProfile() }\\n\\n// This would not compile - wrong parameter type\\nval userId by path(ofString)\\nuserRepository.findById(request[userId].toLong()) // Type mismatch\\n\\n// This would not compile - missing required parameter\\nPOST() isHandledBy { createUser() } // Body parameter missing\\n```\\n\\n### 2. Refactoring Confidence\\n\\nWhen you need to refactor a large API, type safety is invaluable:\\n\\n```kotlin\\n// Rename a parameter\\nval oldUserId by path(ofLong) // Deprecated\\nval userId by path(ofLong) // New name\\n\\n// The compiler will flag every place oldUserId is used\\n```\\n\\n### 3. Self-Documenting Code\\n\\nSnitch\'s expressive DSL makes the code itself excellent documentation:\\n\\n```kotlin\\n// The route structure visually represents the URL hierarchy\\n// HTTP methods are capitalized and stand out\\n// Parameters are clearly defined\\n// Authorization rules are spelled out in the route definition\\n```\\n\\nAnd because Snitch automatically generates OpenAPI documentation from this code, your API docs are always in sync with the implementation.\\n\\n## Industry Impact: Changing How We Think About API Development\\n\\nThe combination of expressivity and type safety in Snitch has potential implications for the entire field of API development:\\n\\n1. **Reduced testing burden**: With many errors caught at compile time, tests can focus on business logic rather than basic type checking\\n2. **Improved developer experience**: Frameworks that prioritize both safety and expressivity will set a new standard for developer experience\\n3. **More maintainable codebases**: As projects age, the value of self-documenting, type-safe code increases dramatically\\n4. **Faster onboarding**: New team members can understand the API structure more quickly and make contributions with greater confidence\\n5. **Higher quality APIs**: By making good practices the easy path, frameworks like Snitch nudge developers toward better API design\\n\\n## Conclusion: Expressivity as a Competitive Advantage\\n\\nIn the early days of web development, expressivity was often seen as a nice-to-have feature - something that made developers happy but didn\'t necessarily contribute to business outcomes. Today, we understand that expressive, maintainable code is a genuine competitive advantage:\\n\\n- It allows teams to respond more quickly to changing requirements\\n- It reduces bugs and security vulnerabilities\\n- It makes it easier to attract and retain talented developers\\n- It lowers the long-term cost of maintenance\\n\\nSnitch demonstrates that expressivity and type safety are not opposing forces but complementary strengths. By bringing them together in a cohesive framework, Snitch offers a glimpse of the future of API development - one where we no longer have to choose between code that is a joy to write and code that scales robustly.\\n\\nAs the complexity of our systems continues to grow, frameworks that help us manage that complexity without sacrificing readability will become increasingly valuable. Snitch isn\'t just a more pleasant way to build APIs - it\'s a more sustainable approach to software development in an increasingly complex world."},{"id":"migrating-from-spring-to-snitch","metadata":{"permalink":"/blog/migrating-from-spring-to-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2022-12-10-migrating-from-spring-to-snitch.md","source":"@site/blog/2022-12-10-migrating-from-spring-to-snitch.md","title":"Migration Guide: From Spring Boot to Snitch","description":"Many teams working with Kotlin find themselves using Spring Boot because it\'s the industry standard for Java applications. But as projects grow, they often encounter limitations with Spring\'s Java-centric approach when used with Kotlin. If you\'re considering migrating from Spring Boot to Snitch, this guide will help you navigate the transition with practical examples and a step-by-step approach.","date":"2022-12-10T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Spring Boot","permalink":"/blog/tags/spring-boot","description":"Articles related to the Spring Boot framework"},{"inline":false,"label":"Migration","permalink":"/blog/tags/migration","description":"Content about migrating between different frameworks or technologies"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"}],"readingTime":6.19,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"migrating-from-spring-to-snitch","title":"Migration Guide: From Spring Boot to Snitch","authors":["snitch-team"],"tags":["snitch","spring-boot","migration","kotlin"]},"unlisted":false,"prevItem":{"title":"Expressive Code at Scale: How Snitch Transforms API Development","permalink":"/blog/expressivity-and-scaling-with-snitch"},"nextItem":{"title":"The Inspiration Behind Snitch - Borrowing from the Best","permalink":"/blog/the-inspiration-behind-snitch"}},"content":"Many teams working with Kotlin find themselves using Spring Boot because it\'s the industry standard for Java applications. But as projects grow, they often encounter limitations with Spring\'s Java-centric approach when used with Kotlin. If you\'re considering migrating from Spring Boot to Snitch, this guide will help you navigate the transition with practical examples and a step-by-step approach.\\n\\n\x3c!-- truncate --\x3e\\n\\n## When to Consider Migration\\n\\nBefore diving into the how, let\'s address the when. Consider migrating from Spring Boot to Snitch if:\\n\\n- You\'re primarily using Kotlin and want to leverage its features more effectively\\n- Your team struggles with Spring\'s annotation-heavy approach and \\"magic\\"\\n- You need better performance, particularly startup time and memory usage\\n- You want stronger compile-time guarantees and fewer runtime surprises\\n- Your documentation is constantly out of sync with your code\\n\\n## Migration Strategy: Incremental Approach\\n\\nThe safest way to migrate is incrementally, especially for larger applications. Here\'s a proven strategy:\\n\\n1. **Start with new endpoints** - Implement new functionality in Snitch\\n2. **Use the adapter pattern** - Create Snitch routes that delegate to existing Spring services\\n3. **Migrate endpoints in groups** - Move related endpoints together\\n4. **Replace cross-cutting concerns** - Migrate authentication, logging, etc.\\n5. **Eliminate Spring dependencies** - Finally remove Spring Boot completely\\n\\nLet\'s look at how this works in practice.\\n\\n## Converting REST Controllers to Snitch Routes\\n\\nThe most direct migration path is converting Spring controllers to Snitch routes.\\n\\n### Spring Boot Controller:\\n\\n```kotlin\\n@RestController\\n@RequestMapping(\\"/api/users\\")\\nclass UserController(private val userService: UserService) {\\n    \\n    @GetMapping\\n    fun getAllUsers(\\n        @RequestParam(defaultValue = \\"0\\") page: Int,\\n        @RequestParam(defaultValue = \\"20\\") size: Int\\n    ): ResponseEntity<List<User>> {\\n        val users = userService.findAll(page, size)\\n        return ResponseEntity.ok(users)\\n    }\\n    \\n    @GetMapping(\\"/{id}\\")\\n    fun getUserById(@PathVariable id: Long): ResponseEntity<User> {\\n        return userService.findById(id)\\n            .map { ResponseEntity.ok(it) }\\n            .orElse(ResponseEntity.notFound().build())\\n    }\\n    \\n    @PostMapping\\n    fun createUser(@RequestBody @Valid user: CreateUserRequest): ResponseEntity<User> {\\n        val created = userService.create(user)\\n        return ResponseEntity\\n            .created(URI.create(\\"/api/users/${created.id}\\"))\\n            .body(created)\\n    }\\n}\\n```\\n\\n### Equivalent Snitch Routes:\\n\\n```kotlin\\n// Define parameters\\nval page by query(ofNonNegativeInt, default = 0)\\nval size by query(ofIntRange(1, 100), default = 20)\\nval userId by path(ofLong)\\nval createUserRequest by body<CreateUserRequest>()\\n\\n// Define routes\\nval userRoutes = routes {\\n    \\"api\\" / \\"users\\" / {\\n        GET() withQueries(page, size) isHandledBy {\\n            val users = userService.findAll(request[page], request[size])\\n            users.ok\\n        }\\n        \\n        GET(userId) isHandledBy {\\n            userService.findById(request[userId])\\n                ?.ok\\n                ?: \\"User not found\\".notFound()\\n        }\\n        \\n        POST() with createUserRequest isHandledBy {\\n            val user = userService.create(request[createUserRequest])\\n            user.created\\n        }\\n    }\\n}\\n```\\n\\n## Migrating Spring Security to Snitch Conditions\\n\\nAuthentication and authorization are critical concerns. Here\'s how to migrate from Spring Security:\\n\\n### Spring Boot Security:\\n\\n```kotlin\\n@Configuration\\n@EnableWebSecurity\\nclass SecurityConfig : WebSecurityConfigurerAdapter() {\\n    override fun configure(http: HttpSecurity) {\\n        http.authorizeRequests()\\n            .antMatchers(\\"/api/public/**\\").permitAll()\\n            .antMatchers(\\"/api/admin/**\\").hasRole(\\"ADMIN\\")\\n            .anyRequest().authenticated()\\n            .and()\\n            .oauth2ResourceServer().jwt()\\n    }\\n}\\n\\n@RestController\\n@RequestMapping(\\"/api/admin\\")\\nclass AdminController {\\n    @GetMapping(\\"/dashboard\\")\\n    @PreAuthorize(\\"hasRole(\'ADMIN\')\\")\\n    fun getDashboard(): ResponseEntity<Dashboard> {\\n        // Implementation\\n    }\\n}\\n```\\n\\n### Equivalent Snitch Implementation:\\n\\n```kotlin\\n// Authentication middleware\\nval Router.authenticated get() = decorateWith {\\n    val auth = request.headerParams(\\"Authorization\\").firstOrNull()\\n    if (auth == null || !auth.startsWith(\\"Bearer \\")) {\\n        return@decorateWith \\"Unauthorized\\".unauthorized()\\n    }\\n    \\n    val token = auth.substring(7)\\n    val claims = jwtVerifier.verify(token)\\n    \\n    // Store in request attributes for later use\\n    request.attributes[\\"user\\"] = User.fromClaims(claims)\\n    next()\\n}\\n\\n// Role-based conditions\\nval hasAdminRole = condition(\\"hasAdminRole\\") {\\n    val user = request.attributes[\\"user\\"] as? User\\n    if (user?.roles?.contains(\\"ADMIN\\") == true) {\\n        ConditionResult.Successful\\n    } else {\\n        ConditionResult.Failed(\\"Admin role required\\".forbidden())\\n    }\\n}\\n\\n// Routes with authentication and authorization\\nval adminRoutes = routes {\\n    authenticated {\\n        \\"api\\" / \\"admin\\" / {\\n            \\"dashboard\\" / {\\n                GET() onlyIf hasAdminRole isHandledBy {\\n                    // Implementation\\n                    dashboardService.getDashboard().ok\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\"api\\" / \\"public\\" / {\\n        // Public routes don\'t need authentication\\n        GET(\\"health\\") isHandledBy { \\"OK\\".ok }\\n    }\\n}\\n```\\n\\n## Migrating Validation Logic\\n\\nSpring\'s validation relies heavily on Bean Validation annotations. Here\'s how to migrate to Snitch\'s validator system:\\n\\n### Spring Boot Validation:\\n\\n```kotlin\\ndata class CreateUserRequest(\\n    @field:NotBlank(message = \\"Name is required\\")\\n    val name: String,\\n    \\n    @field:Email(message = \\"Valid email is required\\")\\n    @field:NotBlank(message = \\"Email is required\\")\\n    val email: String,\\n    \\n    @field:Min(value = 18, message = \\"Age must be at least 18\\")\\n    val age: Int\\n)\\n\\n@PostMapping\\nfun createUser(@RequestBody @Valid request: CreateUserRequest): ResponseEntity<User> {\\n    // Implementation\\n}\\n```\\n\\n### Equivalent Snitch Validation:\\n\\n```kotlin\\ndata class CreateUserRequest(\\n    val name: String,\\n    val email: String,\\n    val age: Int\\n)\\n\\nval ofCreateUserRequest = bodyValidator<CreateUserRequest>(\\"valid user request\\") { request ->\\n    when {\\n        request.name.isBlank() -> throw ValidationException(\\"Name is required\\")\\n        !isValidEmail(request.email) -> throw ValidationException(\\"Valid email is required\\")\\n        request.age < 18 -> throw ValidationException(\\"Age must be at least 18\\")\\n        else -> request\\n    }\\n}\\n\\nval createUserReq by body(ofCreateUserRequest)\\n\\nPOST(\\"users\\") with createUserReq isHandledBy {\\n    // Implementation with validated request\\n    val validatedRequest = request[createUserReq]\\n    userService.create(validatedRequest).created\\n}\\n```\\n\\n## Migrating Exception Handling\\n\\nSpring\'s `@ExceptionHandler` and `@ControllerAdvice` can be migrated to Snitch\'s exception handling:\\n\\n### Spring Boot Exception Handling:\\n\\n```kotlin\\n@ControllerAdvice\\nclass GlobalExceptionHandler {\\n    \\n    @ExceptionHandler(ResourceNotFoundException::class)\\n    fun handleResourceNotFound(ex: ResourceNotFoundException): ResponseEntity<ErrorResponse> {\\n        return ResponseEntity\\n            .status(HttpStatus.NOT_FOUND)\\n            .body(ErrorResponse(ex.message ?: \\"Resource not found\\"))\\n    }\\n    \\n    @ExceptionHandler(ValidationException::class)\\n    fun handleValidation(ex: ValidationException): ResponseEntity<ErrorResponse> {\\n        return ResponseEntity\\n            .status(HttpStatus.BAD_REQUEST)\\n            .body(ErrorResponse(ex.message ?: \\"Validation failed\\"))\\n    }\\n}\\n```\\n\\n### Equivalent Snitch Exception Handling:\\n\\n```kotlin\\nsnitch(GsonJsonParser)\\n    .onRoutes(routes)\\n    .handleException(ResourceNotFoundException::class) { ex ->\\n        ErrorResponse(ex.message ?: \\"Resource not found\\").notFound()\\n    }\\n    .handleException(ValidationException::class) { ex ->\\n        ErrorResponse(ex.message ?: \\"Validation failed\\").badRequest()\\n    }\\n    .start()\\n```\\n\\n## Adapting Spring Services\\n\\nDuring migration, you\'ll likely keep using Spring services for a while. Here\'s how to bridge the gap:\\n\\n```kotlin\\n// Existing Spring service\\n@Service\\nclass UserServiceImpl(private val userRepository: UserRepository) : UserService {\\n    // Implementation\\n}\\n\\n// Snitch route using Spring service\\nval springUserService = springContext.getBean(UserService::class.java)\\n\\nval userRoutes = routes {\\n    \\"api\\" / \\"users\\" / {\\n        GET(userId) isHandledBy {\\n            // Use Spring service from Snitch handler\\n            springUserService.findById(request[userId])\\n                ?.ok\\n                ?: \\"User not found\\".notFound()\\n        }\\n    }\\n}\\n```\\n\\n## Configuration Migration\\n\\nReplace Spring\'s property-based configuration with Snitch\'s configuration:\\n\\n### Spring Boot Configuration:\\n\\n```kotlin\\n@Configuration\\n@ConfigurationProperties(prefix = \\"app\\")\\ndata class AppConfig(\\n    var apiKey: String = \\"\\",\\n    var maxConnections: Int = 10,\\n    var timeoutSeconds: Int = 30\\n)\\n\\n@RestController\\nclass ConfiguredController(private val appConfig: AppConfig) {\\n    // Use configuration\\n}\\n```\\n\\n### Equivalent Snitch Configuration:\\n\\n```kotlin\\ndata class AppConfig(\\n    val apiKey: String,\\n    val maxConnections: Int,\\n    val timeoutSeconds: Int\\n)\\n\\nval config = ConfigFactory.load()\\nval appConfig = AppConfig(\\n    apiKey = config.getString(\\"app.apiKey\\"),\\n    maxConnections = config.getInt(\\"app.maxConnections\\"),\\n    timeoutSeconds = config.getInt(\\"app.timeoutSeconds\\")\\n)\\n\\nval configuredRoutes = routes {\\n    // Use configuration\\n}\\n```\\n\\n## Testing Approach\\n\\nMigrate from Spring Boot testing to Snitch\'s testing DSL:\\n\\n### Spring Boot Test:\\n\\n```kotlin\\n@SpringBootTest\\n@AutoConfigureMockMvc\\nclass UserControllerTest {\\n    \\n    @Autowired\\n    private lateinit var mockMvc: MockMvc\\n    \\n    @MockBean\\n    private lateinit var userService: UserService\\n    \\n    @Test\\n    fun `should return user when found`() {\\n        // Given\\n        val user = User(1, \\"Test User\\", \\"test@example.com\\")\\n        whenever(userService.findById(1)).thenReturn(Optional.of(user))\\n        \\n        // When/Then\\n        mockMvc.perform(get(\\"/api/users/1\\"))\\n            .andExpect(status().isOk)\\n            .andExpect(jsonPath(\\"$.name\\").value(\\"Test User\\"))\\n    }\\n}\\n```\\n\\n### Equivalent Snitch Test:\\n\\n```kotlin\\nclass UserRoutesTest : SnitchTest(/* configure app */) {\\n    \\n    private val userService = mockk<UserService>()\\n    \\n    init {\\n        // Wire up the mock service\\n        registerRoutes(createUserRoutes(userService))\\n    }\\n    \\n    @Test\\n    fun `should return user when found`() {\\n        // Given\\n        val user = User(1, \\"Test User\\", \\"test@example.com\\")\\n        every { userService.findById(1) } returns user\\n        \\n        // When/Then\\n        GET(\\"/api/users/1\\")\\n            .expectCode(200)\\n            .expectJson {\\n                it.path(\\"name\\").asText() shouldBe \\"Test User\\"\\n            }\\n    }\\n}\\n```\\n\\n## Conclusion: Embracing Idioms Over Conventions\\n\\nMigrating from Spring Boot to Snitch is fundamentally about shifting from a convention-based approach to an idiomatic Kotlin approach. While Spring Boot hides complexity through conventions, Snitch makes behavior explicit through an expressive DSL.\\n\\nThe migration process requires rethinking how your application is structured, but the rewards are substantial:\\n- More readable, maintainable code\\n- Stronger compile-time guarantees\\n- Better performance characteristics\\n- Automated documentation that stays in sync\\n- A more natural Kotlin development experience\\n\\nBy following an incremental approach and leveraging the patterns outlined above, you can successfully transition even large applications from Spring Boot to Snitch, unlocking the full potential of Kotlin for your web services."},{"id":"the-inspiration-behind-snitch","metadata":{"permalink":"/blog/the-inspiration-behind-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2022-07-12-the-inspiration-behind-snitch.md","source":"@site/blog/2022-07-12-the-inspiration-behind-snitch.md","title":"The Inspiration Behind Snitch - Borrowing from the Best","description":"Creating a new web framework isn\'t a decision to take lightly. The ecosystem is already crowded with options across many languages, each with their strengths and devoted communities. So when we built Snitch, we didn\'t start from scratch - instead, we carefully studied what worked well in other frameworks and what didn\'t, then synthesized those lessons into something new that addresses the specific needs of Kotlin developers.","date":"2022-07-12T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Web Development","permalink":"/blog/tags/web-development","description":"Articles related to web development technologies and approaches"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"},{"inline":false,"label":"Inspiration","permalink":"/blog/tags/inspiration","description":"Posts discussing inspiration and influences in software design"},{"inline":false,"label":"Frameworks","permalink":"/blog/tags/frameworks","description":"Content comparing and discussing various software frameworks"}],"readingTime":7.435,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"the-inspiration-behind-snitch","title":"The Inspiration Behind Snitch - Borrowing from the Best","authors":["snitch-team"],"tags":["snitch","web-development","kotlin","inspiration","frameworks"]},"unlisted":false,"prevItem":{"title":"Migration Guide: From Spring Boot to Snitch","permalink":"/blog/migrating-from-spring-to-snitch"},"nextItem":{"title":"Unlocking Advanced Web APIs with Snitch","permalink":"/blog/unlocking-advanced-web-apis-with-snitch"}},"content":"Creating a new web framework isn\'t a decision to take lightly. The ecosystem is already crowded with options across many languages, each with their strengths and devoted communities. So when we built Snitch, we didn\'t start from scratch - instead, we carefully studied what worked well in other frameworks and what didn\'t, then synthesized those lessons into something new that addresses the specific needs of Kotlin developers.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn this post, I\'ll walk through the frameworks and libraries that inspired key aspects of Snitch, and how we adapted those ideas into a cohesive whole that leverages Kotlin\'s strengths.\\n\\n## Expressive Routing: Learning from Sinatra and Express\\n\\nSnitch\'s routing DSL draws significant inspiration from Ruby\'s Sinatra and JavaScript\'s Express frameworks, both known for their clean, readable route definitions:\\n\\n**Sinatra (Ruby):**\\n```ruby\\nget \'/hello/:name\' do\\n  \\"Hello #{params[:name]}!\\"\\nend\\n```\\n\\n**Express (JavaScript):**\\n```javascript\\napp.get(\'/hello/:name\', (req, res) => {\\n  res.send(`Hello ${req.params.name}!`);\\n});\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nGET(\\"hello\\" / name) isHandledBy {\\n  \\"Hello ${request[name]}!\\".ok\\n}\\n```\\n\\nWhile these approaches appear similar, Snitch adds several meaningful improvements:\\n\\n1. **Type safety**: Sinatra and Express both use dynamic string parameters, while Snitch parameters are explicitly defined with types\\n2. **Hierarchical routing**: Snitch\'s route nesting approach makes complex API hierarchies much more readable\\n3. **Infix notation**: The `isHandledBy` infix function makes the route-to-handler relationship exceptionally clear\\n\\nThe nested routing approach was also influenced by the excellent Ktor framework, but with a focus on more explicit parameter handling.\\n\\n## Middleware Inspiration: Express and Ktor\\n\\nThe middleware pattern in Snitch draws inspiration from both Express and Ktor, but with a Kotlin-specific twist.\\n\\n**Express (JavaScript):**\\n```javascript\\nconst logMiddleware = (req, res, next) => {\\n  console.log(`${req.method} ${req.path}`);\\n  next();\\n  console.log(\'Request completed\');\\n};\\n\\napp.use(logMiddleware);\\n```\\n\\n**Ktor (Kotlin):**\\n```kotlin\\ninstall(CallLogging) {\\n  level = Level.INFO\\n}\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nval Router.log get() = decorateWith {\\n  logger.info(\\"Begin: ${request.method} ${request.path}\\")\\n  next().also {\\n    logger.info(\\"End: ${request.method} ${request.path}\\")\\n  }\\n}\\n\\nroutes {\\n  log {\\n    // Routes here\\n  }\\n}\\n```\\n\\nWhile Express\'s approach is very flexible, it relies on side effects and mutation. Ktor\'s approach is more declarative but sometimes less flexible. Snitch strikes a balance:\\n\\n1. **Composition over configuration**: Like Express, middleware can be composed easily\\n2. **Extension properties**: Using Kotlin\'s extension properties creates an intuitive DSL\\n3. **Functional approach**: The `next()` function creates a clean flow control similar to Express but with proper lexical scoping\\n4. **Immutable approaches**: No shared mutable state between middlewares\\n\\n## Before/After Actions: Rails and AspectJ\\n\\nThe before/after action system in Snitch was inspired by Ruby on Rails\' filters and AspectJ\'s aspect-oriented programming concepts.\\n\\n**Rails (Ruby):**\\n```ruby\\nclass UsersController < ApplicationController\\n  before_action :authenticate_user\\n  after_action :log_activity\\n  \\n  def show\\n    @user = User.find(params[:id])\\n  end\\nend\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nGET(\\"users\\" / userId)\\n  .doBefore { authenticate() }\\n  .doAfter { logActivity() }\\n  .isHandledBy {\\n    userRepository.findUser(request[userId]).ok\\n  }\\n```\\n\\nThe key improvements in Snitch\'s implementation:\\n\\n1. **Route-specific actions**: Actions can be applied at the individual route level, not just controller-wide\\n2. **Method chaining**: Clean, fluent API compared to Rails\' class-level declarations\\n3. **Type safety**: Full access to request parameters in a type-safe manner\\n4. **Explicit ordering**: The execution order is clearly visible in the code\\n\\n## Validator System: Inspired by Play Framework and Joi\\n\\nSnitch\'s validator system combines ideas from Play Framework\'s form binding and JavaScript\'s Joi validation library.\\n\\n**Play Framework (Scala):**\\n```scala\\ncase class User(name: String, age: Int)\\n\\nval userForm = Form(\\n  mapping(\\n    \\"name\\" -> nonEmptyText,\\n    \\"age\\" -> number(min = 0, max = 120)\\n  )(User.apply)(User.unapply)\\n)\\n```\\n\\n**Joi (JavaScript):**\\n```javascript\\nconst schema = Joi.object({\\n  name: Joi.string().required(),\\n  age: Joi.number().min(0).max(120).required()\\n});\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\ndata class User(val name: String, val age: Int)\\n\\nval ofUser = validator<Map<String, String>, User> { map ->\\n  val name = map[\\"name\\"] ?: throw ValidationException(\\"Name required\\")\\n  val ageStr = map[\\"age\\"] ?: throw ValidationException(\\"Age required\\")\\n  val age = ageStr.toIntOrNull() ?: throw ValidationException(\\"Age must be a number\\")\\n  \\n  if (age < 0 || age > 120) throw ValidationException(\\"Age must be between 0 and 120\\")\\n  \\n  User(name, age)\\n}\\n```\\n\\nSnitch\'s validator system offers several advantages:\\n\\n1. **Transformation, not just validation**: Validators both validate and transform data into domain types\\n2. **Kotlin-native**: Leverages Kotlin\'s type system rather than external DSLs\\n3. **Composable validators**: Validators can be combined and reused\\n4. **Automatic documentation**: Validators automatically feed into API documentation\\n\\n## Conditions System: Spring Security and Rails CanCan\\n\\nThe conditions system in Snitch draws inspiration from Spring Security\'s expression-based access control and Ruby\'s CanCan authorization library.\\n\\n**Spring Security (Java):**\\n```java\\n@PreAuthorize(\\"hasRole(\'ADMIN\') or #userId == authentication.principal.id\\")\\npublic User getUser(@PathVariable Long userId) {\\n  return userRepository.findById(userId);\\n}\\n```\\n\\n**CanCan (Ruby):**\\n```ruby\\nclass Ability\\n  include CanCan::Ability\\n  \\n  def initialize(user)\\n    can :manage, Post, user_id: user.id\\n    can :manage, :all if user.admin?\\n  end\\nend\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nval hasAdminRole = condition(\\"hasAdminRole\\") {\\n  when (role) {\\n    ADMIN -> ConditionResult.Successful\\n    else -> ConditionResult.Failed(\\"Not an admin\\".forbidden())\\n  }\\n}\\n\\nval isResourceOwner = condition(\\"isResourceOwner\\") {\\n  if (principal.id == request[resourceId]) ConditionResult.Successful\\n  else ConditionResult.Failed(\\"Not the resource owner\\".forbidden())\\n}\\n\\nGET(\\"resource\\" / resourceId) onlyIf (isResourceOwner or hasAdminRole) isHandledBy { getResource() }\\n```\\n\\nSnitch\'s condition system provides several key improvements:\\n\\n1. **Composable boolean logic**: Operators like `and`, `or`, and `not` work naturally\\n2. **Route-level application**: Conditions can be applied at the route level for fine-grained control\\n3. **Custom error responses**: Each condition can specify its own error response\\n4. **Type safety**: Leverages Kotlin\'s type system for compile-time validation\\n5. **Self-documenting**: Conditions automatically document access requirements in API docs\\n\\n## Automated Documentation: Swagger and Springfox\\n\\nSnitch\'s automatic documentation system was inspired by Swagger/OpenAPI and tools like Springfox, but with a focus on zero-config operation.\\n\\n**Springfox (Java):**\\n```java\\n@ApiOperation(value = \\"Get a user by ID\\", notes = \\"Requires authentication\\")\\n@ApiResponses(value = {\\n    @ApiResponse(code = 200, message = \\"Success\\", response = User.class),\\n    @ApiResponse(code = 404, message = \\"User not found\\")\\n})\\n@GetMapping(\\"/users/{id}\\")\\npublic ResponseEntity<User> getUser(@PathVariable(\\"id\\") @ApiParam(value = \\"User ID\\") Long id) {\\n    // ...\\n}\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\n// No annotations required - documentation is derived from code\\nval userId by path(ofNonNegativeInt)\\n\\nGET(\\"users\\" / userId) isHandledBy {\\n    val user = userRepository.findUser(request[userId])\\n    if (user != null) user.ok\\n    else \\"User not found\\".notFound()\\n}\\n```\\n\\nSnitch\'s documentation approach offers substantial benefits:\\n\\n1. **Zero annotations**: No extra code needed for documentation\\n2. **Always accurate**: Documentation derived directly from routes, parameters, and handler code\\n3. **Type information**: Response types automatically included in documentation\\n4. **Interactive UI**: Swagger UI available automatically\\n5. **No out-of-sync docs**: Documentation cannot become outdated as it\'s generated from code\\n\\n## Performance Inspiration: Undertow and Vert.x\\n\\nSnitch\'s performance focus was inspired by high-performance servers like Undertow and Vert.x.\\n\\n**Undertow (Java):**\\n```java\\nUndertow server = Undertow.builder()\\n    .addHttpListener(8080, \\"localhost\\")\\n    .setHandler(exchange -> {\\n        exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, \\"text/plain\\");\\n        exchange.getResponseSender().send(\\"Hello World\\");\\n    }).build();\\nserver.start();\\n```\\n\\n**Vert.x (Java):**\\n```java\\nVertx vertx = Vertx.vertx();\\nHttpServer server = vertx.createHttpServer();\\n\\nserver.requestHandler(request -> {\\n  request.response()\\n    .putHeader(\\"content-type\\", \\"text/plain\\")\\n    .end(\\"Hello world!\\");\\n});\\n\\nserver.listen(8080);\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nsnitch(GsonJsonParser)\\n    .onRoutes {\\n        GET(\\"hello\\") isHandledBy { \\"Hello world\\".ok }\\n    }\\n    .start()\\n```\\n\\nWhile Snitch provides a higher-level API, it maintains excellent performance by:\\n\\n1. **Thin abstraction layer**: Minimal overhead on top of Undertow\\n2. **No reflection in hot paths**: Avoiding the performance costs of reflection\\n3. **Inlining**: Using Kotlin\'s inline functions to eliminate function call overhead\\n4. **Minimal object creation**: Avoiding excessive object instantiation that could increase GC pressure\\n\\n## DSL Design: Inspired by Kotlin\'s Built-in DSLs\\n\\nSnitch\'s DSL design draws heavily on Kotlin\'s own built-in DSLs like the ones for building HTML or type-safe SQL with Exposed.\\n\\n**Kotlin HTML DSL:**\\n```kotlin\\nhtml {\\n    head {\\n        title(\\"HTML Example\\")\\n    }\\n    body {\\n        h1 { +\\"Hello, world!\\" }\\n        div {\\n            p { +\\"This is a paragraph\\" }\\n        }\\n    }\\n}\\n```\\n\\n**Snitch (Kotlin):**\\n```kotlin\\nroutes {\\n    \\"api\\" / {\\n        \\"v1\\" / {\\n            \\"users\\" / {\\n                GET() isHandledBy { getAllUsers() }\\n                POST() with body<CreateUserRequest>() isHandledBy { createUser() }\\n                \\n                userId / {\\n                    GET() isHandledBy { getUser() }\\n                    PUT() with body<UpdateUserRequest>() isHandledBy { updateUser() }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSnitch\'s DSL leverages Kotlin-specific features:\\n\\n1. **Type-safe builders**: Like Kotlin\'s HTML DSL, but for HTTP routes\\n2. **Infix functions**: Creating a readable, almost English-like syntax\\n3. **Extension functions**: Extending existing types for a more natural API\\n4. **Lambdas with receivers**: Creating natural scoping and reducing boilerplate\\n5. **Immutable data structures**: Promoting safe, predictable code\\n\\n## Conclusion: Best Ideas, Better Implementation\\n\\nSnitch didn\'t try to reinvent the wheel. Instead, we carefully studied what made other frameworks great, then adapted those ideas to create something that takes full advantage of Kotlin\'s strengths while avoiding common framework pitfalls.\\n\\nWhat makes Snitch special isn\'t just the features it borrowed, but how it integrated them into a cohesive whole that emphasizes:\\n\\n- **Type safety** without verbosity\\n- **Explicitness** without boilerplate\\n- **Performance** without complexity\\n- **Flexibility** without magic\\n\\nBy standing on the shoulders of giants - taking inspiration from frameworks like Sinatra, Express, Rails, Spring, and Ktor - we\'ve created something that feels natural and powerful for Kotlin developers.\\n\\nWe\'d love to hear which aspects of Snitch you find most valuable, and what other frameworks you\'ve used that have features you\'d like to see adapted to the Kotlin ecosystem. Join us on [Discord](https://discord.gg/bG6NW3UyxS) to share your thoughts and experiences!"},{"id":"unlocking-advanced-web-apis-with-snitch","metadata":{"permalink":"/blog/unlocking-advanced-web-apis-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2022-02-18-unlocking-advanced-web-apis-with-snitch.md","source":"@site/blog/2022-02-18-unlocking-advanced-web-apis-with-snitch.md","title":"Unlocking Advanced Web APIs with Snitch","description":"Building production-grade HTTP APIs can be complex and time-consuming. Many frameworks offer simplicity at the cost of readability or performance when systems grow beyond simple examples. Today, I\'m excited to introduce you to Snitch: a Kotlin HTTP framework that prioritizes readability and maintainability while delivering exceptional performance and a powerful feature set.","date":"2022-02-18T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Web Development","permalink":"/blog/tags/web-development","description":"Articles related to web development technologies and approaches"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"},{"inline":false,"label":"APIs","permalink":"/blog/tags/apis","description":"Content discussing API design, implementation, and best practices"},{"inline":false,"label":"DSL","permalink":"/blog/tags/dsl","description":"Articles about Domain Specific Languages and their applications"}],"readingTime":5.395,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"unlocking-advanced-web-apis-with-snitch","title":"Unlocking Advanced Web APIs with Snitch","authors":["snitch-team"],"tags":["snitch","web-development","kotlin","apis","dsl"]},"unlisted":false,"prevItem":{"title":"The Inspiration Behind Snitch - Borrowing from the Best","permalink":"/blog/the-inspiration-behind-snitch"},"nextItem":{"title":"Building Lightweight Microservices with Snitch","permalink":"/blog/lightweight-microservices-with-snitch"}},"content":"Building production-grade HTTP APIs can be complex and time-consuming. Many frameworks offer simplicity at the cost of readability or performance when systems grow beyond simple examples. Today, I\'m excited to introduce you to **Snitch**: a Kotlin HTTP framework that prioritizes readability and maintainability while delivering exceptional performance and a powerful feature set.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Essence of Snitch\\n\\nSnitch was created to solve a fundamental problem: as web APIs grow more complex, codebase readability often suffers. Many frameworks prioritize conventions over explicit configuration, which can lead to obscure runtime errors and steep learning curves for new team members.\\n\\nHere\'s what makes Snitch different:\\n\\n- **Expressive, readable DSL** that makes complex route hierarchies understandable at a glance\\n- **Strong type safety** that catches errors at compile time rather than runtime\\n- **Minimal overhead** by leveraging Kotlin\'s inline functions and a thin layer over high-performance servers\\n- **Automated documentation** generation without additional configuration\\n- **No reflection magic** in production code, making it easier to understand and debug\\n\\nFor many developers, that \\"aha!\\" moment with Snitch comes when they first see how explicitly yet concisely they can model intricate API structures:\\n\\n```kotlin\\nval usersController = routes {\\n    POST() with body<CreateUserRequest>() isHandledBy createUser\\n    \\n    userId / \\"posts\\" / {\\n        authenticated {\\n            GET() onlyIf principalEquals(userId) isHandledBy getPosts\\n            POST() onlyIf principalEquals(userId) with body<CreatePostRequest>() isHandledBy createPost\\n            \\n            GET(postId) isHandledBy getPost\\n            DELETE(postId) onlyIf (principalEquals(userId) or hasAdminRole) isHandledBy deletePost\\n        }\\n    }\\n}\\n```\\n\\nThis declarative style strikes an impressive balance between readability and expressiveness, making it immediately clear what routes are available and what security constraints apply.\\n\\n## The Validation System: Transform Raw Inputs into Domain Types\\n\\nSnitch\'s validator system addresses a critical challenge in HTTP API development: safely converting raw string inputs into strongly-typed domain objects. Let\'s look at what makes this system powerful:\\n\\n```kotlin\\n// Define custom domain types\\ndata class UserId(val value: String)\\ndata class PostId(val value: String)\\n\\n// Create validators that validate and transform raw inputs\\nval ofUserId = validator<String, UserId>(\\"valid user ID\\", \\"\\"\\"^[a-zA-Z0-9]{8,12}$\\"\\"\\".toRegex()) {\\n    UserId(it)\\n}\\n\\n// Use validators with parameters\\nval userId by path(ofUserId)\\nval postId by path(ofPostId)\\n\\n// Access validated, typed parameters in handlers\\nval getPost by handling {\\n    val user: UserId = request[userId]\\n    val post: PostId = request[postId]\\n    \\n    postRepository.findPost(user, post).ok\\n}\\n```\\n\\nWith this approach, validations happen before your handler code runs, so you\'re always working with properly validated, domain-specific types. If validation fails, the framework returns appropriate 400-level responses automatically, with descriptive error messages that help API consumers fix their requests.\\n\\n## Before and After Actions: Tackle Cross-Cutting Concerns Elegantly\\n\\nOne of Snitch\'s newer features that I find particularly elegant is its **before and after** action system. This lets you execute code around your handlers in a clean, composable way:\\n\\n```kotlin\\nGET(\\"users\\" / userId)\\n    .doBefore { \\n        // Authentication check\\n        if (request[accessToken] is Authentication.Unauthenticated) {\\n            return@doBefore \\"Unauthorized\\".unauthorized()\\n        }\\n    }\\n    .doBefore {\\n        // Logging\\n        logger.info(\\"User access: ${request[userId]}\\")\\n        request.attributes[\\"startTime\\"] = System.currentTimeMillis()\\n    }\\n    .doAfter { \\n        // Performance tracking\\n        val duration = System.currentTimeMillis() - (request.attributes[\\"startTime\\"] as Long)\\n        metrics.recordRequestTime(request.path, duration)\\n    }\\n    .isHandledBy {\\n        userRepository.findUser(request[userId]).ok\\n    }\\n```\\n\\nWhat\'s fascinating about this approach is its flexibility and readability. The before/after actions have full access to the request context, can short-circuit execution with early responses, and can be composed together in intuitive ways. For cross-cutting concerns like logging, metrics, authentication, and authorization, this provides a clean separation of those aspects from your core business logic.\\n\\n## Conditions: Sophisticated Access Control Made Simple\\n\\nSnitch\'s condition system is another gem worth exploring. It allows for incredibly expressive access control rules that are both readable and maintainable:\\n\\n```kotlin\\nval isResourceOwner = condition(\\"isResourceOwner\\") {\\n    if (principal.id == request[resourceId]) ConditionResult.Successful\\n    else ConditionResult.Failed(\\"Not the resource owner\\".forbidden())\\n}\\n\\nval hasAdminRole = condition(\\"hasAdminRole\\") {\\n    when (role) {\\n        ADMIN -> ConditionResult.Successful\\n        else -> ConditionResult.Failed(\\"Not an admin\\".forbidden())\\n    }\\n}\\n\\n// Apply conditions to endpoints\\nDELETE(\\"posts\\" / postId) onlyIf (isResourceOwner or hasAdminRole) isHandledBy deletePost\\n```\\n\\nThe most impressive aspect here is the support for logical operators (`and`, `or`, `not`) that work exactly as you\'d expect, making complex access control rules both expressive and maintainable.\\n\\n## Decoration: Reusable Middleware Patterns\\n\\nThe decoration system in Snitch provides a flexible way to wrap behavior around route handlers:\\n\\n```kotlin\\nval withLogging = decorateWith {\\n    logger.info(\\"Begin Request: ${request.method} ${request.path}\\")\\n    next().also {\\n        logger.info(\\"End Request: ${request.method} ${request.path} ${it.statusCode} (${System.currentTimeMillis() - startTime}ms)\\")\\n    }\\n}\\n\\nval withTransaction = decorateWith {\\n    transaction {\\n        next()\\n    }\\n}\\n\\n// Apply to routes\\nwithLogging {\\n    withTransaction {\\n        POST(\\"orders\\") isHandledBy createOrder\\n    }\\n}\\n```\\n\\nThe `next()` function is the key - it executes the next decoration in the chain or the handler itself, allowing for pre and post-processing while maintaining a clean control flow.\\n\\n## Everything Unified by Documentation\\n\\nPerhaps the most impressive feature - one that developers typically dread implementing - is automatic API documentation. Snitch generates OpenAPI 3.0 documentation without any additional configuration:\\n\\n```kotlin\\nsnitch(GsonJsonParser)\\n    .onRoutes(myRoutes)\\n    .generateDocumentation()\\n    .servePublicDocumentation()\\n    .start()\\n```\\n\\nWith this minimal setup, you get a full Swagger UI that accurately reflects your API, including:\\n- All routes and their HTTP methods\\n- Path, query, and header parameters with their validators and descriptions\\n- Request and response body schemas\\n- Authentication requirements\\n- Possible response status codes\\n\\nThe magic here is that this documentation is derived directly from your code, so it\'s always accurate and up-to-date.\\n\\n## Performance Without Compromise\\n\\nBeyond the elegant API, Snitch delivers impressive performance. By using Undertow as the default embedded server and carefully avoiding reflection and excessive object creation, it achieves near-native performance while maintaining its expressive DSL.\\n\\nA typical Snitch application has a tiny memory footprint (as low as 12MB of RAM on top of the JVM) and minimal startup time, making it suitable for everything from microservices to Android applications.\\n\\n## Conclusion: A Framework That Grows With You\\n\\nWhat I find most compelling about Snitch is how it scales with complexity. Simple APIs remain simple, but as your requirements grow more sophisticated - with nested routes, complex access control, detailed validation, and cross-cutting concerns - the code remains readable and maintainable.\\n\\nSnitch achieves this by providing powerful abstractions that are composable and explicit, avoiding the \\"magic\\" that often makes frameworks hard to reason about as applications grow.\\n\\nIf you\'re building HTTP APIs in Kotlin and value both expressiveness and type safety, Snitch deserves a serious look. Its combination of a readable DSL, sophisticated features like validators and conditions, and exceptional performance makes it a compelling choice for professional API development.\\n\\nTo get started with Snitch, check out the [comprehensive tutorials](/docs/tutorials/Mastering-Snitch-Parameters) in our documentation section, or dive right into the [example application](https://github.com/memoizr/snitch/tree/master/example) on GitHub."},{"id":"lightweight-microservices-with-snitch","metadata":{"permalink":"/blog/lightweight-microservices-with-snitch","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2021-09-25-lightweight-microservices-with-snitch.md","source":"@site/blog/2021-09-25-lightweight-microservices-with-snitch.md","title":"Building Lightweight Microservices with Snitch","description":"Microservice architectures promise scalability and development agility, but they often come with significant overhead - both in terms of resource requirements and development complexity. Snitch offers a compelling approach to microservices that maintains the benefits while drastically reducing the costs.","date":"2021-09-25T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"Microservices","permalink":"/blog/tags/microservices","description":"Content about microservice architecture and implementation"},{"inline":false,"label":"Performance","permalink":"/blog/tags/performance","description":"Articles focusing on application performance and optimization"},{"inline":false,"label":"Deployment","permalink":"/blog/tags/deployment","description":"Content about deploying and managing applications"}],"readingTime":3.72,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"lightweight-microservices-with-snitch","title":"Building Lightweight Microservices with Snitch","authors":["snitch-team"],"tags":["snitch","microservices","performance","deployment"]},"unlisted":false,"prevItem":{"title":"Unlocking Advanced Web APIs with Snitch","permalink":"/blog/unlocking-advanced-web-apis-with-snitch"},"nextItem":{"title":"Beyond Annotations: Why Snitch\'s DSL Approach Improves Code Readability","permalink":"/blog/beyond-annotations-snitch-dsl"}},"content":"Microservice architectures promise scalability and development agility, but they often come with significant overhead - both in terms of resource requirements and development complexity. Snitch offers a compelling approach to microservices that maintains the benefits while drastically reducing the costs.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Microservice Resource Challenge\\n\\nTraditional Java-based microservices built with frameworks like Spring Boot often have substantial resource requirements:\\n\\n- **Memory footprint**: 300-500MB per service instance\\n- **Startup time**: 5-30 seconds\\n- **JAR size**: 15-50MB\\n- **CPU requirements**: Often 0.5-1 CPU cores minimum\\n\\nThese requirements lead to:\\n1. Higher cloud infrastructure costs\\n2. Slower scaling during traffic spikes\\n3. Inefficient resource utilization (many services idle at 10-20% CPU)\\n4. Painful development cycles (slow startup = slow feedback)\\n\\n## Snitch\'s Lightweight Approach\\n\\nSnitch was designed specifically to address these challenges:\\n\\n- **Memory footprint**: As low as 12MB RAM on top of JVM\\n- **Startup time**: Typically under 1 second\\n- **JAR size**: 2-5MB for simple services\\n- **CPU requirements**: Efficient use of available resources\\n\\nLet\'s look at the practical impact of these improvements for microservice architectures.\\n\\n## Ultra-Fast Startup: Enabling New Deployment Models\\n\\nSnitch\'s sub-second startup time enables deployment models that weren\'t practical with heavier frameworks:\\n\\n```kotlin\\n// A complete microservice in <20 lines\\nfun main() {\\n    snitch(GsonJsonParser)\\n        .onRoutes {\\n            \\"health\\" / {\\n                GET() isHandledBy { \\"OK\\".ok }\\n            }\\n            \\"api\\" / \\"products\\" / {\\n                GET() isHandledBy { productRepository.findAll().ok }\\n                GET(productId) isHandledBy { \\n                    productRepository.findById(request[productId])?.ok \\n                        ?: \\"Product not found\\".notFound() \\n                }\\n            }\\n        }\\n        .start()\\n}\\n```\\n\\nThis service starts in milliseconds, enabling:\\n\\n1. **True serverless deployments** with no cold start concerns\\n2. **Blue-green deployments** with instant switching\\n3. **Autoscaling** that responds immediately to traffic spikes\\n4. **Development hot-reloading** that\'s practically instantaneous\\n\\n## Minimal Memory Footprint: Density and Cost Benefits\\n\\nSnitch\'s tiny memory footprint means you can run many more services on the same hardware:\\n\\n| Framework  | Services per 16GB | Monthly Cost (AWS) |\\n|------------|------------------|-------------------|\\n| Spring Boot| ~30-40           | ~$250-300         |\\n| Snitch     | ~200-300         | ~$40-50           |\\n\\nThis translates directly to infrastructure cost savings, especially as your microservice ecosystem grows.\\n\\n## Container Optimization\\n\\nSnitch\'s lightweight nature makes it ideal for containerized environments:\\n\\n```dockerfile\\nFROM eclipse-temurin:17-jre-alpine\\nCOPY build/libs/my-service.jar /app/service.jar\\nCMD [\\"java\\", \\"-jar\\", \\"/app/service.jar\\"]\\n```\\n\\nThe resulting container images are remarkably small and efficient:\\n\\n- **Image size**: 50-100MB (vs. 300-500MB for typical Spring Boot services)\\n- **Startup time**: 1-2 seconds (vs. 10-30 seconds for typical Spring Boot services)\\n- **Resource usage**: Minimal, allowing high container density\\n\\nThis makes Snitch services ideal for Kubernetes, AWS ECS, or any containerized environment.\\n\\n## Real-World Microservice Patterns\\n\\nLet\'s look at how Snitch enables common microservice patterns:\\n\\n### Service-to-Service Communication\\n\\n```kotlin\\nval userClient = HttpClient.newBuilder().build()\\n\\nval getUserById by handling {\\n    val userId = request[userId]\\n    \\n    // Call user service\\n    val response = userClient.send(\\n        HttpRequest.newBuilder()\\n            .GET()\\n            .uri(URI.create(\\"http://user-service/users/$userId\\"))\\n            .build(),\\n        HttpResponse.BodyHandlers.ofString()\\n    )\\n    \\n    if (response.statusCode() == 200) {\\n        val user = parser.fromJson<User>(response.body())\\n        ProductWithUser(request[productId], user).ok\\n    } else {\\n        \\"User not found\\".notFound()\\n    }\\n}\\n```\\n\\n### Circuit Breaking\\n\\nSnitch works seamlessly with resilience libraries:\\n\\n```kotlin\\nval circuitBreaker = CircuitBreaker.ofDefaults(\\"userService\\")\\n\\nval getUserWithResilience by handling {\\n    val userId = request[userId]\\n    \\n    try {\\n        val user = circuitBreaker.executeSupplier {\\n            userService.getUser(userId)\\n        }\\n        ProductWithUser(request[productId], user).ok\\n    } catch (e: CallNotPermittedException) {\\n        \\"User service unavailable\\".serviceUnavailable()\\n    }\\n}\\n```\\n\\n### Service Discovery\\n\\n```kotlin\\nval serviceRegistry = ServiceRegistry.getInstance()\\n\\nval dynamicServiceCall by handling {\\n    val serviceUrl = serviceRegistry.getService(\\"payment-service\\")\\n    val response = httpClient.send(\\n        HttpRequest.newBuilder()\\n            .POST(HttpRequest.BodyPublishers.ofString(request[paymentRequest]))\\n            .uri(URI.create(\\"$serviceUrl/payments\\"))\\n            .build(),\\n        HttpResponse.BodyHandlers.ofString()\\n    )\\n    \\n    if (response.statusCode() == 201) {\\n        val payment = parser.fromJson<Payment>(response.body())\\n        payment.created\\n    } else {\\n        \\"Payment failed\\".badRequest()\\n    }\\n}\\n```\\n\\n## Development Experience Benefits\\n\\nBeyond deployment advantages, Snitch improves the microservice development experience:\\n\\n1. **Fast feedback loop** - Services start in milliseconds\\n2. **Consistent patterns** - The same DSL works for tiny and complex services\\n3. **Low cognitive overhead** - Routes and handlers are explicit and readable\\n4. **Automated documentation** - OpenAPI specs generated automatically\\n\\nThese benefits make it much more pleasant to work in a microservice architecture, reducing the \\"microservice tax\\" on developer productivity.\\n\\n## Conclusion: Microservices Without the Weight\\n\\nMicroservices don\'t have to be heavyweight. Snitch proves that you can have the architectural benefits of microservices - isolation, independent scaling, technology flexibility - without the traditional resource costs and development overhead.\\n\\nBy focusing on performance fundamentals and a minimal, expressive API, Snitch enables microservice architectures that are both more cost-effective and more developer-friendly.\\n\\nNext time you\'re planning a microservice architecture and dreading the resource requirements, consider Snitch as an alternative that might give you the best of both worlds: the flexibility of microservices with the efficiency of a monolith."},{"id":"beyond-annotations-snitch-dsl","metadata":{"permalink":"/blog/beyond-annotations-snitch-dsl","editUrl":"https://github.com/memoizr/snitch/tree/main/guides/blog/2021-04-15-beyond-annotations-snitch-dsl.md","source":"@site/blog/2021-04-15-beyond-annotations-snitch-dsl.md","title":"Beyond Annotations: Why Snitch\'s DSL Approach Improves Code Readability","description":"When examining modern web frameworks, one pattern appears consistently: the heavy use of annotations to configure behavior. From Spring\'s @RequestMapping to JAX-RS\'s @Path, annotations have become the standard way to define routes, validation, and more. But Snitch takes a different approach with its expressive DSL. Here\'s why that matters for your codebase.","date":"2021-04-15T00:00:00.000Z","tags":[{"inline":false,"label":"Snitch","permalink":"/blog/tags/snitch","description":"Posts about the Snitch HTTP framework for Kotlin"},{"inline":false,"label":"DSL","permalink":"/blog/tags/dsl","description":"Articles about Domain Specific Languages and their applications"},{"inline":false,"label":"Code Quality","permalink":"/blog/tags/code-quality","description":"Articles about improving code readability, maintainability, and quality"},{"inline":false,"label":"Kotlin","permalink":"/blog/tags/kotlin","description":"Posts about the Kotlin programming language and its ecosystem"}],"readingTime":3.635,"hasTruncateMarker":true,"authors":[{"name":"Snitch Team","title":"Snitch Framework Maintainers","url":"https://github.com/memoizr/snitch","page":{"permalink":"/blog/authors/snitch-team"},"imageURL":"https://github.com/memoizr.png","key":"snitch-team"}],"frontMatter":{"slug":"beyond-annotations-snitch-dsl","title":"Beyond Annotations: Why Snitch\'s DSL Approach Improves Code Readability","authors":["snitch-team"],"tags":["snitch","dsl","code-quality","kotlin"]},"unlisted":false,"prevItem":{"title":"Building Lightweight Microservices with Snitch","permalink":"/blog/lightweight-microservices-with-snitch"}},"content":"When examining modern web frameworks, one pattern appears consistently: the heavy use of annotations to configure behavior. From Spring\'s `@RequestMapping` to JAX-RS\'s `@Path`, annotations have become the standard way to define routes, validation, and more. But Snitch takes a different approach with its expressive DSL. Here\'s why that matters for your codebase.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem with Annotation Overload\\n\\nAnnotations are undeniably convenient - they let you attach metadata to your code without affecting its execution flow. However, as applications grow in complexity, annotation-heavy code creates several challenges:\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/api/users\\")\\npublic class UserController {\\n    @GetMapping(\\"/{id}\\")\\n    @Operation(summary = \\"Get user by ID\\")\\n    @ApiResponses({\\n        @ApiResponse(responseCode = \\"200\\", description = \\"User found\\"),\\n        @ApiResponse(responseCode = \\"404\\", description = \\"User not found\\")\\n    })\\n    public ResponseEntity<User> getUser(\\n        @PathVariable(\\"id\\") @Min(1) Long id,\\n        @RequestHeader(required = false) String authorization\\n    ) {\\n        // Actual business logic is buried under annotations\\n        return userService.findById(id)\\n            .map(ResponseEntity::ok)\\n            .orElse(ResponseEntity.notFound().build());\\n    }\\n}\\n```\\n\\nThe issues with this approach include:\\n\\n1. **Signal-to-noise ratio** - The actual business logic gets buried under layers of configuration\\n2. **Scattered information** - Related functionality is spread across multiple annotations\\n3. **Limited composition** - Annotations can\'t be easily combined or reused\\n4. **Runtime discovery** - Annotation errors are only found at runtime\\n5. **Limited expressiveness** - Annotations can\'t express complex relationships easily\\n\\n## Snitch\'s DSL: Code That Reads Like Intent\\n\\nSnitch\'s DSL approach shifts the focus from decorating methods to describing intent:\\n\\n```kotlin\\nval userId by path(ofLong)\\n\\nroutes {\\n    \\"api\\" / \\"users\\" / {\\n        GET(userId) isHandledBy {\\n            userService.findById(request[userId])\\n                ?.ok\\n                ?: \\"User not found\\".notFound()\\n        }\\n    }\\n}\\n```\\n\\nThis approach offers several readability advantages:\\n\\n1. **Hierarchical organization** - The route structure is visually apparent\\n2. **Explicit parameters** - Parameters are defined and referenced explicitly\\n3. **Natural language flow** - Infix functions like `isHandledBy` create readable sentences\\n4. **Visual distinction** - HTTP methods stand out, making API surface clear at a glance\\n5. **Focused handlers** - Business logic stands out rather than being buried in configuration\\n\\n## Structure That Mirrors Your API\\n\\nOne of the most powerful aspects of Snitch\'s DSL is how the code structure visually represents the API structure:\\n\\n```kotlin\\nroutes {\\n    \\"api\\" / {\\n        \\"v1\\" / {\\n            \\"users\\" / {\\n                GET() isHandledBy getAllUsers\\n                POST() with userBody isHandledBy createUser\\n                \\n                userId / {\\n                    GET() isHandledBy getUser\\n                    PUT() with userBody isHandledBy updateUser\\n                    DELETE() isHandledBy deleteUser\\n                    \\n                    \\"posts\\" / {\\n                        GET() isHandledBy getUserPosts\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nThe nested structure creates a visual map of your API. You can immediately see that `/api/v1/users/{userId}/posts` is a valid endpoint without tracing through multiple class files or annotations.\\n\\n## Composition Over Configuration\\n\\nUnlike annotations, which are static metadata, Snitch\'s DSL enables powerful composition:\\n\\n```kotlin\\n// Define reusable route groups\\nval userRoutes = routes {\\n    GET(userId) isHandledBy getUser\\n    PUT(userId) with userBody isHandledBy updateUser\\n    DELETE(userId) isHandledBy deleteUser\\n}\\n\\nval postRoutes = routes {\\n    GET(postId) isHandledBy getPost\\n    PUT(postId) with postBody isHandledBy updatePost\\n    DELETE(postId) isHandledBy deletePost\\n}\\n\\n// Compose them into a complete API\\nval apiRoutes = routes {\\n    \\"users\\" / {\\n        GET() isHandledBy getAllUsers\\n        POST() with userBody isHandledBy createUser\\n        userId / userRoutes\\n    }\\n    \\n    \\"posts\\" / {\\n        GET() isHandledBy getAllPosts\\n        POST() with postBody isHandledBy createPost\\n        postId / postRoutes\\n    }\\n}\\n```\\n\\nThis composability makes your code more modular and reusable, without sacrificing readability.\\n\\n## The Power of Infix Functions\\n\\nKotlin\'s infix functions are a key enabler of Snitch\'s readable DSL:\\n\\n```kotlin\\nGET(\\"users\\" / userId) withQueries (limit, offset) onlyIf hasAdminRole isHandledBy getUser\\n```\\n\\nThis reads almost like English - \\n\\n `GET users/{userId} with queries limit and offset, only if user has admin role, is handled by getUser function.`\\n\\nThe infix approach creates a clear flow from HTTP method to path to conditions to handler, making the intent immediately clear even to developers new to the codebase.\\n\\n## Conclusion: DSLs as Documentation\\n\\nPerhaps the greatest benefit of Snitch\'s DSL approach is that your code becomes its own documentation. New team members can quickly understand the API surface, routing logic, and authorization rules by simply reading the route definitions.\\n\\nWhile annotations have their place, a well-designed DSL can dramatically improve code readability and maintainability, especially for complex HTTP APIs. By making the structure explicit and the intent clear, Snitch helps you build APIs that are not only powerful but also a joy to work with.\\n\\nNext time you find yourself wading through layers of annotations trying to understand an API\'s structure, remember there\'s a more expressive alternative available."}]}}')}}]);